---
title: Golden File Standard
type: standard
status: active
version: 1.4.0
created: 2025-01-XX
updated: 2025-01-XX
tags: [standard, frontmatter, validation, bun-platform, architecture, governance]
category: development
description: Comprehensive standard for all vault files - frontmatter, structure, validation, and governance
usage: Reference for creating, validating, and maintaining vault files. Enforced by bun-platform tooling.
author: // Run initial health check on all templates
const { TemplateHealthMonitor } = require('./06-Templates/validation/template-health-monitor.js');

const monitor = new TemplateHealthMonitor();
const initialReport = await monitor.scanAllTemplates();

// Create initial health report
const healthReport = `
# ü©∫ Initial Template Health Report
**Generated**: ${new Date().toISOString()}

## üìä Summary
- **Total Templates**: ${initialReport.summary.total}
- **Healthy**: ${initialReport.summary.healthy}
- **With Issues**: ${initialReport.summary.errors}
- **Health Score**: ${((initialReport.summary.healthy / initialReport.summary.total) * 100).toFixed(1)}%

## üö® Issues Found
${initialReport.templates.filter(t => t.issues.length > 0).map(template => `
### ${template.template}
${template.issues.map(issue => 
  `- **${issue.field}**: Expected ${issue.expected}, got ${issue.actual} (value: ${issue.value})`
).join('\n')}
`).join('\n')}

## ‚úÖ Healthy Templates
${initialReport.templates.filter(t => t.issues.length === 0).map(t => `- ${t.template}`).join('\n')}

## üéØ Next Steps
1. Fix field type mismatches in problematic templates
2. Implement pre-commit validation hooks
3. Schedule regular health checks
4. Monitor template usage patterns
`;

await fs.writeFile('06-Templates/validation/initial-health-report.md', healthReport);// Run initial health check on all templates
const { TemplateHealthMonitor } = require('./06-Templates/validation/template-health-monitor.js');

const monitor = new TemplateHealthMonitor();
const initialReport = await monitor.scanAllTemplates();

// Create initial health report
const healthReport = `
# ü©∫ Initial Template Health Report
**Generated**: ${new Date().toISOString()}

## üìä Summary
- **Total Templates**: ${initialReport.summary.total}
- **Healthy**: ${initialReport.summary.healthy}
- **With Issues**: ${initialReport.summary.errors}
- **Health Score**: ${((initialReport.summary.healthy / initialReport.summary.total) * 100).toFixed(1)}%

## üö® Issues Found
${initialReport.templates.filter(t => t.issues.length > 0).map(template => `
### ${template.template}
${template.issues.map(issue => 
  `- **${issue.field}**: Expected ${issue.expected}, got ${issue.actual} (value: ${issue.value})`
).join('\n')}
`).join('\n')}

## ‚úÖ Healthy Templates
${initialReport.templates.filter(t => t.issues.length === 0).map(t => `- ${t.template}`).join('\n')}

## üéØ Next Steps
1. Fix field type mismatches in problematic templates
2. Implement pre-commit validation hooks
3. Schedule regular health checks
4. Monitor template usage patterns
`;

await fs.writeFile('06-Templates/validation/initial-health-report.md', healthReport);// Run initial health check on all templates
const { TemplateHealthMonitor } = require('./06-Templates/validation/template-health-monitor.js');

const monitor = new TemplateHealthMonitor();
const initialReport = await monitor.scanAllTemplates();

// Create initial health report
const healthReport = `
# ü©∫ Initial Template Health Report
**Generated**: ${new Date().toISOString()}

## üìä Summary
- **Total Templates**: ${initialReport.summary.total}
- **Healthy**: ${initialReport.summary.healthy}
- **With Issues**: ${initialReport.summary.errors}
- **Health Score**: ${((initialReport.summary.healthy / initialReport.summary.total) * 100).toFixed(1)}%

## üö® Issues Found
${initialReport.templates.filter(t => t.issues.length > 0).map(template => `
### ${template.template}
${template.issues.map(issue => 
  `- **${issue.field}**: Expected ${issue.expected}, got ${issue.actual} (value: ${issue.value})`
).join('\n')}
`).join('\n')}

## ‚úÖ Healthy Templates
${initialReport.templates.filter(t => t.issues.length === 0).map(t => `- ${t.template}`).join('\n')}

## üéØ Next Steps
1. Fix field type mismatches in problematic templates
2. Implement pre-commit validation hooks
3. Schedule regular health checks
4. Monitor template usage patterns
`;

// Run initial health check on all templates
await fs.writeFile('06-Templates/validation/initial-health-report.md', healthReport);

---

# üìê GOLDEN_FILE_STANDARD.md: Obsidian Vault Governance & Interoperability

**Document Version:** `v1.4.0` *(New feature: Atomic Source File Header Standard added)*

**Last Updated:** `2025-01-XX` *(Auto-generated by `bun-platform`)*

**Owner:** Kimi2 Architecture Governance Board (`@arch-gov-board`)

**Related EPICs:** K2-ARCH-012 (Dedicated Dynamic Architecture Canvas), K2-TOOL-005 (Frontmatter Validation Suite)

**Purpose:** To codify the immutable and adaptable standards for file organization, naming, linking, content structure, and metadata within the Kimi2 Obsidian Vault. This standard ensures maximum interoperability with `bun-platform` tooling, robust architectural governance, and sustainable knowledge management for the entire team. This document itself serves as a **primary architectural artifact**.

---

## 0. The "Living Standard" Philosophy

This `GOLDEN_FILE_STANDARD.md` is not static. It is a **"Living Standard"** that directly drives and is driven by our `BUN:FIRST` platform's automation. Adherence is non-negotiable for system integrity. Deviations trigger automated alerts and mandate immediate reconciliation via `bun-platform` tooling.

- **Self-Updating**: `updated` date is automatically updated on commit/deploy by `bun-platform`.
- **Self-Validating**: `bun-platform validate` ensures compliance of the vault's contents against *this document's directives*.
- **Self-Correcting**: `bun-platform create-note` and `bun-platform update-note` adhere to and enforce these rules during note lifecycle.

---

## 1. Core Principles (Immutable Laws of the Vault)

All standards defined herein are derived from and enforce these core principles:

- **Machine-First Readability**: All naming, linking, and metadata (especially frontmatter and `component_id` tags) **must** be precisely parsable by `bun-platform` tools and AI agents. This is paramount for automation and architectural intelligence.

- **Human-Centric Usability**: While machine-first, the vault must remain intuitively navigable, clearly comprehensible, and rapidly searchable by all team members. Markdown is the preferred content format for human readability.

- **Absolute Consistency**: A singular, unified approach to organization and metadata management **must** be maintained across the entire vault. Variance inhibits automation and breeds confusion.

- **Atomic Knowledge Units**: Each note (`.md`) or canvas (`.canvas`) **must** represent a single, well-defined concept, component, or logical grouping, enabling modularity and precise linking.

- **Link-Centric Discoverability**: Knowledge discovery and navigation **must** prioritize semantic linking (`[[Wikilinks]]`) over reliance on static directory structures, fostering a rich knowledge graph.

- **`BUN:FIRST` Alignment**: All conventions, particularly for `component_id`s, **must** reflect and reinforce our `BUN:FIRST` strategic imperative for platform development.

---

## 2. Vault Structure & Directory Naming (The Physical Manifestation of Architecture)

The vault's top-level directory structure **must explicitly mirror the `[DOMAIN/PATH]` segments of `architecture.json`** where applicable. This provides a direct, verifiable mapping from the architectural blueprint to the physical location of its documentation.

### Root Structure

- **`_templates/`**: **Canonical source for note creation.** Contains all `bun-platform create-note` templates (e.g., `_templates/arch-component.md`, `_templates/refactor-proposal.md`).

- **`Architecture/`**: **The core architectural definition and visualization space.**
  - `Components.canvas`: **The single, dynamically managed architecture canvas, automatically synced by `bun-platform update-canvas-colors`.**
  - `Overview.md`: High-level platform architecture summary (`[PLATFORM/CORE/KIMI2_vX.Y.Z][TYPE:OVERVIEW]`).
  - `DomainMaps/`: Sub-directories for domain-specific architectural views and deep-dives.

- **`Components/`**: **Dedicated home for detailed documentation of individual architectural components.** Structure *must directly reflect* `[DOMAIN/PATH/COMPONENT_NAME]` segments.
  - `Data/`: (Corresponds to `DOMAIN:DATA`)
    - `Storage/`: (Corresponds to `PATH:STORAGE`)
      - `CoreDB/`: (Corresponds to `COMPONENT_NAME:COREDB`)
        - `Persistence.md`: The canonical note for `[DATA/STORAGE/COREDB/PERSISTENCE_vX.Y.Z]`.
      - `SubA/`:
        - `Service.md`: The canonical note for `[DATA/STORAGE/SUB_A/SERVICE_vX.Y.Z]`.
  - `Server/`: (Corresponds to `DOMAIN:SERVER`)
    - `Backend/`:
      - `ApiGateway/`:
        - `Runtime.md`: The canonical note for `[SERVER/BACKEND/APIGATEWAY/RUNTIME_vX.Y.Z]`.
  - *(...and so on for all `DOMAIN/PATH` segments defined in `architecture.json`)*

- **`Documentation/`**: General platform documentation, developer guides, and high-level conceptual notes.

- **`Operations/`**: Runbooks, deployment guides, incident response procedures, and monitoring dashboards (`[TYPE:RUNBOOK]`, `[TYPE:PROCEDURE]`).

- **`Research/`**: Exploratory notes, proof-of-concepts, unresolved questions, and competitive analysis (`[TYPE:RESEARCH]`).

- **`Inbox/`**: **Temporary holding area for new notes or auto-generated review documents.**
  - `INBOX_REVIEW.md`: **The dynamically generated Inbox Review document, updated by `bun-platform generate-inbox-review`.**

- **`Assets/`**: Static assets such as images, diagrams, and auto-generated reports.

### Directory Naming Rules

- **Case**: `PascalCase` for top-level directories (e.g., `Architecture`, `Documentation`). `Kebab-case` for sub-directories that map directly to `COMPONENT_NAME`s (e.g., `api-gateway`), or general-purpose sub-folders.

- **No Spaces**: Use `-` (kebab-case) or `_` (snake_case) for multi-word names.

- **Short & Semantic**: Directory names **must** be clear, concise, and reflect their content accurately.

- **Validation**: `bun-platform validate` will check directory structure against `architecture.json`'s `DOMAIN/PATH` segments.

### 2.1 Documentation Structure Patterns (`bun-platform` Enforced)

For complex documentation areas (e.g., optimizations, protocols, standards), use phase-based organization with master indexes:

#### Phase-Based Organization Pattern

```
Documentation-Area/
‚îú‚îÄ‚îÄ README.md                    # Master Index (Entry Point) - REQUIRED
‚îú‚îÄ‚îÄ Protocol/                    # Protocol Documentation (if applicable)
‚îú‚îÄ‚îÄ Phase-0-Name/                # Phase 0 Documentation
‚îÇ   ‚îî‚îÄ‚îÄ Sub-Area/
‚îÇ       ‚îú‚îÄ‚îÄ EXECUTION-LOG.md    # Execution log (if applicable)
‚îÇ       ‚îî‚îÄ‚îÄ GUIDE.md            # Practical guide (if applicable)
‚îú‚îÄ‚îÄ Phase-1-Name/                # Phase 1 Documentation
‚îú‚îÄ‚îÄ Standards/                   # Standards & Guidelines (if applicable)
‚îî‚îÄ‚îÄ Tools/                       # Tools & Utilities (if applicable)
```

**Requirements**:
- Every documentation area **must** have a `README.md` master index serving as the entry point
- Execution logs and guides **must** be paired in the same directory when both exist
- Phase organization **must** follow logical progression (Phase-0, Phase-1, etc.)
- Registry pattern **must** be used for discoverability (see [Registry/Index Pattern](#21-registryindex-pattern-bun-platform-enforced))

**Master Index Requirements** (`README.md`):
- **Quick Reference Table**: Tabular overview with links to all sub-documents
- **Phase Organization**: Phase-based breakdown (if applicable)
- **Performance Summary**: Aggregated performance metrics (if applicable)
- **Related Documentation**: Cross-references to related documentation

**Example Master Index Structure**:
```markdown
## üìã Quick Reference Table

| Phase | Item | Status | Execution Log | Guide | Performance Gain |
|-------|------|--------|---------------|-------|------------------|
| Phase 0 | Item 1 | ‚úÖ Complete | [[Link\|Log]] | [[Link\|Guide]] | 6‚Äì400√ó |

## üéØ Phase Organization

### Phase 0: Name
**Focus**: Description  
**Items**: Item 1, Item 2

## üìä Performance Summary

| Phase | Total Items | Average Performance Gain | Status |
|-------|-------------|--------------------------|--------|
| Phase 0 | 3 | 6‚Äì400√ó | ‚úÖ Complete |
```

#### Registry/Index Pattern (`bun-platform` Enforced)

For areas with multiple related documents, create a registry/index following this pattern:

**Required Sections**:
1. **Quick Reference Table**: Tabular overview with all items, links, and status
2. **Phase Organization**: Phase-based breakdown (if applicable)
3. **Performance Summary**: Aggregated metrics (if applicable)
4. **Related Documentation**: Cross-references to related docs

**Validation**: `bun-platform validate` will check for master indexes in major documentation areas.

---

## 3. File Naming Convention (`.md` notes & `.canvas` files)

File names are critical for human searchability and machine linking.

### Primary Notes (`.md`)

- **Convention**: `[ComponentName].md` or `[ComponentName].[SubPurpose].md`.
- **Examples**:
  - `Data/Storage/CoreDB/Persistence.md` (for `[DATA/STORAGE/COREDB/PERSISTENCE_vX.Y.Z]`)
  - `Server/Backend/ApiGateway/Runtime.md` (for `[SERVER/BACKEND/APIGATEWAY/RUNTIME_vX.Y.Z]`)
  - `Operations/Incident-Response-Plan-CRITICAL.md`
- **Avoid**: Dates, version numbers, or overly verbose descriptions in filenames (use frontmatter for detailed metadata). Filenames **must not** contain special characters that impede linking or file system operations (e.g., `!@#$%^&*`).

### Canvas Files (`.canvas`)

- **Convention**: `[CanvasName].canvas`.
- **Examples**: `Architecture/Components.canvas`, `Architecture/DomainMaps/Trade-Execution-Flow.canvas`.

---

## 4. Note Structure & Frontmatter (YAML) - The Machine-Readable Contract

Every primary note within the vault, especially those describing architectural components, **must** include a YAML frontmatter block. This block serves as the machine-readable contract for the note's metadata, enabling robust Dataview integration, automated tool processing, and architectural governance.

### 4.1 Mandatory Core Fields (All Notes - `bun-platform` Enforced)

These fields are **absolutely required** in the frontmatter of every note. `bun-platform validate` will check for their presence and format.

- `title`: `string` - Human-readable title of the note. **Must align with the H1 heading**.
- `type`: `string[]` - **Crucial: An array of component types or note classifications.** Each value **must** be from the [Authorized Type Values](#46-authorized-type-values-for-type-frontmatter-field--component_id-bun-platform-enforced) list. *(Example: `type: [service, api]`)*
- `status`: `string` - Current lifecycle status (`active | deprecated | draft | proposed | open | investigating | complete | resolved`). **Must be from an authorized enum.**
- `version`: `string` - Semantic version (e.g., `1.0.0`). If an architectural component, this **must match** the `vMAJOR.MINOR.PATCH` extracted from its `component_id`.
- `created`: `ISO Date` - Creation timestamp. Automatically populated by `bun-platform create-note`.
- `updated`: `ISO Date` - Last update timestamp. Automatically managed by `bun-platform` tools on relevant changes.
- `tags`: `string[]` - Array of relevant keywords (e.g., `[project, bun-first, database, hft]`). Tags **must be lowercase, kebab-case**.
- `category`: `string` - Broad classification (`architecture-governance`, `project-management`, `system-component`, `documentation`, `operations`, `research`). **Must be from an authorized enum.**
- `description`: `string` - Brief, one-sentence summary of the note's content or component's purpose. Max 160 characters.
- `usage`: `string` - Concise guidance on how/when to use this note or component, or the system it describes.
- `author`: `string` - Creator or primary maintainer (e.g., `bun-platform`, `Dev Team A`).
- `deprecated`: `boolean` - Set to `true` if the note/component is deprecated.

### 4.2 Mandatory `component_id` & Associated Fields (for Architectural Component Notes - `bun-platform` Enforced)

For any note detailing an architectural component (e.g., notes in the `Components/` directory), these fields are **mandatory**. They establish the definitive link to `architecture.json`.

- `component_id`: `string` - **The full, canonical, vectorable architectural ID string.** This is the immutable identity.
  - **Format**: `[DOMAIN/PATH/COMPONENT_NAME_vMAJOR.MINOR.PATCH][TYPE:VALUE1,VALUE2,...][#REF:GUID][CH:'HSL(h,s%,l%),hex(...),HEX(...)'][#META:KEY1=VAL1,KEY2=VAL2]`
  - **Validation**: This field is strictly validated by `bun-platform validate` against regex patterns and `architecture.json` contents.
- `ref`: `string` - The extracted `#REF` (GUID/Alias) from `component_id`. Used for stable linking.
- `channel_color`: `string` - The extracted primary color string (e.g., `HSL(h,s%,l%)` or `#RRGGBB`) from `component_id`'s `[CH:'...']` tag. Used for visual theming.
- *(Note: Fields like `type` and `version` from 4.1 will be automatically derived from and strictly validated against the `component_id` field by `bun-platform` tools to ensure consistency.)*

### 4.3 Common Optional Fields (by Category - `bun-platform` Assisted)

These fields are encouraged for specific types of notes to enrich context and enable advanced Dataview queries. `bun-platform` tools can assist in their population and validation.

#### Project Management

- `priority`: `string` - (`critical | high | medium | low | none`).
- `assignee`: `string` - Team or individual responsible.
- `due_date`: `ISO Date` - Target completion date.
- `estimated_hours`: `number` - Work estimate in hours.
- `progress`: `number` - Completion percentage (0-100).
- `related_projects`: `string[]` - Array of references/links (e.g., Jira ticket IDs, `[[Project Note]]`) to related projects.

#### Operational / Performance

- `bun_cli_version`: `string` - `bun-platform` CLI version used for last generation/interaction.
- `bun_runtime_version`: `string` - Bun runtime version deployed for this component/project.
- `generated_at`: `ISO Date` - Timestamp of auto-generation or last major update.
- `performance_metrics`: `object` - Nested object for key performance indicators (e.g., `p99_latency: 25ms`, `error_rate: 0.01`).
- `latency_p99_contract`: `string` - (e.g., `20ms`). Derived from `component_id [[META]]`.
- `cpu_request_contract`: `string` - (e.g., `200m`). Derived from `component_id [[META]]`.
- `mem_request_contract`: `string` - (e.g., `512Mi`). Derived from `component_id [[META]]`.

#### Performance Documentation Standard (`bun-platform` Enforced)

For optimization and performance documentation, use standardized performance metrics format to ensure consistent reporting and comparison across all optimizations.

**Required Fields** (for optimization documentation):
- `pre_optimization`: `string` - Baseline performance description (e.g., "40-50s core operations", "55K-node lag")
- `post_optimization`: `string` - Optimized performance description (e.g., "<0.1s core operations", "<300ms canvas operations")
- `speed_improvement`: `string` - Performance multiplier in standardized format (e.g., "6‚Äì400√ó faster", "183√ó+ faster")
- `complexity_reduction`: `string` - Complexity reduction percentage, if applicable (e.g., "-80%", "-70% complexity")

**Optional Fields**:
- `latency_p99`: `string` - 99th percentile latency (e.g., "25ms", "<300ms")
- `error_rate`: `string` - Error rate percentage (e.g., "0.01", "0.001")
- `throughput`: `string` - Throughput improvement (e.g., "2√ó throughput", "50% increase")
- `memory_reduction`: `string` - Memory reduction percentage (e.g., "-60%", "4√ó less")

**Format Example**:
```yaml
performance_metrics:
  pre_optimization: "55K-node lag with unlimited shapes"
  post_optimization: "<300ms with shape limits and image offload"
  speed_improvement: "6‚Äì400√ó faster (183√ó+ average)"
  complexity_reduction: "-80%"
  latency_p99: "<300ms"
  error_rate: "0.001"
```

**Validation**: `bun-platform validate` will check for required performance metrics fields in optimization documentation and verify format consistency.

**Usage**: All optimization execution logs and guides **must** include performance metrics following this standard format.

#### Visualization / Canvas

- `canvas_links`: `string[]` - Array of links to relevant `.canvas` files (e.g., `[[Architecture/Components.canvas]]`).
- `main_canvas_node_id`: `string` - The internal `canvasNode.id` for this component on the main architecture canvas. Automatically updated by `bun-platform update-canvas-colors`.

#### Meeting Notes

- `attendees`: `string[]` - List of participants.
- `meeting_link`: `string` - Link to meeting recording/agenda.
- `action_items`: `string[]` - Array of resolved action items from the meeting.

#### Bug Reports

- `severity`: `string` - (`critical | major | minor | trivial`).
- `component_refs_affected`: `string[]` - Array of `#REF`s of affected components.
- `repro_steps`: `string` - Detailed reproduction steps.

### 4.4 Field Value Formats & Validation Rules (`bun-platform` Enforced)

All field values are strictly validated for format and content.

- **`string`**: General text. Values in `tags` and single-word enums **must be `kebab-case` and lowercase**.
- **`string[]`**: YAML array of strings. Each item follows string rules.
- **`boolean`**: `true` or `false`.
- **`number`**: Integer or float.
- **`ISO Date`**: `YYYY-MM-DD` or `YYYY-MM-DDTHH:MM:SSZ` (e.g., `2023-10-27`, `2023-10-27T10:30:00Z`).
- **`[#REF:...]` values**: Must conform to `^[A-Z0-9_]{3,30}$` regex. Case-sensitive.
- **`[CH:'...']` values**: Must conform to `^'HSL\([0-9]{1,3},[0-9]{1,3}%,[0-9]{1,3}%\)(?:,hex\([0-9a-fA-F]{6}\),HEX\([0-9a-fA-F]{6}\))?'$` regex. **Must be from the [Authorized Channel Palette](#82-authorized-channel-palette-bun-platform-enforced).**
- **`[#META:...]` values**: Must conform to standardized meta tag format (see [Standard Meta Tags](#45-standard-meta-tags-bun-platform-enforced) and [`[#META:key=value,...]` Tag](#46-metakeyvalue-tag-flexible-metadata-bun-platform-managed)).
- **Case Sensitivity**: All frontmatter *field names* are `kebab-case`. Frontmatter *values* (e.g., `tags`, `type`, `status`, `category`) should be stored in **lowercase `kebab-case`** for consistency, *except* for specific `[#REF]`, `[CH]`, `[#META]` values within `component_id` where exact case is part of the contract.

### 4.5 Standard Meta Tags (`bun-platform` Enforced)

Meta tags in `component_id` and optimization documentation **must** follow these standardized definitions. This ensures consistent semantic meaning across all documentation.

| Meta Tag | Format | Purpose | Usage Example |
|----------|--------|---------|---------------|
| `[META: LIMIT]` | Limit/Constraint | Performance limits, caps, maximums | Shape limits, node limits, file limits |
| `[META: OFFLOAD]` | Offload/Externalize | External storage, caching, offloading | Image offload, cache offload, R2 storage |
| `[META: TUNE]` | Tuning/Optimization | Performance tuning, parameter adjustment | Physics tuning, repulsion tuning |
| `[META: SPLIT]` | Split/Divide | Division, separation, partitioning | Sub-graphs, sub-vaults, split views |
| `[META: FILTER]` | Filter/Scope | Filtering, scoping, limiting scope | Load filters, tag filters, search filters |
| `[META: LINK]` | Linking | Link management, link optimization | Wikilinks, auto-update links |
| `[META: CLEAN]` | Cleanup | Cache cleanup, maintenance, pruning | Cache cleanup, temp file cleanup |
| `[META: OPTIONAL]` | Optional/Disable | Optional features, conditional enablement | Optional features, disable on demand |
| `[META: DEFAULT]` | Default/Initial | Default values, initial settings | Default filters, initial tags |
| `[META: FORCE]` | Force/Physics | Force minimization, physics simulation | Force physics, node repulsion |
| `[META: VERLET]` | Algorithm | Specific algorithms, integration methods | Verlet integration, d3.js algorithms |
| `[META: EXTEND]` | Extension | Extended features, advanced capabilities | Extended graph, extended canvas |
| `[META: SEARCH]` | Search | Search optimization, search configuration | Search filters, search on-open |
| `[META: ENHANCED]` | Enhancement | General enhancements, improvements | Enhanced features, enhanced performance |

**Format**: Meta tags **must** follow the pattern `[META: TAG_NAME]` where `TAG_NAME` is uppercase, space-separated words.

**Validation**: `bun-platform validate` will check meta tag format and ensure values match this authorized list.

**Usage in `component_id`**: Meta tags can appear in `component_id` strings as `[#META:KEY1=VALUE1,KEY2=VALUE2]` or as standalone tags `[META: TAG_NAME]` in documentation.

---

### 4.6 `[#META:key=value,...]` Tag (Flexible Metadata - `bun-platform` Managed)

#### Placement

This tag provides arbitrary, flexible metadata and **must** appear in `component_id` (and `TES_CANONICAL` tags) when metadata is needed. It enables rich, dynamic querying, provides contextual data for AI agents, and supports rapid extensibility of metadata without structural changes.

#### Format

```
[#META:key1=value1,key2=value2,key3=value3]
```

#### Rules

1. **Separator**: Comma (`,`) between `key=value` pairs
2. **Delimiter**: Equals sign (`=`) between key and value
3. **Whitespace**: **Strictly no whitespace** around commas or equals signs within the tag
4. **Key Naming**: `UPPER_SNAKE_CASE` (e.g., `OWNER_TEAM`, `CRITICAL_PATH`, `DEPLOYMENT_ENV`)
   - Keys are automatically normalized: lowercase/snake_case/kebab-case are converted to `UPPER_SNAKE_CASE`
5. **Value Naming**: Flexible, but single-word or `kebab-case` values are preferred
6. **Quoted Values**: Values containing spaces or commas should be quoted: `DESCRIPTION="This is a description"`

#### Purpose

- Enables rich, dynamic querying (e.g., `bun-platform search-notes --meta="owner=DevTeamA,critical_path=true"`)
- Provides contextual data for AI agents and automated tooling
- Supports rapid extensibility of metadata without structural changes
- Captures attributes that don't fit into structured tags (`TYPE`, `REF`, `CH`, `SLA`)

#### Examples

**Valid:**
```
[#META:OWNER_TEAM=dev-team-a,PRIORITY=high]
[#META:AUDIENCE=operators,SECTION=intro]
[#META:CRITICAL_PATH=true,DEPLOYMENT_ENV=prod]
[#META:DESCRIPTION="Short summary text"]
```

**Invalid:**
```
[#META:KEY1 = value1, KEY2=value2]  ‚ùå Whitespace around equals/comma
[#META:invalid-key=value]          ‚ùå Key not UPPER_SNAKE_CASE (after normalization)
[#META:KEY1=value1, ]              ‚ùå Empty pair
```

#### Validation (`bun-platform` Enforced)

1. **Format Check**: Enforces no spaces around `=` or `,`
2. **Key Validation**: Validates `key` against [Authorized `#META` Keys](#47-authorized-meta-keys-bun-platform-enforced) whitelist (optional but recommended)
3. **Value Constraints**: Validates `value` for specific keys (e.g., `CRITICAL_PATH` must be `true` or `false`)
4. **FORGE-007 Violation**: Format violations trigger `FORGE-007: Meta Parse Failure (META_CORRUPTION)` with detailed error messages

#### Common Use Cases

- **Audience**: `AUDIENCE=operators` - Who is this component primarily for/managed by?
- **Section**: `SECTION=intro` - Context within a document (for `TES_CANONICAL`)
- **Priority**: `PRIORITY=high` - Business priority of the component
- **Owner**: `OWNER_TEAM=dev-team-a` - The team or individual responsible
- **Deployment**: `DEPLOYMENT_ENV=prod` - The environment the component is deployed in
- **Critical Path**: `CRITICAL_PATH=true` - Boolean flag indicating extreme importance
- **Data Sensitivity**: `DATA_SENSITIVITY=PII` - Classification of data handled
- **Security**: `SECURITY_LEVEL=L3` - Security classification
- **Framework**: `FRAMEWORK=React` - What framework it uses (for `CLIENT` components)
- **Protocol**: `PROTOCOL=gRPC` - Communication protocol used

#### Integration Points

- **Parsing**: `tools/arch-parser.ts` - Extracts `[#META:...]` tags from component IDs
- **Validation**: `scripts/validate-vault-frontmatter.ts` - Validates all `#META` tags in vault files
- **Parser**: `packages/registry/meta-parser.ts` - Strict parser with format validation
- **Config**: `config/meta-keys.json` - Authorized keys whitelist and value constraints
- **FORGE System**: `packages/registry/hammer.ts` - FORGE-007 violation reporting

---

### 4.7 Authorized `#META` Keys (`bun-platform` Enforced)

The following keys are authorized for use in `#META` tags. This list is defined in `config/meta-keys.json` and can be extended as needed. `bun-platform validate` enforces key authorization and value constraints.

| Key | Description | Example Values | Type |
|-----|-------------|----------------|------|
| `AUDIENCE` | Who is this component for | `operators`, `developers`, `stakeholders`, `end-users`, `admins` | Enum |
| `SECTION` | Context within a document | `intro`, `overview`, `deployment`, `monitoring`, `troubleshooting` | Enum |
| `PRIORITY` | Business priority | `high`, `medium`, `low`, `urgent`, `critical` | Enum |
| `OWNER_TEAM` | Responsible team | `dev-team-a`, `platform-squad` | Freeform |
| `DEPLOYMENT_ENV` | Deployment environment | `prod`, `staging`, `dev`, `test`, `local` | Enum |
| `CRITICAL_PATH` | Extreme importance flag | `true`, `false` | Boolean |
| `DATA_SENSITIVITY` | Data classification | `PII`, `PCI`, `PUBLIC`, `INTERNAL`, `CONFIDENTIAL`, `RESTRICTED` | Enum |
| `SECURITY_LEVEL` | Security classification | `L1`, `L2`, `L3`, `L4`, `L5` | Enum |
| `FRAMEWORK` | Framework used (CLIENT components) | `React`, `Vue`, `Solid`, `Svelte`, `Angular`, `Vanilla` | Enum |
| `AUTH_METHOD` | Authentication mechanism | `JWT`, `OAuth2`, `API-Key`, `Basic`, `Bearer`, `None` | Enum |
| `PROTOCOL` | Communication protocol | `gRPC`, `REST`, `Kafka`, `WebSocket`, `GraphQL`, `HTTP`, `HTTPS` | Enum |
| `DESCRIPTION` | Short text summary | Freeform (max 100 chars) | Freeform |
| `STATUS_CODE` | HTTP status code (API components) | `200-OK`, `404-NOT_FOUND` | Pattern |
| `BUN_RUNTIME` | Bun runtime configuration | `native`, `node`, `bun` | Enum |
| `BUN_API` | Bun API features used | Freeform | Freeform |
| `HSL_PHASE` | HSL color phase for categorization | Freeform (kebab-case) | Freeform |

#### Adding New Keys

To add a new authorized key:

1. Edit `config/meta-keys.json`
2. Add the key definition with:
   - `description`: What the key represents
   - `values`: Array of allowed values or `"freeform"`
   - `required`: Whether the key is required (usually `false`)
   - `pattern`: Regex pattern for freeform values (optional)
   - `maxLength`: Maximum length for freeform values (optional)
3. Run `bun-platform validate` to verify the configuration
4. Update this documentation section

#### Key Normalization

Keys are automatically normalized to `UPPER_SNAKE_CASE`:
- `owner_team` ‚Üí `OWNER_TEAM`
- `owner-team` ‚Üí `OWNER_TEAM`
- `OwnerTeam` ‚Üí `OWNER_TEAM`
- `OWNER_TEAM` ‚Üí `OWNER_TEAM` (no change)

This allows flexible input while maintaining consistency in storage and validation.

---

### 4.8 Authorized Type Values (for `type` Frontmatter Field & `component_id` - `bun-platform` Enforced)

All `type` values used in frontmatter or within `component_id`s **must** originate from this canonical, case-normalized list. `bun-platform validate` will strictly enforce this, ensuring a controlled vocabulary for component classification.

- `OVERVIEW` (for high-level descriptions, platform root)
- `PLATFORM` (for the entire Kimi2 platform component)
- `LAYER` (for architectural layers like `DATA_LAYER`, `SERVICE_LAYER`)
- `SERVICE` (for a standalone microservice/Bun service, a core execution unit)
- `API` (specifically for API endpoints/gateways, defines an interface)
- `CLIENT` (for frontend apps or client libraries consuming services)
- `DATABASE` (for any persistent data store, e.g., `Bun.sqlite`, PostgreSQL)
- `CACHE` (for in-memory or distributed caches, e.g., Redis, in-Bun cache)
- `QUEUE` (for message queues/brokers, e.g., Kafka, RabbitMQ)
- `TOPIC` (for specific messaging topics/streams)
- `WORKER` (for background processing units, cron jobs)
- `INTEGRATION` (for connectors to external systems, third-party APIs)
- `TOOL` (for standalone utility scripts, CLI tools like `bun-platform` itself)
- `ASSET` (for static assets, shared libraries, configuration bundles)
- `TEMPLATE` (for notes that are primarily templates, like VIZ-06 nodes)
- `PROPOSAL` (for architectural proposals, RFCs, design docs)
- `REPORT` (for dynamically generated operational or architectural reports)
- `MEETING` (for meeting notes/minutes)
- `RESEARCH` (for research notes/spikes, technical explorations)
- `BUG` (for bug reports/issues)
- `DOCUMENTATION` (for general informational notes, guides)
- `POLICY` (for security policies, governance rules)

---

## 5. Internal Linking & Referencing

Semantic linking is the backbone of our knowledge graph.

- **Wikilinks `[[Link Target]]`**: The preferred method for internal Obsidian links. Always link to the canonical filename (e.g., `[[Components/Data/Storage/CoreDB/Persistence]]`).

- **Block References `[[Note Name#^BlockID]]`**: Use for precise linking to specific sections or paragraphs within a note.

- **Component Links**: Always link directly to the note (e.g., `[[Components/Data/Storage/CoreDB/Persistence]]`) when referring to an architectural component.

- **Architectural ID Cross-Referencing**:
  - **Frontmatter `ref`**: This is the primary stable identifier for linking. Access it via `ref:API_GW_01`.
  - **Dataview Queries**: Leverage `ref` and `component_id` values for powerful, dynamic queries across the vault.
  - **Direct Block Links to Component IDs**: Reference specific component IDs embedded in text: `[[Note Name#^component_id_full_string]]` for strong traceability.

- **Anchor Links (`[[Note Name#Section Header]]`)**: Use for general section linking within a note.

- **External Links**: Use standard Markdown format `[Link Text](URL)`.

### 5.1 Cross-Reference Standards (`bun-platform` Enforced)

For optimization documentation and related technical documentation, use standardized cross-reference format to ensure consistent navigation and discoverability.

#### Standardized Cross-Reference Format

**Required Section**: All optimization and technical documentation **must** include a "Related Documentation" section with standardized format:

```markdown
## üìö Related Documentation

- **[[EXECUTION-LOG|Optimization Name Complete]]** - Full execution log (if paired guide)
- **[[GUIDE|Optimization Guide]]** - Practical guide (if paired execution log)
- **[[../Phase-X/Other-Opt/EXECUTION-LOG|Other Optimization]]** - Related optimization
- **[[../../Standards/STANDARD-NAME|Standard Name]]** - Related standard
- **[[../../../docs/GOLDEN_FILE_STANDARD|Golden File Standard]]** - Standard compliance
```

**Pattern Requirements**:
1. **Relative Paths**: Always use relative paths (`../`, `../../`) for navigation within the same documentation area
2. **Execution Log Reference**: If document is a guide, reference its paired execution log
3. **Guide Reference**: If document is an execution log, reference its paired guide
4. **Related Optimizations**: Link to related optimizations in the same or other phases
5. **Standards Reference**: Link to relevant standards documents
6. **Golden File Standard**: Always include reference to Golden File Standard for compliance

**Validation**: `bun-platform validate` will check for "Related Documentation" sections in optimization documentation and verify link format.

**Benefits**:
- Consistent navigation patterns
- Improved discoverability
- Clear relationship mapping
- Standard compliance verification

---

## 6. `README.md` Conventions (for Code Directories)

For all code directories outside the Obsidian vault but intrinsically linked to it (e.g., `platform/`, `data/`, `server/`), a `README.md` file is **mandatory**. These READMEs bridge the code and knowledge layers.

### Mandatory Sections (`bun-platform` Template Enforced)

- `# [Directory/Component Name]` (H1 title)
- `## Overview` (Concise explanation of this directory's/component's purpose and contents)
- `## Architectural Context` (Links to Obsidian note for deep-dive)
  - `[[Components/Data/Storage/CoreDB/Persistence]]` (example link to canonical note)
  - `Component ID: [DATA/STORAGE/COREDB/PERSISTENCE_vX.Y.Z][#REF:GUID][CH:'...'][#META:'...']` (Full ID from `architecture.json` to link the code to its blueprint)
- `## Development` (Instructions on how to build, run, test this specific code component. Includes relevant `bun` commands.)
- `## Deployment` (Deployment specifics, links to operational runbooks in Obsidian `[[Operations/...]]`)
- `## Contributing` (Guidelines for contributing to this specific code component)

---

## 7. `bun-platform` Tooling Compliance & Automation

The `bun-platform` CLI suite is the enforcement mechanism for this `GOLDEN_FILE_STANDARD.md`. It actively manages, validates, and reports on compliance.

- **`bun-platform validate`**: Will perform comprehensive validation across the entire vault.
  - **Frontmatter Schema**: Verifies presence, format, and content of all mandatory fields per [4.1](#41-mandatory-core-fields-all-notes-bun-platform-enforced) and [4.2](#42-mandatory-component_id--associated-fields-for-architectural-component-notes-bun-platform-enforced).
  - **`component_id` Integrity**: Strictly validates `component_id` string against regex, `architecture.json`, and [4.4](#44-field-value-formats--validation-rules-bun-platform-enforced).
  - **Directory Alignment**: Checks if the `Components/` directory structure aligns with `architecture.json`'s `DOMAIN/PATH`.
  - **Authorized Values**: Enforces [4.7](#47-authorized-meta-keys-bun-platform-enforced), [4.8](#48-authorized-type-values-for-type-frontmatter-field--component_id-bun-platform-enforced), and [8.2](#82-authorized-channel-palette-bun-platform-enforced).
  - **`#META` Tag Validation**: Validates `[#META:key=value,...]` format, authorized keys, and value constraints (see [4.6](#46-metakeyvalue-tag-flexible-metadata-bun-platform-managed)).

- **`bun-platform create-note --id "[...]"`**: Will use templates from `_templates/` and automatically populate frontmatter based on the provided component ID, ensuring compliance from inception.
- **`bun-platform create-note --meta-tags="key1=value1,key2=value2"`**: Accepts `#META` tags as command-line arguments to build this tag when creating new `component_id`s.

- **`bun-platform update-note --id "[...]"`**: Assists in modifying existing notes, ensuring changes remain compliant.

- **`bun-platform generate-inbox-review`**: Reports on current compliance status and highlights deviations, drawing directly from `validate` results.

- **`bun-platform update-canvas-colors`**: Relies on the consistency of the `ref` field and `component_id` in frontmatter/text for accurate visual synchronization.

---

## 8. `bun-platform` Architectural Palette Definitions (The Visual Contract)

This section defines the canonical color and meta-data palettes that `bun-platform` tools manage and enforce for visual and semantic consistency.

### 8.1 Component ID `[CH:'...']` Format

The `[CH:'...']` tag within `component_id` (and potentially `channel_color` frontmatter field) **must** follow this strict multi-format specification:

- **Format**: `CH:'HSL(H,S%,L%),hex(#RRGGBB),HEX(#RRGGBB)'`
- **Mandatory Components**: Each `CH` tag **must** provide HSL, lowercase hex, and uppercase HEX representations.
- **Validation**: `bun-platform validate` ensures the format is exact and that all three color values resolve to the same color.

### 8.2 Authorized Channel Palette (`bun-platform` Enforced)

All `CH` (Channel Color) values used in `component_id`s **must** originate from this centrally defined and authorized channel palette. This palette is the visual language of our architecture.

*(This section refers to an external, centrally managed configuration file, e.g., `config/channel-palette.json` or `bun-platform.config.yaml`)*

**Example Palette Entries (from `config/channel-palette.json`):**

```json
{
  "Leadership Blue": {
    "tag": "CH:'HSL(217,91%,59%),hex(#3b82f6),HEX(#3B82F6)'",
    "context": "Core Platform, Governance, Strategic Oversight",
    "visual_purpose": "Foundation, Stability",
    "semantic_meanings": ["core", "platform", "governance", "foundation", "stability", "critical"]
  },
  "Navigation Green": {
    "tag": "CH:'HSL(160,84%,39%),hex(#10b981),HEX(#10B981)'",
    "context": "Routing, Integration, Data Flow",
    "visual_purpose": "Flow, Connectivity",
    "semantic_meanings": ["routing", "integration", "data-flow", "connectivity", "flow"]
  },
  "Domain Purple": {
    "tag": "CH:'HSL(258,89%,66%),hex(#8b5cf6),HEX(#8B5CF6)'",
    "context": "Specific Business Domains, ML Models, Data Processing",
    "visual_purpose": "Specificity, Intelligence",
    "semantic_meanings": ["domain", "business", "ml", "intelligence", "specificity", "processing"]
  },
  "Action Amber": {
    "tag": "CH:'HSL(38,92%,50%),hex(#f59e0b),HEX(#F59E0B)'",
    "context": "Critical Triggers, User Interaction, Active Tasks",
    "visual_purpose": "Warning, Urgency",
    "semantic_meanings": ["action", "trigger", "interaction", "urgency", "warning", "active"]
  },
  "Context Pink": {
    "tag": "CH:'HSL(330,81%,58%),hex(#ec4899),HEX(#EC4899)'",
    "context": "Ambient Data, Contextual Awareness, Knowledge Layers",
    "visual_purpose": "Information, Support",
    "semantic_meanings": ["context", "ambient", "awareness", "knowledge", "information", "support"]
  },
  "Alert Red": {
    "tag": "CH:'HSL(0,84%,53%),hex(#dc2626),HEX(#DC2626)'",
    "context": "Immediate Critical Issues, Errors, Incidents",
    "visual_purpose": "Danger, Action Required",
    "semantic_meanings": ["alert", "critical", "error", "incident", "danger", "action-required"]
  },
  "Success Teal": {
    "tag": "CH:'HSL(170,70%,50%),hex(#2dd4bf),HEX(#2DD4BF)'",
    "context": "Successful Operations, Positive Confirmations, Completion",
    "visual_purpose": "Achievement, Confirmation",
    "semantic_meanings": ["success", "completion", "confirmation", "achievement", "positive"]
  },
  "Platform Black": {
    "tag": "CH:'HSL(0,0%,0%),hex(#000000),HEX(#000000)'",
    "context": "Platform Root, Foundation, Uncategorized Base Elements",
    "visual_purpose": "Base, Immutable",
    "semantic_meanings": ["platform", "root", "foundation", "base", "immutable", "uncategorized"]
  },
  "Worker Pink": {
    "tag": "CH:'HSL(336,100%,50%),hex(#FF006E),HEX(#FF006E)'",
    "context": "Offload, Performance, Worker Processes",
    "visual_purpose": "Offload, Performance",
    "semantic_meanings": ["worker", "offload", "performance", "optimization", "processing"]
  },
  "Command CH1": {
    "tag": "CH:'HSL(180,100%,50%),hex(#00FFFF),HEX(#00FFFF)'",
    "context": "Action, Execution, Commands",
    "visual_purpose": "Action, Execution",
    "semantic_meanings": ["command", "action", "execution", "operation", "control"]
  },
  "Data Orange": {
    "tag": "CH:'HSL(17,96%,50%),hex(#FB5607),HEX(#FB5607)'",
    "context": "Communication, Flow, Data Processing",
    "visual_purpose": "Communication, Flow",
    "semantic_meanings": ["data", "communication", "flow", "processing", "transfer"]
  },
  "Event CH3": {
    "tag": "CH:'HSL(300,100%,50%),hex(#FF00FF),HEX(#FF00FF)'",
    "context": "Structure, Foundation, Events",
    "visual_purpose": "Structure, Foundation",
    "semantic_meanings": ["event", "structure", "foundation", "organization", "framework"]
  },
  "Monitor CH4": {
    "tag": "CH:'HSL(60,100%,50%),hex(#FFFF00),HEX(#FFFF00)'",
    "context": "Observation, Analysis, Monitoring",
    "visual_purpose": "Observation, Analysis",
    "semantic_meanings": ["monitor", "observation", "analysis", "tracking", "surveillance"]
  },
  "Core Blue": {
    "tag": "CH:'HSL(217,100%,61%),hex(#3A86FF),HEX(#3A86FF)'",
    "context": "Critical, Attention, Core Systems",
    "visual_purpose": "Critical, Attention",
    "semantic_meanings": ["core", "critical", "attention", "essential", "primary"]
  },
  "External": {
    "tag": "CH:'HSL(270,65%,60%),hex(#9D4EDD),HEX(#9D4EDD)'",
    "context": "Configuration, Setup, External Systems",
    "visual_purpose": "Configuration, Setup",
    "semantic_meanings": ["external", "configuration", "setup", "integration", "external-system"]
  },
  "API Purple": {
    "tag": "CH:'HSL(258,75%,60%),hex(#8338EC),HEX(#8338EC)'",
    "context": "Integration, Connection, API Interfaces",
    "visual_purpose": "Integration, Connection",
    "semantic_meanings": ["api", "integration", "connection", "interface", "communication"]
  }
}
```

#### HSL Color Semantics Enhancement (`bun-platform` Enforced)

Each color in the authorized channel palette **must** include semantic meaning mappings to ensure consistent usage and understanding across the architecture.

**Required Fields for Each Palette Entry**:
- `tag`: `string` - The complete `CH` tag format (HSL, hex, HEX)
- `context`: `string` - High-level context description
- `visual_purpose`: `string` - Visual purpose description
- `semantic_meanings`: `string[]` - Array of semantic meaning keywords (lowercase, kebab-case)

**Semantic Meaning Selection Guidelines**:
1. **Select colors based on semantic meaning**, not visual preference
2. **Use semantic meanings** to guide color selection for new components
3. **Match semantic meanings** to component purpose and context
4. **Consistent mapping** ensures visual language consistency

**Usage Examples**:
- Performance optimizations ‚Üí `Worker Pink` (semantic: "offload", "performance")
- Action/execution components ‚Üí `Command CH1` (semantic: "action", "execution")
- Data processing ‚Üí `Data Orange` (semantic: "data", "communication", "flow")
- Core critical systems ‚Üí `Core Blue` (semantic: "core", "critical", "attention")

**Validation**: `bun-platform validate` will check that color selections align with semantic meanings and that palette entries include all required fields.

**Benefits**:
- Consistent visual language across architecture
- Semantic-driven color selection
- Improved understanding of color purpose
- Better alignment between visual and conceptual architecture

---

## 9. Atomic Source File Header Standard (Code-Level Governance)

**Purpose**: Extend Golden File Standard principles into source code itself, ensuring every component's source is a self-contained, self-describing, and versioned entity. This creates atomic traceability at the code level, enabling unprecedented auditability and architectural governance enforcement within the source code.

### 9.1. Core Principles

- **Self-Describing Code**: Every significant source file contains its architectural identity within its header
- **Grepable Metadata**: All architectural metadata is easily searchable via standard text tools
- **Single Source of Truth**: Component ID in header links directly to `architecture.json`
- **Automated Generation**: Headers are automatically generated by `bun-platform scaffold-service`
- **Mandatory Validation**: Headers are validated as part of CI/CD pipeline

### 9.2. Header Format Specification

**Required Format** (for TypeScript/JavaScript files):

```typescript
// @KIMI2-ARCH-COMPONENT-START
// ID: [DOMAIN/PATH/COMPONENT_NAME/TYPE_vMAJOR.MINOR.PATCH][#REF:REF_ID][CH:'...'][#META:KEY=VALUE,...]
// DESCRIPTION: Brief human-readable description of the file's purpose
// OWNER: OWNER_TEAM (from [[META]]:OWNER or default)
// CREATED: YYYY-MM-DD (ISO date)
// LAST_MODIFIED: YYYY-MM-DD (ISO date, auto-updated)
// STATUS: ACTIVE | DEPRECATED | EXPERIMENTAL | ARCHIVED
// @KIMI2-ARCH-COMPONENT-END

// ... actual source code follows ...
```

### 9.3. Header Field Definitions

#### `ID:` (Required)
- **Format**: Full vectorable architectural ID matching `architecture.json` entry
- **Components**:
  - `[DOMAIN/PATH/COMPONENT_NAME/TYPE_vMAJOR.MINOR.PATCH]`: Component identifier
  - `[#REF:REF_ID]`: Reference GUID (matches `architecture.json` `ref` field)
  - `[CH:'...']`: Channel color tag (matches `architecture.json` `ch` field)
  - `[#META:KEY=VALUE,...]`: Meta tags (matches `architecture.json` `meta` field)
- **Example**: `[DATA/STORAGE/SUB_A/SERVICE_v1.0.0][#REF:SUB_A_SVC_01][CH:'HSL(20,100%,70%)'][#META:RUNTIME=BUN,LATENCY_P99=20ms]`

#### `DESCRIPTION:` (Required)
- **Format**: Single-line, human-readable description
- **Purpose**: Quick understanding of file's purpose without reading code
- **Example**: `Handles high-load data operations for the COREDB persistence layer`

#### `OWNER:` (Required)
- **Format**: Team identifier (uppercase, underscore-separated)
- **Source**: Extracted from `#META:OWNER` tag or defaults to `PLATFORM_TEAM`
- **Example**: `DATA_TEAM`, `PLATFORM_TEAM`, `FRONTEND_TEAM`

#### `CREATED:` (Required)
- **Format**: ISO date (`YYYY-MM-DD`)
- **Purpose**: Initial creation timestamp for auditing
- **Example**: `2025-11-13`

#### `LAST_MODIFIED:` (Required)
- **Format**: ISO date (`YYYY-MM-DD`)
- **Purpose**: Last modification timestamp (should match file's actual modification time)
- **Auto-Update**: Should be updated when file is modified (tooling can enforce)

#### `STATUS:` (Required)
- **Format**: One of: `ACTIVE`, `DEPRECATED`, `EXPERIMENTAL`, `ARCHIVED`
- **Source**: Can be derived from `#META:STATUS` tag or defaults to `ACTIVE`
- **Purpose**: Operational status indicator

### 9.4. Optional Header Fields

#### `API_VERSION:` (Optional, for API services)
- **Format**: Semantic version (`vMAJOR.MINOR`)
- **Purpose**: API contract version for endpoints within the file
- **Example**: `v1.1`
- **Usage**: Should align with component version (e.g., `SERVICE_v1.0.0` typically exposes `v1.0` APIs)

#### `DEPENDENCIES:` (Optional)
- **Format**: Comma-separated list of component REFs
- **Purpose**: List direct architectural dependencies
- **Example**: `SUB_A_SVC_01,SUB_B_SVC_02`

### 9.5. File Types Requiring Headers

**Mandatory Headers**:
- `*.ts` (TypeScript source files)
- `*.tsx` (TypeScript React components)
- `*.js` (JavaScript source files, if not legacy)
- `*.jsx` (JavaScript React components, if not legacy)

**Optional Headers** (recommended):
- `*.test.ts` (Test files)
- `*.spec.ts` (Spec files)

**Excluded**:
- Generated files (e.g., `*.d.ts`, build outputs)
- Configuration files (e.g., `*.json`, `*.toml`)
- Documentation files (e.g., `*.md`)

### 9.6. Header Generation & Validation

#### Automatic Generation
- **`bun-platform scaffold-service`**: Automatically generates headers for all scaffolded service files
- **Process**:
  1. Parse `--id` parameter to extract architectural metadata
  2. Query `architecture.json` for component details (`ref`, `ch`, `meta`)
  3. Extract `OWNER` from `#META:OWNER` or use default
  4. Generate header with current timestamp for `CREATED`
  5. Prepend header to primary source file (`src/index.ts`)

#### Validation Command
- **`bun-platform validate --codebase-headers`**: Validates all source files
- **Checks**:
  1. **Presence**: Verifies `@KIMI2-ARCH-COMPONENT-START` and `@KIMI2-ARCH-COMPONENT-END` markers exist
  2. **ID Match**: Extracts `ID:` and validates against `architecture.json`:
     - Component exists in `architecture.json`
     - `#REF` matches `architecture.json` `ref` field
     - Version matches (optional check)
  3. **Metadata Consistency**: Compares header fields against `architecture.json`:
     - `OWNER` matches `#META:OWNER` (if present)
     - `STATUS` matches `#META:STATUS` (if present)
  4. **Timestamp Check**: Warns if `LAST_MODIFIED` is significantly older than file's actual modification time
  5. **Format Validation**: Ensures all required fields are present and correctly formatted

#### CI/CD Integration
- **Pre-Build Validation**: `bun-platform build` implicitly runs `validate --codebase-headers`
- **Failure Behavior**: Build fails if header validation errors are found (warnings do not fail build)
- **Reporting**: Validation results reported in CI logs and build artifacts

### 9.7. Benefits & Impact

**Atomic Traceability**:
- Every source file is a self-contained unit of code, documentation, and architectural metadata
- Instant context without reading external documentation

**Unprecedented Auditability**:
- Grep codebase for `OWNER`, `STATUS`, `ID`, `DESCRIPTION` for immediate overview
- Track component ownership and operational status across entire codebase

**Stronger Architectural Governance**:
- `architecture.json` blueprint enforced at code level
- Prevents architectural drift between documentation and implementation

**Automated Self-Documentation**:
- Code contains key metadata, reducing manual documentation burden
- Headers serve as inline documentation

**`BUN:FIRST` Compliance**:
- Ensures consistency and adherence to platform standards from lowest code level
- Fosters good practices from service creation

**Enhanced Developer Experience**:
- New services generated with clear, structured identity
- Immediate understanding of component context and ownership

### 9.8. Migration Strategy

**Existing Codebase**:
1. **Phase 1**: Add headers to all new scaffolded services (automatic)
2. **Phase 2**: Add headers to critical path services (manual, prioritized)
3. **Phase 3**: Gradual migration of remaining services (tooling-assisted)

**Tooling Support**:
- `bun-platform add-header --file <path>`: Add header to existing file
- `bun-platform migrate-headers`: Batch migration tool for existing codebase

---

## 10. Governance Lifecycle & Evolution

This `GOLDEN_FILE_STANDARD.md` is a living document, actively managed by the Kimi2 Architecture Governance Board. All proposed changes must undergo a formal review and `bun-platform` validation process to maintain system integrity.

### Change Process

1. **Proposal**: Changes must be proposed via architectural proposal note (`[TYPE:PROPOSAL]`)
2. **Review**: Architecture Governance Board reviews against `BUN:FIRST` principles
3. **Validation**: `bun-platform validate` ensures backward compatibility
4. **Implementation**: Changes are implemented with version increment
5. **Enforcement**: `bun-platform` tools are updated to enforce new standards

### Version History

- **v1.4.0** (2025-01-XX): New feature: Atomic Source File Header Standard (Section 9) - Code-level governance and self-describing source files
- **v1.3.0r1** (2025-01-XX): Micro-enhancement: Phase 1 & 2 complete, section numbering fixed
- **v1.3.0** (2025-01-XX): Phase 1 & 2 enhancements (meta tags, structure patterns, performance docs, HSL semantics)
- **v1.2.0** (2025-01-XX): Governance lifecycle, `bun-platform` integration, type values, channel palette
- **v1.0.0** (2025-01-XX): Initial standard definition

---

**This `GOLDEN_FILE_STANDARD.md` is a living document, actively managed by the Kimi2 Architecture Governance Board. All proposed changes must undergo a formal review and `bun-platform` validation process to maintain system integrity.**
