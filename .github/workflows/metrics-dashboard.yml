name: Metrics Dashboard

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    # Update metrics every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:

jobs:
  generate-metrics:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate comprehensive metrics
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            
            // Get issues data
            const issues = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'all',
              per_page: 100
            });

            // Get PRs data
            const prs = await github.rest.pulls.list({
              owner,
              repo,
              state: 'all',
              per_page: 100
            });

            // Calculate metrics
            const metrics = {
              issues: {
                total: issues.data.length,
                open: issues.data.filter(i => i.state === 'open').length,
                closed: issues.data.filter(i => i.state === 'closed').length,
                by_priority: {
                  p0: issues.data.filter(i => i.labels.some(l => l.name === 'p0')).length,
                  p1: issues.data.filter(i => i.labels.some(l => l.name === 'p1')).length,
                  p2: issues.data.filter(i => i.labels.some(l => l.name === 'p2')).length
                },
                by_team: {
                  security: issues.data.filter(i => i.labels.some(l => l.name === 'team-security')).length,
                  performance: issues.data.filter(i => i.labels.some(l => l.name === 'team-performance')).length,
                  infrastructure: issues.data.filter(i => i.labels.some(l => l.name === 'team-infrastructure')).length
                },
                by_type: {
                  bugs: issues.data.filter(i => i.labels.some(l => l.name === 'bug')).length,
                  enhancements: issues.data.filter(i => i.labels.some(l => l.name === 'enhancement')).length
                }
              },
              pull_requests: {
                total: prs.data.length,
                open: prs.data.filter(p => p.state === 'open').length,
                merged: prs.data.filter(p => p.state === 'closed' && p.merged).length,
                closed: prs.data.filter(p => p.state === 'closed' && !p.merged).length
              },
              bun_native: {
                total_issues: issues.data.filter(i => i.labels.some(l => l.name === 'bun-native')).length,
                critical_security: issues.data.filter(i => 
                  i.labels.some(l => l.name === 'bun-native') && 
                  i.labels.some(l => l.name === 'critical-security')
                ).length,
                performance_issues: issues.data.filter(i => 
                  i.labels.some(l => l.name === 'bun-native') && 
                  i.labels.some(l => l.name === 'performance')
                ).length
              }
            };

            // Generate SVG badge
            const generateBadge = (label, value, color) => {
              return `https://img.shields.io/badge/${encodeURIComponent(label)}-${encodeURIComponent(value)}-${color}`;
            };

            // Create README with metrics
            const readmeContent = `
# ðŸ“Š FactoryWager Metrics Dashboard

## ðŸŽ¯ Issue Overview
![Total Issues](${generateBadge('Total Issues', metrics.issues.total, 'blue')})
![Open Issues](${generateBadge('Open', metrics.issues.open, 'red')})
![Closed Issues](${generateBadge('Closed', metrics.issues.closed, 'green')})
![Resolution Rate](${generateBadge('Resolution Rate', `${((metrics.issues.closed / metrics.issues.total) * 100).toFixed(1)}%`, 'brightgreen')})

## ðŸ”¥ Priority Distribution
![P0 Critical](${generateBadge('P0 Critical', metrics.issues.by_priority.p0, 'red')})
![P1 High](${generateBadge('P1 High', metrics.issues.by_priority.p1, 'orange')})
![P2 Medium](${generateBadge('P2 Medium', metrics.issues.by_priority.p2, 'yellow')})

## ðŸ‘¥ Team Workload
![Security Team](${generateBadge('Security Team', metrics.issues.by_team.security, 'red')})
![Performance Team](${generateBadge('Performance Team', metrics.issues.by_team.performance, 'green')})
![Infrastructure Team](${generateBadge('Infrastructure Team', metrics.issues.by_team.infrastructure, 'blue')})

## ðŸ”§ Bun Native Issues
![Bun Native Issues](${generateBadge('Bun Native', metrics.bun_native.total_issues, 'ff6b00')})
![Critical Security](${generateBadge('Critical Security', metrics.bun_native.critical_security, 'red')})
![Performance Issues](${generateBadge('Performance Issues', metrics.bun_native.performance_issues, 'green')})

## ðŸ“‹ Type Breakdown
![Bugs](${generateBadge('Bugs', metrics.issues.by_type.bugs, 'red')})
![Enhancements](${generateBadge('Enhancements', metrics.issues.by_type.enhancements, 'green')})

## ðŸ”„ Pull Requests
![Total PRs](${generateBadge('Total PRs', metrics.pull_requests.total, 'blue')})
![Open PRs](${generateBadge('Open PRs', metrics.pull_requests.open, 'yellow')})
![Merged PRs](${generateBadge('Merged PRs', metrics.pull_requests.merged, 'green')})

## ðŸ“ˆ Detailed Metrics

### Issues by Priority
- **P0 (Critical)**: ${metrics.issues.by_priority.p0} issues
- **P1 (High)**: ${metrics.issues.by_priority.p1} issues  
- **P2 (Medium)**: ${metrics.issues.by_priority.p2} issues

### Issues by Team
- **Security Team**: ${metrics.issues.by_team.security} issues
- **Performance Team**: ${metrics.issues.by_team.performance} issues
- **Infrastructure Team**: ${metrics.issues.by_team.infrastructure} issues

### Bun Native Specific
- **Total Bun Native Issues**: ${metrics.bun_native.total_issues}
- **Critical Security Issues**: ${metrics.bun_native.critical_security}
- **Performance Related Issues**: ${metrics.bun_native.performance_issues}

### Pull Request Statistics
- **Total PRs**: ${metrics.pull_requests.total}
- **Open PRs**: ${metrics.pull_requests.open}
- **Merged PRs**: ${metrics.pull_requests.merged}
- **Closed (Unmerged) PRs**: ${metrics.pull_requests.closed}

---

*Last updated: ${new Date().toISOString()}*
`;

            // Write metrics to file
            const fs = require('fs');
            fs.writeFileSync('METRICS.md', readmeContent);
            
            console.log('âœ… Metrics dashboard generated');

      - name: Commit metrics dashboard
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add METRICS.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "ðŸ“Š Update metrics dashboard [skip ci]"
            git push
          fi

  health-check:
    runs-on: ubuntu-latest
    steps:
      - name: Repository health check
        uses: actions/github-script@v7
        with:
          script: |
            // Check for critical issues without assignments
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'p0,critical-security',
              state: 'open'
            });

            const unassigned = issues.data.filter(i => !i.assignees || i.assignees.length === 0);
            
            if (unassigned.length > 0) {
              console.log(`âš ï¸ ${unassigned.length} critical issues are unassigned:`);
              unassigned.forEach(issue => {
                console.log(`  - #${issue.number}: ${issue.title}`);
              });
            } else {
              console.log('âœ… All critical issues are assigned');
            }

            // Check for stale issues (older than 30 days)
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            const allOpenIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            const staleIssues = allOpenIssues.data.filter(i => 
              new Date(i.created_at) < thirtyDaysAgo && 
              !i.labels.some(l => l.name === 'stale')
            );

            if (staleIssues.length > 0) {
              console.log(`âš ï¸ ${staleIssues.length} issues might be stale:`);
              staleIssues.forEach(issue => {
                console.log(`  - #${issue.number}: ${issue.title} (${issue.created_at})`);
              });
            } else {
              console.log('âœ… No stale issues detected');
            }
