#!/usr/bin/env bun
/**
 * cb-status - Clawdbot health check
 * Usage: cb-status [--json] [--deep] [--watch] [--alerts]
 */

const BOT_TOKEN = "7873135075:AAHmySXcKIJpQ0KQX0aAOufB-VPMsdMF73Y";
const GATEWAY_URL = "http://127.0.0.1:18789";
const CONFIG_PATH = `${Bun.env.HOME}/.clawdbot/clawdbot.json`;
const LOG_DIR = "/tmp/clawdbot";

interface ServiceStatus {
  ok: boolean;
  message: string;
  details?: Record<string, any>;
}

interface FullStatus {
  timestamp: string;
  services: {
    gateway: ServiceStatus;
    tmux: ServiceStatus;
    telegram: ServiceStatus;
    config: ServiceStatus;
  };
  system?: {
    disk: ServiceStatus;
    memory: ServiceStatus;
    logs: ServiceStatus;
    uptime: ServiceStatus;
  };
  alerts: string[];
}

// Service checks
async function checkGateway(): Promise<ServiceStatus> {
  try {
    const start = Date.now();
    const res = await fetch(GATEWAY_URL);
    const latency = Date.now() - start;

    if (!res.ok) {
      return { ok: false, message: `HTTP ${res.status}`, details: { latency } };
    }

    return {
      ok: true,
      message: `up (${latency}ms)`,
      details: { status: res.status, latency }
    };
  } catch (err: any) {
    return { ok: false, message: "not responding", details: { error: err.message } };
  }
}

async function checkTmux(): Promise<ServiceStatus> {
  try {
    const proc = Bun.spawn(["tmux", "list-windows", "-t", "clawdbot", "-F", "#{window_name}"]);
    const exitCode = await proc.exited;

    if (exitCode !== 0) {
      return { ok: false, message: "session not found" };
    }

    const text = await new Response(proc.stdout).text();
    const windows = text.trim().split("\n").filter(l => l.length > 0);

    return {
      ok: true,
      message: `${windows.length} windows`,
      details: { windows }
    };
  } catch {
    return { ok: false, message: "tmux error" };
  }
}

async function checkTelegram(): Promise<ServiceStatus> {
  try {
    const start = Date.now();
    const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getMe`);
    const latency = Date.now() - start;
    const data = await res.json();

    if (!data.ok) {
      return { ok: false, message: data.description || "API error" };
    }

    return {
      ok: true,
      message: `@${data.result.username}`,
      details: {
        username: data.result.username,
        id: data.result.id,
        latency
      }
    };
  } catch (err: any) {
    return { ok: false, message: err.message || "connection failed" };
  }
}

async function checkConfig(): Promise<ServiceStatus> {
  try {
    const file = Bun.file(CONFIG_PATH);
    if (!await file.exists()) {
      return { ok: false, message: "file missing" };
    }

    const config = await file.json();
    const model = config.agents?.defaults?.model?.primary || "not set";
    const telegram = config.channels?.telegram?.enabled ? "enabled" : "disabled";

    return {
      ok: true,
      message: "valid",
      details: { model, telegram, path: CONFIG_PATH }
    };
  } catch (err: any) {
    return { ok: false, message: `parse error: ${err.message}` };
  }
}

// System checks (deep mode)
async function checkDisk(): Promise<ServiceStatus> {
  try {
    const proc = Bun.spawn(["df", "-h", "/"]);
    await proc.exited;
    const text = await new Response(proc.stdout).text();
    const lines = text.trim().split("\n");

    if (lines.length < 2) {
      return { ok: false, message: "could not read disk info" };
    }

    const parts = lines[1].split(/\s+/);
    const used = parts[4]?.replace("%", "") || "0";
    const usedPct = parseInt(used);

    const ok = usedPct < 90;
    return {
      ok,
      message: `${used}% used`,
      details: { size: parts[1], used: parts[2], avail: parts[3], pct: usedPct }
    };
  } catch {
    return { ok: false, message: "check failed" };
  }
}

async function checkMemory(): Promise<ServiceStatus> {
  try {
    // macOS: use memory_pressure for accurate available memory
    const proc = Bun.spawn(["memory_pressure"]);
    await proc.exited;
    const text = await new Response(proc.stdout).text();

    // Parse "System-wide memory free percentage: XX%"
    const pctMatch = text.match(/free percentage:\s*(\d+)%/);

    if (pctMatch) {
      const freePct = parseInt(pctMatch[1]);
      const ok = freePct >= 5; // macOS manages memory well, only warn at <5%

      return {
        ok,
        message: `${freePct}% available`,
        details: { freePct }
      };
    }

    // Fallback: check memory pressure level
    const levelMatch = text.match(/The system has (\w+) memory/i);
    if (levelMatch) {
      const level = levelMatch[1].toLowerCase();
      const ok = level !== "critical";
      return {
        ok,
        message: level,
        details: { level }
      };
    }

    return { ok: true, message: "available" };
  } catch {
    return { ok: true, message: "ok" };
  }
}

async function checkLogs(): Promise<ServiceStatus> {
  try {
    const today = new Date().toISOString().split("T")[0];
    const logFile = `${LOG_DIR}/clawdbot-${today}.log`;
    const file = Bun.file(logFile);

    if (!await file.exists()) {
      return { ok: true, message: "no logs today", details: { path: logFile } };
    }

    const stat = await file.stat();
    const sizeMB = Math.round(stat.size / 1024 / 1024 * 10) / 10;
    const mtime = new Date(stat.mtime).toLocaleTimeString();

    // Check for recent errors
    const content = await file.text();
    const lines = content.trim().split("\n");
    const recentLines = lines.slice(-100);
    const errorCount = recentLines.filter(l =>
      l.includes("error") || l.includes("Error") || l.includes("ERROR")
    ).length;

    return {
      ok: errorCount < 10,
      message: `${sizeMB}MB, ${errorCount} recent errors`,
      details: { path: logFile, sizeMB, lastModified: mtime, recentErrors: errorCount }
    };
  } catch {
    return { ok: true, message: "could not read logs" };
  }
}

async function checkUptime(): Promise<ServiceStatus> {
  try {
    const proc = Bun.spawn(["uptime"]);
    await proc.exited;
    const text = await new Response(proc.stdout).text();

    // Parse uptime output
    const uptimeMatch = text.match(/up\s+(.+?),\s+\d+\s+user/);
    const loadMatch = text.match(/load average[s]?:\s+([\d.]+)/);

    const uptime = uptimeMatch?.[1]?.trim() || "unknown";
    const load = loadMatch?.[1] || "0";
    const loadNum = parseFloat(load);

    return {
      ok: loadNum < 8,
      message: `${uptime}, load ${load}`,
      details: { uptime, load: loadNum }
    };
  } catch {
    return { ok: true, message: "unknown" };
  }
}

// Alert generation
function generateAlerts(status: FullStatus): string[] {
  const alerts: string[] = [];

  if (!status.services.gateway.ok) {
    alerts.push("CRITICAL: Gateway is down - run 'cb-restart'");
  }
  if (!status.services.tmux.ok) {
    alerts.push("WARNING: tmux session missing - run 'cb-restart --full'");
  }
  if (!status.services.telegram.ok) {
    alerts.push("WARNING: Telegram API unreachable - check bot token");
  }
  if (!status.services.config.ok) {
    alerts.push("ERROR: Config invalid - run 'cb-config --edit'");
  }

  if (status.system) {
    if (!status.system.disk.ok) {
      alerts.push("WARNING: Disk space low (>90% used)");
    }
    if (!status.system.memory.ok) {
      alerts.push("WARNING: Memory pressure critical");
    }
    if (!status.system.logs.ok) {
      alerts.push("WARNING: Many recent errors in logs");
    }
    if (!status.system.uptime.ok) {
      alerts.push("WARNING: High system load");
    }
  }

  return alerts;
}

// Display helpers
const icon = (ok: boolean) => ok ? "✓" : "✗";
const color = (ok: boolean, text: string) => ok ? `\x1b[32m${text}\x1b[0m` : `\x1b[31m${text}\x1b[0m`;
const yellow = (text: string) => `\x1b[33m${text}\x1b[0m`;
const dim = (text: string) => `\x1b[2m${text}\x1b[0m`;

function displayStatus(status: FullStatus, showAlerts: boolean) {
  console.clear();
  console.log("\n┌─────────────────────────────────────────┐");
  console.log("│          CLAWDBOT STATUS                │");
  console.log("└─────────────────────────────────────────┘\n");

  console.log("  Services");
  console.log("  " + "─".repeat(38));
  console.log(`    ${color(status.services.gateway.ok, icon(status.services.gateway.ok))} Gateway     ${status.services.gateway.message}`);
  console.log(`    ${color(status.services.tmux.ok, icon(status.services.tmux.ok))} tmux        ${status.services.tmux.message}`);
  console.log(`    ${color(status.services.telegram.ok, icon(status.services.telegram.ok))} Telegram    ${status.services.telegram.message}`);
  console.log(`    ${color(status.services.config.ok, icon(status.services.config.ok))} Config      ${status.services.config.message}`);

  if (status.system) {
    console.log("\n  System");
    console.log("  " + "─".repeat(38));
    console.log(`    ${color(status.system.disk.ok, icon(status.system.disk.ok))} Disk        ${status.system.disk.message}`);
    console.log(`    ${color(status.system.memory.ok, icon(status.system.memory.ok))} Memory      ${status.system.memory.message}`);
    console.log(`    ${color(status.system.logs.ok, icon(status.system.logs.ok))} Logs        ${status.system.logs.message}`);
    console.log(`    ${color(status.system.uptime.ok, icon(status.system.uptime.ok))} Uptime      ${status.system.uptime.message}`);
  }

  if (showAlerts && status.alerts.length > 0) {
    console.log("\n  " + yellow("Alerts"));
    console.log("  " + "─".repeat(38));
    for (const alert of status.alerts) {
      console.log(`    ${yellow("⚠")} ${alert}`);
    }
  }

  // Model info from config details
  const model = status.services.config.details?.model;
  if (model) {
    console.log("\n  " + dim(`Model: ${model}`));
  }

  console.log("  " + dim(`Updated: ${new Date(status.timestamp).toLocaleTimeString()}`));
  console.log();
}

async function collectStatus(deep: boolean): Promise<FullStatus> {
  const [gateway, tmux, telegram, config] = await Promise.all([
    checkGateway(),
    checkTmux(),
    checkTelegram(),
    checkConfig(),
  ]);

  const status: FullStatus = {
    timestamp: new Date().toISOString(),
    services: { gateway, tmux, telegram, config },
    alerts: [],
  };

  if (deep) {
    const [disk, memory, logs, uptime] = await Promise.all([
      checkDisk(),
      checkMemory(),
      checkLogs(),
      checkUptime(),
    ]);
    status.system = { disk, memory, logs, uptime };
  }

  status.alerts = generateAlerts(status);
  return status;
}

async function main() {
  const args = Bun.argv.slice(2);
  const jsonMode = args.includes("--json");
  const deepMode = args.includes("--deep");
  const watchMode = args.includes("--watch");
  const alertsMode = args.includes("--alerts");

  if (watchMode) {
    console.log("Watching status (Ctrl+C to stop)...\n");

    while (true) {
      const status = await collectStatus(deepMode);
      displayStatus(status, alertsMode);
      await Bun.sleep(5000);
    }
  }

  const status = await collectStatus(deepMode);

  if (jsonMode) {
    console.log(JSON.stringify(status, null, 2));
    return process.exit(status.alerts.length > 0 ? 1 : 0);
  }

  displayStatus(status, alertsMode);

  const allServicesOk = Object.values(status.services).every(s => s.ok);
  const allSystemOk = !status.system || Object.values(status.system).every(s => s.ok);

  process.exit(allServicesOk && allSystemOk ? 0 : 1);
}

main();
