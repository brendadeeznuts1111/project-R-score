#!/usr/bin/env bun
/**
 * cb-cron - Scheduled task runner
 * Usage: cb-cron [--daemon] | cb-cron add <name> <schedule> <command>
 *
 * Schedule: cron-style or interval (5m, 1h, 30s)
 */

const CRON_FILE = `${Bun.env.HOME}/.clawdbot/cron.json`;
const LOG_FILE = "/tmp/clawdbot/cron.log";
const BOT_TOKEN = "7873135075:AAHmySXcKIJpQ0KQX0aAOufB-VPMsdMF73Y";
const GROUP_CHAT = "-1003663527473";

// Topic IDs
const TOPICS = {
  general: 1,
  code: 2,
  research: 5,
  tasks: 7
};

interface CronJob {
  name: string;
  schedule: string;
  command: string;
  enabled: boolean;
  lastRun?: string;
  nextRun?: string;
  runCount: number;
  lastStatus?: "success" | "failed";
  lastOutput?: string;
  // Telegram notification settings
  notify?: {
    topic: number;        // Topic ID to send to
    on: "always" | "failure" | "success";  // When to notify
    silent?: boolean;     // Disable notification sound
  };
}

interface CronConfig {
  jobs: CronJob[];
}

// Display helpers
const green = (t: string) => `\x1b[32m${t}\x1b[0m`;
const red = (t: string) => `\x1b[31m${t}\x1b[0m`;
const yellow = (t: string) => `\x1b[33m${t}\x1b[0m`;
const dim = (t: string) => `\x1b[2m${t}\x1b[0m`;

// Send Telegram notification
async function sendTelegramNotification(
  topic: number,
  message: string,
  silent: boolean = false
): Promise<boolean> {
  try {
    const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: GROUP_CHAT,
        message_thread_id: topic,
        text: message,
        parse_mode: "Markdown",
        disable_notification: silent
      })
    });
    const data = await res.json();
    return data.ok;
  } catch {
    return false;
  }
}

// Format job result for Telegram
function formatJobNotification(job: CronJob, ok: boolean, output: string, duration: number): string {
  const status = ok ? "‚úÖ" : "‚ùå";
  const time = new Date().toLocaleTimeString();

  let msg = `${status} *Cron: ${job.name}*\n`;
  msg += `‚è± ${time} (${duration}ms)\n`;

  if (!ok) {
    // Include error output for failures
    const errorPreview = output.slice(0, 300).replace(/[`*_]/g, "");
    msg += `\n\`\`\`\n${errorPreview}\n\`\`\``;
  } else if (job.name === "health-check") {
    // Parse health check JSON for summary
    try {
      const data = JSON.parse(output);
      const services = data.services || {};
      const allOk = Object.values(services).every((s: any) => s.ok);
      if (allOk) {
        msg += `\nAll services healthy ‚úì`;
      } else {
        const failed = Object.entries(services)
          .filter(([_, s]: [string, any]) => !s.ok)
          .map(([name]) => name);
        msg += `\n‚ö†Ô∏è Issues: ${failed.join(", ")}`;
      }
    } catch {
      msg += `\nCompleted successfully`;
    }
  } else if (job.name === "test-suite") {
    // Parse test results
    try {
      const passMatch = output.match(/(\d+) passed/);
      const failMatch = output.match(/(\d+) failed/);
      if (passMatch) {
        msg += `\n${passMatch[1]} passed`;
        if (failMatch && parseInt(failMatch[1]) > 0) {
          msg += `, ${failMatch[1]} failed`;
        }
      }
    } catch {
      msg += `\nCompleted`;
    }
  }

  return msg;
}

// Parse interval string (5m, 1h, 30s) to milliseconds
function parseInterval(schedule: string): number | null {
  const match = schedule.match(/^(\d+)(s|m|h|d)$/);
  if (!match) return null;

  const value = parseInt(match[1]);
  const unit = match[2];

  switch (unit) {
    case "s": return value * 1000;
    case "m": return value * 60 * 1000;
    case "h": return value * 60 * 60 * 1000;
    case "d": return value * 24 * 60 * 60 * 1000;
    default: return null;
  }
}

// Parse cron expression to next run time
function parseCron(schedule: string): Date | null {
  const parts = schedule.split(" ");
  if (parts.length !== 5) return null;

  const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
  const now = new Date();

  // Simple implementation - handles basic patterns
  // For production, use a proper cron parser

  let nextMinute = now.getMinutes();
  let nextHour = now.getHours();

  // Handle minute
  if (minute === "*") {
    nextMinute = now.getMinutes() + 1;
  } else if (minute.startsWith("*/")) {
    const interval = parseInt(minute.slice(2));
    nextMinute = Math.ceil((now.getMinutes() + 1) / interval) * interval;
  } else {
    nextMinute = parseInt(minute);
    if (nextMinute <= now.getMinutes()) {
      nextHour++;
    }
  }

  // Handle hour overflow
  if (nextMinute >= 60) {
    nextMinute = nextMinute % 60;
    nextHour++;
  }

  // Handle hour
  if (hour !== "*" && !hour.startsWith("*/")) {
    nextHour = parseInt(hour);
  }

  const next = new Date(now);
  next.setMinutes(nextMinute);
  next.setSeconds(0);
  next.setMilliseconds(0);

  if (nextHour !== now.getHours()) {
    next.setHours(nextHour);
    if (minute === "*" || minute.startsWith("*/")) {
      next.setMinutes(0);
    }
  }

  // If next is in the past, add appropriate time
  if (next <= now) {
    if (minute.startsWith("*/")) {
      const interval = parseInt(minute.slice(2));
      next.setMinutes(next.getMinutes() + interval);
    } else {
      next.setHours(next.getHours() + 1);
    }
  }

  return next;
}

function getNextRun(schedule: string): Date | null {
  // Try interval format first
  const intervalMs = parseInterval(schedule);
  if (intervalMs) {
    return new Date(Date.now() + intervalMs);
  }

  // Try cron format
  return parseCron(schedule);
}

async function loadConfig(): Promise<CronConfig> {
  try {
    const file = Bun.file(CRON_FILE);
    if (await file.exists()) {
      return await file.json();
    }
  } catch {}

  // Default jobs
  return {
    jobs: [
      {
        name: "health-check",
        schedule: "5m",
        command: "bun ~/clawd/scripts/cb-status --json",
        enabled: true,
        runCount: 0
      },
      {
        name: "test-suite",
        schedule: "1h",
        command: "bun ~/clawd/scripts/cb-test --json",
        enabled: false,
        runCount: 0
      }
    ]
  };
}

async function saveConfig(config: CronConfig) {
  await Bun.write(CRON_FILE, JSON.stringify(config, null, 2));
}

async function logEvent(event: string, data: any) {
  const line = JSON.stringify({
    time: new Date().toISOString(),
    event,
    ...data
  }) + "\n";

  await Bun.write(LOG_FILE, line, { append: true });
}

async function runJob(job: CronJob): Promise<{ ok: boolean; output: string; duration: number }> {
  const start = Date.now();

  try {
    const proc = Bun.spawn(["bash", "-c", job.command], {
      stdout: "pipe",
      stderr: "pipe"
    });

    const [stdout, stderr] = await Promise.all([
      new Response(proc.stdout).text(),
      new Response(proc.stderr).text()
    ]);

    const code = await proc.exited;
    const duration = Date.now() - start;

    await logEvent("job_completed", {
      job: job.name,
      code,
      duration,
      output: (stdout || stderr).slice(0, 500)
    });

    return {
      ok: code === 0,
      output: stdout || stderr,
      duration
    };
  } catch (err: any) {
    const duration = Date.now() - start;
    await logEvent("job_failed", { job: job.name, error: err.message });
    return { ok: false, output: err.message, duration };
  }
}

async function runDaemon(config: CronConfig) {
  console.log("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
  console.log("‚îÇ          CLAWDBOT SCHEDULER             ‚îÇ");
  console.log("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");

  const enabledJobs = config.jobs.filter(j => j.enabled);
  console.log(`  Jobs:   ${enabledJobs.length} enabled / ${config.jobs.length} total`);
  console.log(`  Config: ${dim(CRON_FILE)}`);
  console.log(`  Log:    ${dim(LOG_FILE)}`);
  console.log();

  // Initialize next run times
  const jobTimers: Map<string, Date> = new Map();

  for (const job of enabledJobs) {
    const nextRun = getNextRun(job.schedule);
    if (nextRun) {
      jobTimers.set(job.name, nextRun);
      job.nextRun = nextRun.toISOString();
      console.log(`  ${green("‚óè")} ${job.name.padEnd(20)} ${job.schedule.padEnd(10)} next: ${nextRun.toLocaleTimeString()}`);
    } else {
      console.log(`  ${red("‚óè")} ${job.name.padEnd(20)} ${job.schedule.padEnd(10)} ${red("invalid schedule")}`);
    }
  }

  console.log();
  console.log(`  ${dim("Scheduler running... (Ctrl+C to stop)")}`);
  console.log();

  await logEvent("scheduler_started", { jobs: enabledJobs.length });
  await saveConfig(config);

  // Main loop
  while (true) {
    const now = new Date();

    for (const job of enabledJobs) {
      const nextRun = jobTimers.get(job.name);
      if (!nextRun || now < nextRun) continue;

      // Time to run
      console.log(`  [${now.toLocaleTimeString()}] Running: ${job.name}`);

      const result = await runJob(job);

      job.lastRun = now.toISOString();
      job.runCount++;
      job.lastStatus = result.ok ? "success" : "failed";
      job.lastOutput = result.output.slice(0, 200);

      // Schedule next run
      const newNextRun = getNextRun(job.schedule);
      if (newNextRun) {
        jobTimers.set(job.name, newNextRun);
        job.nextRun = newNextRun.toISOString();
      }

      const status = result.ok ? green("‚úì") : red("‚úó");
      console.log(`  [${now.toLocaleTimeString()}] ${status} ${job.name} completed`);

      // Send Telegram notification if configured
      if (job.notify) {
        const shouldNotify =
          job.notify.on === "always" ||
          (job.notify.on === "failure" && !result.ok) ||
          (job.notify.on === "success" && result.ok);

        if (shouldNotify) {
          const message = formatJobNotification(job, result.ok, result.output, result.duration);
          const sent = await sendTelegramNotification(job.notify.topic, message, job.notify.silent);
          if (sent) {
            console.log(`  [${now.toLocaleTimeString()}] üì§ Notified topic ${job.notify.topic}`);
          } else {
            console.log(`  [${now.toLocaleTimeString()}] ${red("!")} Notification failed`);
          }
        }
      }

      await saveConfig(config);
    }

    // Sleep for 1 second
    await Bun.sleep(1000);
  }
}

async function addJob(name: string, schedule: string, command: string) {
  const config = await loadConfig();

  // Check if job exists
  const existing = config.jobs.find(j => j.name === name);
  if (existing) {
    console.log(`\n  ${yellow("!")} Job "${name}" already exists. Updating...\n`);
    existing.schedule = schedule;
    existing.command = command;
  } else {
    config.jobs.push({
      name,
      schedule,
      command,
      enabled: true,
      runCount: 0
    });
    console.log(`\n  ${green("‚úì")} Added job: ${name}\n`);
  }

  await saveConfig(config);
}

async function listJobs() {
  const config = await loadConfig();

  console.log("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
  console.log("‚îÇ          SCHEDULED JOBS                 ‚îÇ");
  console.log("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");

  if (config.jobs.length === 0) {
    console.log("  No jobs configured.\n");
    console.log(`  Add one: cb-cron add <name> <schedule> <command>\n`);
    return;
  }

  for (const job of config.jobs) {
    const status = job.enabled ? green("‚óè") : dim("‚óã");
    const lastStatus = job.lastStatus === "success" ? green("‚úì") : job.lastStatus === "failed" ? red("‚úó") : dim("-");

    console.log(`  ${status} ${job.name}`);
    console.log(`      Schedule: ${job.schedule}`);
    console.log(`      Command:  ${dim(job.command.slice(0, 50))}${job.command.length > 50 ? "..." : ""}`);
    console.log(`      Runs:     ${job.runCount} ${lastStatus}`);
    if (job.notify) {
      const topicName = Object.entries(TOPICS).find(([_, v]) => v === job.notify!.topic)?.[0] || job.notify.topic;
      console.log(`      Notify:   üì§ ${topicName} (${job.notify.on})`);
    }
    if (job.lastRun) {
      console.log(`      Last:     ${new Date(job.lastRun).toLocaleString()}`);
    }
    console.log();
  }
}

async function toggleJob(name: string, enabled: boolean) {
  const config = await loadConfig();
  const job = config.jobs.find(j => j.name === name);

  if (!job) {
    console.log(`\n  ${red("‚úó")} Job "${name}" not found\n`);
    return;
  }

  job.enabled = enabled;
  await saveConfig(config);
  console.log(`\n  ${green("‚úì")} Job "${name}" ${enabled ? "enabled" : "disabled"}\n`);
}

async function removeJob(name: string) {
  const config = await loadConfig();
  const index = config.jobs.findIndex(j => j.name === name);

  if (index === -1) {
    console.log(`\n  ${red("‚úó")} Job "${name}" not found\n`);
    return;
  }

  config.jobs.splice(index, 1);
  await saveConfig(config);
  console.log(`\n  ${green("‚úì")} Job "${name}" removed\n`);
}

async function setNotify(name: string, topic: string, on: string) {
  const config = await loadConfig();
  const job = config.jobs.find(j => j.name === name);

  if (!job) {
    console.log(`\n  ${red("‚úó")} Job "${name}" not found\n`);
    return;
  }

  // Parse topic (can be number or name)
  let topicId: number;
  if (topic === "off" || topic === "none") {
    delete job.notify;
    await saveConfig(config);
    console.log(`\n  ${green("‚úì")} Notifications disabled for "${name}"\n`);
    return;
  } else if (TOPICS[topic as keyof typeof TOPICS]) {
    topicId = TOPICS[topic as keyof typeof TOPICS];
  } else {
    topicId = parseInt(topic);
    if (isNaN(topicId)) {
      console.log(`\n  ${red("‚úó")} Invalid topic: ${topic}`);
      console.log(`  Use: general, code, research, tasks, or topic ID\n`);
      return;
    }
  }

  // Validate 'on' parameter
  if (!["always", "failure", "success"].includes(on)) {
    console.log(`\n  ${red("‚úó")} Invalid notify mode: ${on}`);
    console.log(`  Use: always, failure, or success\n`);
    return;
  }

  job.notify = {
    topic: topicId,
    on: on as "always" | "failure" | "success"
  };

  await saveConfig(config);
  console.log(`\n  ${green("‚úì")} Job "${name}" will notify topic ${topicId} on ${on}\n`);
}

function showHelp() {
  console.log(`
  ${green("cb-cron")} - Scheduled task runner with Telegram notifications

  Usage:
    cb-cron                     Run scheduler daemon
    cb-cron list                List all jobs
    cb-cron add <n> <s> <cmd>   Add a job
    cb-cron enable <name>       Enable a job
    cb-cron disable <name>      Disable a job
    cb-cron remove <name>       Remove a job
    cb-cron run <name>          Run a job immediately
    cb-cron notify <name> <topic> <on>   Set Telegram notification

  Schedule formats:
    Interval: 30s, 5m, 1h, 1d
    Cron:     "*/5 * * * *" (every 5 minutes)

  Topics:
    general (1), code (2), research (5), tasks (7)

  Notify modes:
    always    - Notify on every run
    failure   - Only notify on failures
    success   - Only notify on success

  Examples:
    cb-cron add health "5m" "cb-status --json"
    cb-cron notify health code failure      # Alert Code topic on failure
    cb-cron notify test-suite code always   # Post all test results
    cb-cron notify health off               # Disable notifications
    cb-cron run health
`);
}

async function main() {
  const args = Bun.argv.slice(2);
  const command = args[0];

  // Ensure directories exist
  await Bun.spawn(["mkdir", "-p", "/tmp/clawdbot"]).exited;

  if (!command || command === "--daemon") {
    const config = await loadConfig();
    await runDaemon(config);
    return;
  }

  if (command === "list" || command === "ls") {
    await listJobs();
    return;
  }

  if (command === "add" && args.length >= 4) {
    const name = args[1];
    const schedule = args[2];
    const cmd = args.slice(3).join(" ");
    await addJob(name, schedule, cmd);
    return;
  }

  if (command === "enable" && args[1]) {
    await toggleJob(args[1], true);
    return;
  }

  if (command === "disable" && args[1]) {
    await toggleJob(args[1], false);
    return;
  }

  if (command === "remove" && args[1]) {
    await removeJob(args[1]);
    return;
  }

  if (command === "notify" && args[1]) {
    const topic = args[2] || "off";
    const on = args[3] || "always";
    await setNotify(args[1], topic, on);
    return;
  }

  if (command === "run" && args[1]) {
    const config = await loadConfig();
    const job = config.jobs.find(j => j.name === args[1]);

    if (!job) {
      console.log(`\n  ${red("‚úó")} Job "${args[1]}" not found\n`);
      return;
    }

    console.log(`\n  Running: ${job.name}...`);
    const result = await runJob(job);

    job.lastRun = new Date().toISOString();
    job.runCount++;
    job.lastStatus = result.ok ? "success" : "failed";
    await saveConfig(config);

    const status = result.ok ? green("‚úì") : red("‚úó");
    console.log(`  ${status} Done\n`);

    // Send Telegram notification if configured
    if (job.notify) {
      const shouldNotify =
        job.notify.on === "always" ||
        (job.notify.on === "failure" && !result.ok) ||
        (job.notify.on === "success" && result.ok);

      if (shouldNotify) {
        const message = formatJobNotification(job, result.ok, result.output, result.duration);
        console.log(`  Sending notification to topic ${job.notify.topic}...`);
        const sent = await sendTelegramNotification(job.notify.topic, message, job.notify.silent);
        if (sent) {
          console.log(`  ${green("‚úì")} Notification sent\n`);
        } else {
          console.log(`  ${red("‚úó")} Notification failed\n`);
        }
      }
    }

    if (result.output) {
      console.log(dim("  Output:"));
      console.log(result.output.split("\n").map(l => `  ${l}`).join("\n"));
    }
    return;
  }

  if (command === "--help" || command === "-h") {
    showHelp();
    return;
  }

  showHelp();
}

main();
