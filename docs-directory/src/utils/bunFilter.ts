import { BUN_FILTER_OPERATIONS, BunFilterQuery, validateBunFilter } from '../config/bunConstants';\n\nexport class BunFilterParser {\n  static parseFilterString(filterString: string): BunFilterQuery {\n    const filters: BunFilterQuery = {};\n    \n    if (!filterString || !filterString.trim()) {\n      return filters;\n    }\n    \n    // Split by -- separator for multiple filters\n    const filterGroups = filterString.split(BUN_FILTER_OPERATIONS.SEPARATOR).filter(group => group.trim());\n    \n    for (const group of filterGroups) {\n      this.parseFilterGroup(group.trim(), filters);\n    }\n    \n    return filters;\n  }\n  \n  private static parseFilterGroup(group: string, filters: BunFilterQuery): void {\n    // Parse key=value pairs\n    const pairs = group.split(/\\s+/).filter(pair => pair.includes('='));\n    \n    for (const pair of pairs) {\n      const [key, ...valueParts] = pair.split('=');\n      const value = valueParts.join('=');\n      \n      if (!key || !value) continue;\n      \n      switch (key.toLowerCase()) {\n        case 'category':\n          filters.category = value;\n          break;\n          \n        case 'status':\n          filters.status = value;\n          break;\n          \n        case 'tags':\n          filters.tags = value.split(',').map(tag => tag.trim());\n          break;\n          \n        case 'memory':\n          this.parseMemoryFilter(value, filters);\n          break;\n          \n        case 'date':\n          this.parseDateFilter(value, filters);\n          break;\n      }\n    }\n  }\n  \n  private static parseMemoryFilter(value: string, filters: BunFilterQuery): void {\n    if (!filters.performance) {\n      filters.performance = {};\n    }\n    \n    // Parse memory filters like >100MB, <500MB, =200MB\n    const match = value.match(/([><=])(\\d+(?:\\.\\d+)?)(MB|GB|KB)?/i);\n    \n    if (match) {\n      const [, operator, amount, unit] = match;\n      const bytes = this.convertToBytes(parseFloat(amount), unit?.toUpperCase() || 'MB');\n      \n      switch (operator) {\n        case '>':\n          filters.performance.minMemory = bytes;\n          break;\n        case '<':\n          filters.performance.maxMemory = bytes;\n          break;\n        case '=':\n          filters.performance.minMemory = bytes;\n          filters.performance.maxMemory = bytes;\n          break;\n      }\n    }\n  }\n  \n  private static parseDateFilter(value: string, filters: BunFilterQuery): void {\n    // Parse date range like 2024-01-01..2024-12-31\n    const dateRange = value.split('..');\n    \n    if (dateRange.length === 2) {\n      filters.dateRange = {\n        start: dateRange[0].trim(),\n        end: dateRange[1].trim()\n      };\n    } else {\n      // Single date - treat as start date\n      filters.dateRange = {\n        start: value.trim(),\n        end: new Date().toISOString().split('T')[0]\n      };\n    }\n  }\n  \n  private static convertToBytes(amount: number, unit: string): number {\n    switch (unit) {\n      case 'KB': return amount * 1024;\n      case 'MB': return amount * 1024 * 1024;\n      case 'GB': return amount * 1024 * 1024 * 1024;\n      default: return amount;\n    }\n  }\n}\n\nexport class BunFilterMatcher {\n  static matches(item: any, filter: BunFilterQuery): boolean {\n    if (!validateBunFilter(filter)) {\n      return false;\n    }\n    \n    // Category filter\n    if (filter.category && item.category !== filter.category) {\n      return false;\n    }\n    \n    // Status filter\n    if (filter.status && item.status !== filter.status) {\n      return false;\n    }\n    \n    // Tags filter\n    if (filter.tags && filter.tags.length > 0) {\n      const itemTags = item.tags || [];\n      const hasAllTags = filter.tags.every(tag => itemTags.includes(tag));\n      if (!hasAllTags) {\n        return false;\n      }\n    }\n    \n    // Performance filter\n    if (filter.performance && item.metrics) {\n      const { minMemory, maxMemory } = filter.performance;\n      \n      if (minMemory && item.metrics.memoryUsed < minMemory) {\n        return false;\n      }\n      \n      if (maxMemory && item.metrics.memoryUsed > maxMemory) {\n        return false;\n      }\n    }\n    \n    // Date range filter\n    if (filter.dateRange && item.timestamp) {\n      const itemDate = new Date(item.timestamp);\n      const startDate = new Date(filter.dateRange.start);\n      const endDate = new Date(filter.dateRange.end);\n      \n      if (itemDate < startDate || itemDate > endDate) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n  \n  static filterArray<T>(items: T[], filter: BunFilterQuery): T[] {\n    return items.filter(item => this.matches(item, filter));\n  }\n}\n\n// CLI-style filter builder\nexport class BunFilterBuilder {\n  private filters: string[] = [];\n  \n  category(value: string): this {\n    this.filters.push(`category=${value}`);\n    return this;\n  }\n  \n  status(value: string): this {\n    this.filters.push(`status=${value}`);\n    return this;\n  }\n  \n  tags(...values: string[]): this {\n    this.filters.push(`tags=${values.join(',')}`);\n    return this;\n  }\n  \n  memory(operator: '>' | '<' | '=', amount: number, unit: 'KB' | 'MB' | 'GB' = 'MB'): this {\n    this.filters.push(`memory=${operator}${amount}${unit}`);\n    return this;\n  }\n  \n  dateRange(start: string, end?: string): this {\n    if (end) {\n      this.filters.push(`date=${start}..${end}`);\n    } else {\n      this.filters.push(`date=${start}`);\n    }\n    return this;\n  }\n  \n  build(): string {\n    return this.filters.join(` ${BUN_FILTER_OPERATIONS.SEPARATOR} `);\n  }\n  \n  reset(): this {\n    this.filters = [];\n    return this;\n  }\n}\n\n// Utility functions for common filter operations\nexport const BunFilters = {\n  // Create filter for successful tests\n  successful: (): string => {\n    return new BunFilterBuilder().status('success').build();\n  },\n  \n  // Create filter for security features\n  security: (): string => {\n    return new BunFilterBuilder().category('security').build();\n  },\n  \n  // Create filter for high memory usage\n  highMemory: (threshold: number = 100): string => {\n    return new BunFilterBuilder().memory('>', threshold, 'MB').build();\n  },\n  \n  // Create filter for recent tests\n  recent: (days: number = 7): string => {\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n    return new BunFilterBuilder().dateRange(startDate.toISOString().split('T')[0]).build();\n  },\n  \n  // Create filter for specific tags\n  withTags: (...tags: string[]): string => {\n    return new BunFilterBuilder().tags(...tags).build();\n  },\n  \n  // Parse and validate filter string\n  parse: (filterString: string): BunFilterQuery => {\n    return BunFilterParser.parseFilterString(filterString);\n  },\n  \n  // Apply filter to array\n  apply: <T>(items: T[], filter: string | BunFilterQuery): T[] => {\n    const parsedFilter = typeof filter === 'string' \n      ? BunFilterParser.parseFilterString(filter)\n      : filter;\n    \n    return BunFilterMatcher.filterArray(items, parsedFilter);\n  }\n};\n\n// Example usage:\n// const filter = BunFilters.security();\n// const results = BunFilters.apply(testResults, filter);\n// \n// const customFilter = new BunFilterBuilder()\n//   .status('success')\n//   .memory('<', 50, 'MB')\n//   .dateRange('2024-01-01', '2024-12-31')\n//   .tags('performance', 'security')\n//   .build();
