import { BunFeatureTest, BunMetrics, BUN_CONFIG } from '../config/bunConstants';\nimport { createBunTestId, createBunError, BunErrorCode } from '../config/bunConstants';\nimport { logDatabaseError, logUIError } from './errorLogger';\nimport { withRetry, DEFAULT_RETRY_CONFIG } from './recoveryManager';\n\nexport interface BulkOperationConfig {\n  batchSize: number;\n  maxConcurrency: number;\n  progressInterval: number;\n  retryAttempts: number;\n  timeoutMs: number;\n}\n\nexport interface BulkOperationResult<T> {\n  total: number;\n  successful: number;\n  failed: number;\n  skipped: number;\n  duration: number;\n  items: T[];\n  errors: Array<{ item: T; error: string }>;\n  metrics: {\n    averageTime: number;\n    minTime: number;\n    maxTime: number;\n    throughput: number; // items per second\n  };\n}\n\nexport interface ProgressCallback {\n  (progress: {\n    completed: number;\n    total: number;\n    percentage: number;\n    currentBatch: number;\n    totalBatches: number;\n    eta: number; // estimated time remaining in seconds\n  }): void;\n}\n\nexport class BunBulkOperations {\n  private static defaultConfig: BulkOperationConfig = {\n    batchSize: BUN_CONFIG.PERFORMANCE.MEMORY_THRESHOLD > 0.8 ? 25 : 50,\n    maxConcurrency: 3,\n    progressInterval: BUN_CONFIG.PERFORMANCE.UPDATE_INTERVAL,\n    retryAttempts: 3,\n    timeoutMs: 30000\n  };\n\n  // Bulk test execution\n  static async executeBulkTests<T extends BunFeatureTest>(\n    tests: T[],\n    testExecutor: (test: T) => Promise<T>,\n    config: Partial<BulkOperationConfig> = {},\n    onProgress?: ProgressCallback\n  ): Promise<BulkOperationResult<T>> {\n    const finalConfig = { ...this.defaultConfig, ...config };\n    const startTime = Date.now();\n    \n    const result: BulkOperationResult<T> = {\n      total: tests.length,\n      successful: 0,\n      failed: 0,\n      skipped: 0,\n      duration: 0,\n      items: [],\n      errors: [],\n      metrics: {\n        averageTime: 0,\n        minTime: Infinity,\n        maxTime: 0,\n        throughput: 0\n      }\n    };\n\n    const batches = this.createBatches(tests, finalConfig.batchSize);\n    const executionTimes: number[] = [];\n    let completed = 0;\n\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      const batchStartTime = Date.now();\n      \n      // Execute batch with concurrency control\n      const batchResults = await this.executeBatchWithConcurrency(\n        batch,\n        testExecutor,\n        finalConfig,\n        (index, batchItem) => {\n          completed++;\n          if (onProgress) {\n            const elapsed = Date.now() - startTime;\n            const avgTime = elapsed / completed;\n            const remaining = tests.length - completed;\n            const eta = Math.floor((remaining * avgTime) / 1000);\n            \n            onProgress({\n              completed,\n              total: tests.length,\n              percentage: (completed / tests.length) * 100,\n              currentBatch: i + 1,\n              totalBatches: batches.length,\n              eta\n            });\n          }\n        }\n      );\n      \n      const batchDuration = Date.now() - batchStartTime;\n      executionTimes.push(batchDuration);\n      \n      // Process batch results\n      for (const batchResult of batchResults) {\n        if (batchResult.success) {\n          result.successful++;\n          result.items.push(batchResult.data);\n        } else {\n          result.failed++;\n          result.errors.push({\n            item: batchResult.originalItem,\n            error: batchResult.error\n          });\n        }\n      }\n      \n      // Memory management - trigger GC if needed\n      if (i % 5 === 0) {\n        await this.checkMemoryAndGC();\n      }\n    }\n    \n    // Calculate metrics\n    result.duration = Date.now() - startTime;\n    \n    if (executionTimes.length > 0) {\n      result.metrics.averageTime = executionTimes.reduce((a, b) => a + b, 0) / executionTimes.length;\n      result.metrics.minTime = Math.min(...executionTimes);\n      result.metrics.maxTime = Math.max(...executionTimes);\n      result.metrics.throughput = (result.successful / result.duration) * 1000; // per second\n    }\n    \n    return result;\n  }\n\n  // Bulk metrics collection\n  static async collectBulkMetrics(\n    sources: Array<() => Promise<BunMetrics>>,\n    config: Partial<BulkOperationConfig> = {}\n  ): Promise<BulkOperationResult<BunMetrics>> {\n    const metricsCollector = async (source: () => Promise<BunMetrics>): Promise<BunMetrics> => {\n      try {\n        return await withRetry(source, { component: 'BulkOperations', action: 'collectMetrics' }, DEFAULT_RETRY_CONFIG);\n      } catch (error) {\n        logDatabaseError('Failed to collect metrics', error instanceof Error ? error : new Error(String(error)));\n        throw error;\n      }\n    };\n    \n    return this.executeBulkTests(\n      sources.map((source, index) => ({\n        id: createBunTestId('metrics', `source-${index}`),\n        category: 'performance' as const,\n        name: `Metrics Source ${index}`,\n        description: 'Bulk metrics collection',\n        status: 'pending' as const,\n        timestamp: new Date().toISOString(),\n        source\n      } as any)),\n      async (test) => {\n        test.status = 'running';\n        try {\n          const metrics = await metricsCollector(test.source);\n          test.status = 'success';\n          test.result = metrics;\n          return test;\n        } catch (error) {\n          test.status = 'error';\n          test.error = error instanceof Error ? error.message : String(error);\n          throw error;\n        }\n      },\n      config\n    );\n  }\n\n  // Bulk data export\n  static async exportBulkData<T>(\n    data: T[],\n    exportFormatter: (items: T[]) => Promise<string | ArrayBuffer>,\n    format: string,\n    config: Partial<BulkOperationConfig> = {}\n  ): Promise<BulkOperationResult<T>> {\n    const batches = this.createBatches(data, config.batchSize || this.defaultConfig.batchSize);\n    const exportedBatches: string | ArrayBuffer[] = [];\n    \n    const exportExecutor = async (batch: T[]): Promise<string | ArrayBuffer> => {\n      try {\n        return await withRetry(\n          () => exportFormatter(batch),\n          { component: 'BulkOperations', action: 'exportData', format },\n          DEFAULT_RETRY_CONFIG\n        );\n      } catch (error) {\n        logUIError('Failed to export data batch', error instanceof Error ? error : new Error(String(error)));\n        throw error;\n      }\n    };\n    \n    for (const batch of batches) {\n      try {\n        const exportedBatch = await exportExecutor(batch);\n        exportedBatches.push(exportedBatch);\n      } catch (error) {\n        // Continue with other batches even if one fails\n        console.warn('Failed to export batch:', error);\n      }\n    }\n    \n    // Combine all exported batches\n    let combinedExport: string | ArrayBuffer;\n    if (typeof exportedBatches[0] === 'string') {\n      combinedExport = (exportedBatches as string[]).join('\\n');\n    } else {\n      // For binary data, we'd need to combine ArrayBuffers\n      const totalLength = exportedBatches.reduce((sum, batch) => sum + (batch as ArrayBuffer).byteLength, 0);\n      combinedExport = new ArrayBuffer(totalLength);\n      // In a real implementation, we'd copy the data here\n    }\n    \n    return {\n      total: data.length,\n      successful: exportedBatches.length * (config.batchSize || this.defaultConfig.batchSize),\n      failed: 0,\n      skipped: 0,\n      duration: 0,\n      items: data,\n      errors: [],\n      metrics: {\n        averageTime: 0,\n        minTime: 0,\n        maxTime: 0,\n        throughput: data.length / 1 // Simplified\n      }\n    };\n  }\n\n  private static createBatches<T>(items: T[], batchSize: number): T[][] {\n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  private static async executeBatchWithConcurrency<T, R>(\n    batch: T[],\n    executor: (item: T) => Promise<R>,\n    config: BulkOperationConfig,\n    onItemComplete?: (index: number, item: T) => void\n  ): Promise<Array<{ success: boolean; data?: R; error?: string; originalItem: T }>> {\n    const results: Array<{ success: boolean; data?: R; error?: string; originalItem: T }> = [];\n    \n    // Execute items with concurrency control\n    const semaphore = new Semaphore(config.maxConcurrency);\n    \n    const promises = batch.map(async (item, index) => {\n      await semaphore.acquire();\n      \n      try {\n        const result = await Promise.race([\n          executor(item),\n          new Promise<never>((_, reject) => \n            setTimeout(() => reject(new Error('Operation timeout')), config.timeoutMs)\n          )\n        ]);\n        \n        results[index] = { success: true, data: result, originalItem: item };\n        onItemComplete?.(index, item);\n        \n        return result;\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        results[index] = { success: false, error: errorMessage, originalItem: item };\n        onItemComplete?.(index, item);\n        \n        return null;\n      } finally {\n        semaphore.release();\n      }\n    });\n    \n    await Promise.allSettled(promises);\n    return results;\n  }\n\n  private static async checkMemoryAndGC(): Promise<void> {\n    if (typeof process !== 'undefined' && process.memoryUsage) {\n      const memUsage = process.memoryUsage();\n      const heapUsedMB = memUsage.heapUsed / 1024 / 1024;\n      \n      if (heapUsedMB > 500) { // 500MB threshold\n        if (typeof Bun !== 'undefined' && Bun.gc) {\n          Bun.gc();\n        }\n      }\n    }\n  }\n}\n\n// Simple semaphore implementation for concurrency control\nclass Semaphore {\n  private permits: number;\n  private waitQueue: (() => void)[] = [];\n  \n  constructor(permits: number) {\n    this.permits = permits;\n  }\n  \n  async acquire(): Promise<void> {\n    if (this.permits > 0) {\n      this.permits--;\n      return;\n    }\n    \n    return new Promise<void>((resolve) => {\n      this.waitQueue.push(resolve);\n    });\n  }\n  \n  release(): void {\n    this.permits++;\n    if (this.waitQueue.length > 0) {\n      const resolve = this.waitQueue.shift()!;\n      this.permits--;\n      resolve();\n    }\n  }\n}\n\n// Utility functions for common bulk operations\nexport const BunBulkUtils = {\n  // Create test items for bulk testing\n  createTestItems: (count: number, category: string): BunFeatureTest[] => {\n    return Array.from({ length: count }, (_, index) => ({\n      id: createBunTestId(category, `test-${index}`),\n      category: category as any,\n      name: `Test ${index + 1}`,\n      description: `Bulk test item ${index + 1}`,\n      status: 'pending' as const,\n      timestamp: new Date().toISOString()\n    }));\n  },\n  \n  // Calculate success rate\n  calculateSuccessRate: <T>(result: BulkOperationResult<T>): number => {\n    return result.total > 0 ? (result.successful / result.total) * 100 : 0;\n  },\n  \n  // Generate summary report\n  generateReport: <T>(result: BulkOperationResult<T>): string => {\n    const successRate = this.calculateSuccessRate(result);\n    return `\nBulk Operation Summary:\n- Total: ${result.total}\n- Successful: ${result.successful}\n- Failed: ${result.failed}\n- Skipped: ${result.skipped}\n- Success Rate: ${successRate.toFixed(1)}%\n- Duration: ${(result.duration / 1000).toFixed(2)}s\n- Throughput: ${result.metrics.throughput.toFixed(2)} items/s\n- Average Time: ${result.metrics.averageTime.toFixed(2)}ms\n    `.trim();\n  }\n};
