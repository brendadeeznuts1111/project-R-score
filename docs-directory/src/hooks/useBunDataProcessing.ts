import { useState, useEffect } from 'react';\n\ninterface BunDataProcessing {\n  jsonVariants: {\n    parseJSON5: (text: string) => any;\n    parseJSONC: (text: string) => any;\n    parseJSONL: (text: string) => any[];\n    stringifyJSON5: (obj: any) => string;\n    stringifyJSONC: (obj: any, comments?: string) => string;\n  };\n  configFormats: {\n    parseYAML: (text: string) => any;\n    parseTOML: (text: string) => any;\n    stringifyYAML: (obj: any) => string;\n    stringifyTOML: (obj: any) => string;\n  };\n  objectComparison: {\n    deepEquals: (obj1: any, obj2: any) => boolean;\n    deepMatch: (subset: any, superset: any) => boolean;\n  };\n  versionManagement: {\n    parse: (version: string) => { major: number; minor: number; patch: number; prerelease?: string };\n    compare: (v1: string, v2: string) => -1 | 0 | 1;\n    satisfies: (version: string, range: string) => boolean;\n  };\n}\n\nexport function useBunDataProcessing(): BunDataProcessing {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    setIsReady(true);\n  }, []);\n\n  // JSON Variants\n  const jsonVariants = {\n    parseJSON5: (text: string): any => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.JSON5) {\n          return Bun.JSON5.parse(text);\n        }\n        \n        // Fallback: strip comments and parse as regular JSON\n        const cleanedText = text.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n        return JSON.parse(cleanedText);\n      } catch (error) {\n        console.error('Failed to parse JSON5:', error);\n        throw error;\n      }\n    },\n\n    parseJSONC: (text: string): any => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.JSONC) {\n          return Bun.JSONC.parse(text);\n        }\n        \n        // Fallback: strip comments and parse as regular JSON\n        const cleanedText = text.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n        return JSON.parse(cleanedText);\n      } catch (error) {\n        console.error('Failed to parse JSONC:', error);\n        throw error;\n      }\n    },\n\n    parseJSONL: (text: string): any[] => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.JSONL) {\n          return Bun.JSONL.parse(text);\n        }\n        \n        // Fallback: split by lines and parse each line\n        const lines = text.trim().split('\\n');\n        return lines.map(line => {\n          if (line.trim()) {\n            return JSON.parse(line);\n          }\n          return null;\n        }).filter(Boolean);\n      } catch (error) {\n        console.error('Failed to parse JSONL:', error);\n        throw error;\n      }\n    },\n\n    stringifyJSON5: (obj: any): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.JSON5) {\n          return Bun.JSON5.stringify(obj, null, 2);\n        }\n        \n        // Fallback to regular JSON\n        return JSON.stringify(obj, null, 2);\n      } catch (error) {\n        console.error('Failed to stringify JSON5:', error);\n        throw error;\n      }\n    },\n\n    stringifyJSONC: (obj: any, comments?: string): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.JSONC) {\n          return Bun.JSONC.stringify(obj, null, 2);\n        }\n        \n        // Fallback with manual comment insertion\n        let json = JSON.stringify(obj, null, 2);\n        if (comments) {\n          const commentLines = comments.split('\\n');\n          json = commentLines.map(line => `// ${line}`).join('\\n') + '\\n' + json;\n        }\n        return json;\n      } catch (error) {\n        console.error('Failed to stringify JSONC:', error);\n        throw error;\n      }\n    }\n  };\n\n  // Configuration Formats\n  const configFormats = {\n    parseYAML: (text: string): any => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.YAML) {\n          return Bun.YAML.parse(text);\n        }\n        \n        // Basic YAML parser fallback (very limited)\n        const lines = text.split('\\n');\n        const result: any = {};\n        let currentKey = '';\n        let indentLevel = 0;\n        \n        for (const line of lines) {\n          const trimmed = line.trim();\n          if (!trimmed || trimmed.startsWith('#')) continue;\n          \n          const indent = line.length - line.trimStart().length;\n          const colonIndex = trimmed.indexOf(':');\n          \n          if (colonIndex > 0) {\n            const key = trimmed.substring(0, colonIndex).trim();\n            const value = trimmed.substring(colonIndex + 1).trim();\n            \n            if (value) {\n              // Try to parse as JSON, fallback to string\n              try {\n                result[key] = JSON.parse(value);\n              } catch {\n                result[key] = value.replace(/^['\"]|['\"]$/g, '');\n              }\n            } else {\n              result[key] = {};\n              currentKey = key;\n              indentLevel = indent;\n            }\n          }\n        }\n        \n        return result;\n      } catch (error) {\n        console.error('Failed to parse YAML:', error);\n        throw error;\n      }\n    },\n\n    parseTOML: (text: string): any => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.TOML) {\n          return Bun.TOML.parse(text);\n        }\n        \n        // Basic TOML parser fallback (very limited)\n        const lines = text.split('\\n');\n        const result: any = {};\n        \n        for (const line of lines) {\n          const trimmed = line.trim();\n          if (!trimmed || trimmed.startsWith('#')) continue;\n          \n          const equalIndex = trimmed.indexOf('=');\n          if (equalIndex > 0) {\n            const key = trimmed.substring(0, equalIndex).trim();\n            const value = trimmed.substring(equalIndex + 1).trim();\n            \n            try {\n              result[key] = JSON.parse(value);\n            } catch {\n              result[key] = value.replace(/^['\"]|['\"]$/g, '');\n            }\n          }\n        }\n        \n        return result;\n      } catch (error) {\n        console.error('Failed to parse TOML:', error);\n        throw error;\n      }\n    },\n\n    stringifyYAML: (obj: any): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.YAML) {\n          return Bun.YAML.stringify(obj);\n        }\n        \n        // Basic YAML stringifier fallback\n        const yaml = Object.entries(obj)\n          .map(([key, value]) => {\n            if (typeof value === 'object' && value !== null) {\n              return `${key}:\\n  ${JSON.stringify(value, null, 2).replace(/\\n/g, '\\n  ')}`;\n            }\n            return `${key}: ${JSON.stringify(value)}`;\n          })\n          .join('\\n');\n        \n        return yaml;\n      } catch (error) {\n        console.error('Failed to stringify YAML:', error);\n        throw error;\n      }\n    },\n\n    stringifyTOML: (obj: any): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.TOML) {\n          return Bun.TOML.stringify(obj);\n        }\n        \n        // Basic TOML stringifier fallback\n        const toml = Object.entries(obj)\n          .map(([key, value]) => {\n            return `${key} = ${JSON.stringify(value)}`;\n          })\n          .join('\\n');\n        \n        return toml;\n      } catch (error) {\n        console.error('Failed to stringify TOML:', error);\n        throw error;\n      }\n    }\n  };\n\n  // Object Comparison\n  const objectComparison = {\n    deepEquals: (obj1: any, obj2: any): boolean => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.deepEquals) {\n          return Bun.deepEquals(obj1, obj2);\n        }\n        \n        // Fallback deep equality check\n        return JSON.stringify(obj1) === JSON.stringify(obj2);\n      } catch (error) {\n        console.error('Failed to compare objects:', error);\n        return false;\n      }\n    },\n\n    deepMatch: (subset: any, superset: any): boolean => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.deepMatch) {\n          return Bun.deepMatch(subset, superset);\n        }\n        \n        // Fallback deep match check\n        if (typeof subset !== 'object' || typeof superset !== 'object') {\n          return subset === superset;\n        }\n        \n        for (const key in subset) {\n          if (!(key in superset)) {\n            return false;\n          }\n          \n          if (!this.deepEquals(subset[key], superset[key])) {\n            return false;\n          }\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Failed to match objects:', error);\n        return false;\n      }\n    }\n  };\n\n  // Version Management\n  const versionManagement = {\n    parse: (version: string): { major: number; minor: number; patch: number; prerelease?: string } => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.semver) {\n          return Bun.semver.parse(version);\n        }\n        \n        // Fallback semver parser\n        const match = version.match(/^(\\d+)\\.(\\d+)\\.(\\d+)(?:-(.+))?$/);\n        if (!match) {\n          throw new Error(`Invalid semver: ${version}`);\n        }\n        \n        return {\n          major: parseInt(match[1], 10),\n          minor: parseInt(match[2], 10),\n          patch: parseInt(match[3], 10),\n          prerelease: match[4]\n        };\n      } catch (error) {\n        console.error('Failed to parse version:', error);\n        throw error;\n      }\n    },\n\n    compare: (v1: string, v2: string): -1 | 0 | 1 => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.semver) {\n          return Bun.semver.compare(v1, v2);\n        }\n        \n        // Fallback comparison\n        const parsed1 = this.parse(v1);\n        const parsed2 = this.parse(v2);\n        \n        if (parsed1.major !== parsed2.major) {\n          return parsed1.major > parsed2.major ? 1 : -1;\n        }\n        \n        if (parsed1.minor !== parsed2.minor) {\n          return parsed1.minor > parsed2.minor ? 1 : -1;\n        }\n        \n        if (parsed1.patch !== parsed2.patch) {\n          return parsed1.patch > parsed2.patch ? 1 : -1;\n        }\n        \n        return 0;\n      } catch (error) {\n        console.error('Failed to compare versions:', error);\n        return 0;\n      }\n    },\n\n    satisfies: (version: string, range: string): boolean => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.semver) {\n          return Bun.semver.satisfies(version, range);\n        }\n        \n        // Very basic range satisfaction fallback\n        if (range === '*') return true;\n        if (range === version) return true;\n        \n        // Handle ^1.2.3 style ranges\n        if (range.startsWith('^')) {\n          const rangeVersion = range.substring(1);\n          const parsed = this.parse(rangeVersion);\n          const parsedVersion = this.parse(version);\n          \n          return parsedVersion.major === parsed.major &&\n                 (parsedVersion.major > 0 || parsedVersion.minor >= parsed.minor);\n        }\n        \n        return false;\n      } catch (error) {\n        console.error('Failed to check version satisfaction:', error);\n        return false;\n      }\n    }\n  };\n\n  return {\n    jsonVariants,\n    configFormats,\n    objectComparison,\n    versionManagement\n  };\n}\n\n// Utility function to detect file format\nexport function detectFileFormat(content: string, filename?: string): 'json' | 'json5' | 'jsonc' | 'jsonl' | 'yaml' | 'toml' | 'unknown' {\n  // Check file extension first\n  if (filename) {\n    const ext = filename.toLowerCase().split('.').pop();\n    switch (ext) {\n      case 'json': return 'json';\n      case 'json5': return 'json5';\n      case 'jsonc': return 'jsonc';\n      case 'jsonl': return 'jsonl';\n      case 'yaml':\n      case 'yml': return 'yaml';\n      case 'toml': return 'toml';\n    }\n  }\n  \n  // Analyze content\n  const trimmed = content.trim();\n  \n  // JSONL: multiple lines, each valid JSON\n  if (trimmed.split('\\n').every(line => {\n    try {\n      JSON.parse(line);\n      return true;\n    } catch {\n      return false;\n    }\n  })) {\n    return 'jsonl';\n  }\n  \n  // YAML: starts with key: value pattern, no braces\n  if (/^[a-zA-Z_][a-zA-Z0-9_]*\\s*:/m.test(trimmed) && !trimmed.startsWith('{')) {\n    return 'yaml';\n  }\n  \n  // TOML: key = value pattern\n  if (/^[a-zA-Z_][a-zA-Z0-9_]*\\s*=/m.test(trimmed)) {\n    return 'toml';\n  }\n  \n  // JSON5/JSONC: contains comments\n  if (/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*$/m.test(trimmed)) {\n    return 'jsonc';\n  }\n  \n  // JSON: try parsing as regular JSON\n  try {\n    JSON.parse(trimmed);\n    return 'json';\n  } catch {\n    return 'unknown';\n  }\n}
