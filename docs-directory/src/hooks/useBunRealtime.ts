import { useState, useEffect, useRef } from 'react';\n\ninterface BunRealtimeFeatures {\n  eventSource: {\n    connect: (url: string) => EventSource | null;\n    disconnect: (eventSource: EventSource) => void;\n    isConnected: boolean;\n    lastMessage: any;\n  };\n  webSocket: {\n    connect: (url: string) => WebSocket | null;\n    disconnect: (webSocket: WebSocket) => void;\n    send: (webSocket: WebSocket, data: any) => boolean;\n    isConnected: boolean;\n    lastMessage: any;\n  };\n  server: {\n    start: (port: number, handler: (req: Request) => Response) => Promise<void>;\n    stop: () => Promise<void>;\n    isRunning: boolean;\n    port: number | null;\n  };\n}\n\nexport function useBunRealtime(): BunRealtimeFeatures {\n  const [isConnected, setIsConnected] = useState(false);\n  const [lastMessage, setLastMessage] = useState<any>(null);\n  const [serverRunning, setServerRunning] = useState(false);\n  const [serverPort, setServerPort] = useState<number | null>(null);\n  \n  const eventSourceRef = useRef<EventSource | null>(null);\n  const webSocketRef = useRef<WebSocket | null>(null);\n  const serverRef = useRef<any>(null);\n\n  // EventSource Implementation\n  const eventSource = {\n    connect: (url: string): EventSource | null => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.EventSource) {\n          const source = new Bun.EventSource(url);\n          \n          source.onopen = () => {\n            setIsConnected(true);\n            console.log('EventSource connected to:', url);\n          };\n          \n          source.onmessage = (event) => {\n            try {\n              const data = JSON.parse(event.data);\n              setLastMessage(data);\n            } catch {\n              setLastMessage(event.data);\n            }\n          };\n          \n          source.onerror = (error) => {\n            console.error('EventSource error:', error);\n            setIsConnected(false);\n          };\n          \n          eventSourceRef.current = source;\n          return source;\n        }\n        \n        // Fallback to browser EventSource\n        const source = new EventSource(url);\n        source.onopen = () => setIsConnected(true);\n        source.onmessage = (event) => {\n          try {\n            setLastMessage(JSON.parse(event.data));\n          } catch {\n            setLastMessage(event.data);\n          }\n        };\n        source.onerror = () => setIsConnected(false);\n        \n        eventSourceRef.current = source;\n        return source;\n      } catch (error) {\n        console.error('Failed to connect EventSource:', error);\n        return null;\n      }\n    },\n\n    disconnect: (eventSource: EventSource) => {\n      try {\n        eventSource.close();\n        if (eventSourceRef.current === eventSource) {\n          eventSourceRef.current = null;\n          setIsConnected(false);\n        }\n      } catch (error) {\n        console.error('Failed to disconnect EventSource:', error);\n      }\n    },\n\n    get isConnected(): boolean {\n      return isConnected && eventSourceRef.current?.readyState === EventSource.OPEN;\n    },\n\n    get lastMessage(): any {\n      return lastMessage;\n    }\n  };\n\n  // WebSocket Implementation\n  const webSocket = {\n    connect: (url: string): WebSocket | null => {\n      try {\n        let ws: WebSocket;\n        \n        if (typeof Bun !== 'undefined' && Bun.WebSocket) {\n          ws = new Bun.WebSocket(url);\n        } else {\n          ws = new WebSocket(url);\n        }\n        \n        ws.onopen = () => {\n          setIsConnected(true);\n          console.log('WebSocket connected to:', url);\n        };\n        \n        ws.onmessage = (event) => {\n          try {\n            const data = JSON.parse(event.data);\n            setLastMessage(data);\n          } catch {\n            setLastMessage(event.data);\n          }\n        };\n        \n        ws.onclose = () => {\n          setIsConnected(false);\n          console.log('WebSocket disconnected');\n        };\n        \n        ws.onerror = (error) => {\n          console.error('WebSocket error:', error);\n          setIsConnected(false);\n        };\n        \n        webSocketRef.current = ws;\n        return ws;\n      } catch (error) {\n        console.error('Failed to connect WebSocket:', error);\n        return null;\n      }\n    },\n\n    disconnect: (webSocket: WebSocket) => {\n      try {\n        webSocket.close();\n        if (webSocketRef.current === webSocket) {\n          webSocketRef.current = null;\n          setIsConnected(false);\n        }\n      } catch (error) {\n        console.error('Failed to disconnect WebSocket:', error);\n      }\n    },\n\n    send: (webSocket: WebSocket, data: any): boolean => {\n      try {\n        if (webSocket.readyState === WebSocket.OPEN) {\n          const message = typeof data === 'string' ? data : JSON.stringify(data);\n          webSocket.send(message);\n          return true;\n        }\n        return false;\n      } catch (error) {\n        console.error('Failed to send WebSocket message:', error);\n        return false;\n      }\n    },\n\n    get isConnected(): boolean {\n      return isConnected && webSocketRef.current?.readyState === WebSocket.OPEN;\n    },\n\n    get lastMessage(): any {\n      return lastMessage;\n    }\n  };\n\n  // HTTP Server Implementation\n  const server = {\n    start: async (port: number, handler: (req: Request) => Response): Promise<void> => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.serve) {\n          serverRef.current = Bun.serve({\n            port,\n            fetch: handler,\n            development: process.env.NODE_ENV === 'development'\n          });\n          \n          setServerRunning(true);\n          setServerPort(port);\n          console.log(`Bun server started on port ${port}`);\n        } else {\n          console.warn('Bun server not available in this environment');\n        }\n      } catch (error) {\n        console.error('Failed to start Bun server:', error);\n        setServerRunning(false);\n        setServerPort(null);\n      }\n    },\n\n    stop: async (): Promise<void> => {\n      try {\n        if (serverRef.current && typeof serverRef.current.stop === 'function') {\n          serverRef.current.stop();\n          serverRef.current = null;\n        }\n        \n        setServerRunning(false);\n        setServerPort(null);\n        console.log('Bun server stopped');\n      } catch (error) {\n        console.error('Failed to stop Bun server:', error);\n      }\n    },\n\n    get isRunning(): boolean {\n      return serverRunning;\n    },\n\n    get port(): number | null {\n      return serverPort;\n    }\n  };\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (eventSourceRef.current) {\n        eventSourceRef.current.close();\n      }\n      if (webSocketRef.current) {\n        webSocketRef.current.close();\n      }\n      if (serverRef.current) {\n        serverRef.current.stop();\n      }\n    };\n  }, []);\n\n  return {\n    eventSource,\n    webSocket,\n    server\n  };\n}\n\n// Utility function for SSE (Server-Sent Events)\nexport function createServerSentEvent(data: any, event?: string, id?: string): string {\n  const lines: string[] = [];\n  \n  if (event) {\n    lines.push(`event: ${event}`);\n  }\n  \n  if (id) {\n    lines.push(`id: ${id}`);\n  }\n  \n  const dataStr = typeof data === 'string' ? data : JSON.stringify(data);\n  lines.push(`data: ${dataStr}`);\n  \n  lines.push(''); // Empty line to end the event\n  \n  return lines.join('\\n');\n}\n\n// Utility function for WebSocket message formatting\nexport function createWebSocketMessage(type: string, data: any, id?: string): string {\n  const message: any = {\n    type,\n    data,\n    timestamp: Date.now()\n  };\n  \n  if (id) {\n    message.id = id;\n  }\n  \n  return JSON.stringify(message);\n}\n\n// React hook for real-time data synchronization\nexport function useRealtimeSync<T>(\n  url: string,\n  initialData: T,\n  options: {\n    method?: 'eventsource' | 'websocket';\n    reconnectInterval?: number;\n    maxRetries?: number;\n  } = {}\n) {\n  const [data, setData] = useState<T>(initialData);\n  const [isConnected, setIsConnected] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  \n  const { eventSource, webSocket } = useBunRealtime();\n  const retryCount = useRef(0);\n  \n  const { method = 'eventsource', reconnectInterval = 3000, maxRetries = 5 } = options;\n  \n  const connect = () => {\n    try {\n      setError(null);\n      \n      if (method === 'websocket') {\n        const ws = webSocket.connect(url);\n        if (ws) {\n          ws.onmessage = (event) => {\n            try {\n              const message = JSON.parse(event.data);\n              if (message.type === 'sync') {\n                setData(message.data);\n              }\n            } catch (err) {\n              console.error('Failed to parse WebSocket message:', err);\n            }\n          };\n        }\n      } else {\n        const es = eventSource.connect(url);\n        if (es) {\n          es.onmessage = (event) => {\n            try {\n              const message = JSON.parse(event.data);\n              if (message.type === 'sync') {\n                setData(message.data);\n              }\n            } catch (err) {\n              console.error('Failed to parse EventSource message:', err);\n            }\n          };\n        }\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Connection failed'));\n      \n      // Auto-reconnect logic\n      if (retryCount.current < maxRetries) {\n        setTimeout(() => {\n          retryCount.current++;\n          connect();\n        }, reconnectInterval);\n      }\n    }\n  };\n  \n  useEffect(() => {\n    connect();\n    \n    return () => {\n      // Cleanup handled by useBunRealtime\n    };\n  }, [url, method]);\n  \n  return {\n    data,\n    isConnected: method === 'websocket' ? webSocket.isConnected : eventSource.isConnected,\n    error,\n    reconnect: connect\n  };\n}
