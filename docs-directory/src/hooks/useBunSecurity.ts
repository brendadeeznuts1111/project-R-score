import { useState, useEffect } from 'react';\n\ninterface BunSecurityFeatures {\n  csrfProtection: {\n    token: string;\n    validateToken: (token: string) => boolean;\n    generateToken: () => string;\n  };\n  passwordHashing: {\n    hash: (password: string, algorithm?: 'argon2' | 'bcrypt') => Promise<string>;\n    verify: (password: string, hash: string) => Promise<boolean>;\n  };\n  htmlEscaping: {\n    escape: (text: string) => string;\n    sanitize: (html: string) => string;\n  };\n  cryptographicHashing: {\n    md5: (data: string) => string;\n    sha1: (data: string) => string;\n    sha256: (data: string) => string;\n    sha512: (data: string) => string;\n  };\n}\n\nexport function useBunSecurity(): BunSecurityFeatures {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    setIsReady(true);\n  }, []);\n\n  // CSRF Protection\n  const csrfProtection = {\n    generateToken: (): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.CSRF) {\n          return Bun.CSRF();\n        }\n        \n        // Fallback token generation\n        const array = new Uint8Array(32);\n        crypto.getRandomValues(array);\n        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n      } catch (error) {\n        console.error('Failed to generate CSRF token:', error);\n        return Date.now().toString(36) + Math.random().toString(36);\n      }\n    },\n\n    validateToken: (token: string): boolean => {\n      try {\n        // In a real implementation, you'd validate against stored tokens\n        return token && token.length > 20;\n      } catch (error) {\n        console.error('Failed to validate CSRF token:', error);\n        return false;\n      }\n    },\n\n    get token(): string {\n      return this.generateToken();\n    }\n  };\n\n  // Password Hashing\n  const passwordHashing = {\n    hash: async (password: string, algorithm: 'argon2' | 'bcrypt' = 'argon2'): Promise<string> => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.password) {\n          if (algorithm === 'argon2') {\n            return await Bun.password.hash(password, {\n              algorithm: 'argon2id',\n              memoryLimit: 64,\n              timeLimit: 3,\n              threads: 2\n            });\n          } else {\n            return await Bun.password.hash(password, 'bcrypt');\n          }\n        }\n        \n        // Fallback using Web Crypto API\n        const encoder = new TextEncoder();\n        const data = encoder.encode(password + 'salt');\n        const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n      } catch (error) {\n        console.error('Failed to hash password:', error);\n        throw error;\n      }\n    },\n\n    verify: async (password: string, hash: string): Promise<boolean> => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.password) {\n          return await Bun.password.verify(password, hash);\n        }\n        \n        // Fallback verification\n        const hashedPassword = await this.hash(password);\n        return hashedPassword === hash;\n      } catch (error) {\n        console.error('Failed to verify password:', error);\n        return false;\n      }\n    }\n  };\n\n  // HTML Escaping\n  const htmlEscaping = {\n    escape: (text: string): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.escapeHTML) {\n          return Bun.escapeHTML(text);\n        }\n        \n        // Fallback HTML escaping\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n      } catch (error) {\n        console.error('Failed to escape HTML:', error);\n        return text;\n      }\n    },\n\n    sanitize: (html: string): string => {\n      try {\n        // Basic HTML sanitization\n        return html\n          .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n          .replace(/<iframe[^>]*>.*?<\\/iframe>/gi, '')\n          .replace(/<object[^>]*>.*?<\\/object>/gi, '')\n          .replace(/<embed[^>]*>.*?<\\/embed>/gi, '')\n          .replace(/javascript:/gi, '')\n          .replace(/on\\w+\\s*=/gi, '');\n      } catch (error) {\n        console.error('Failed to sanitize HTML:', error);\n        return html;\n      }\n    }\n  };\n\n  // Cryptographic Hashing\n  const cryptographicHashing = {\n    md5: (data: string): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.MD5) {\n          const encoder = new TextEncoder();\n          const encoded = encoder.encode(data);\n          const hash = new Bun.MD5().update(encoded).digest();\n          return Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n        \n        // Fallback MD5 (simplified)\n        return hashWithWebCrypto(data, 'SHA-256'); // Using SHA-256 as fallback\n      } catch (error) {\n        console.error('Failed to generate MD5 hash:', error);\n        return '';\n      }\n    },\n\n    sha1: (data: string): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.SHA1) {\n          const encoder = new TextEncoder();\n          const encoded = encoder.encode(data);\n          const hash = new Bun.SHA1().update(encoded).digest();\n          return Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n        \n        return hashWithWebCrypto(data, 'SHA-1');\n      } catch (error) {\n        console.error('Failed to generate SHA1 hash:', error);\n        return '';\n      }\n    },\n\n    sha256: (data: string): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.SHA256) {\n          const encoder = new TextEncoder();\n          const encoded = encoder.encode(data);\n          const hash = new Bun.SHA256().update(encoded).digest();\n          return Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n        \n        return hashWithWebCrypto(data, 'SHA-256');\n      } catch (error) {\n        console.error('Failed to generate SHA256 hash:', error);\n        return '';\n      }\n    },\n\n    sha512: (data: string): string => {\n      try {\n        if (typeof Bun !== 'undefined' && Bun.SHA512) {\n          const encoder = new TextEncoder();\n          const encoded = encoder.encode(data);\n          const hash = new Bun.SHA512().update(encoded).digest();\n          return Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n        \n        return hashWithWebCrypto(data, 'SHA-512');\n      } catch (error) {\n        console.error('Failed to generate SHA512 hash:', error);\n        return '';\n      }\n    }\n  };\n\n  // Helper function for Web Crypto API fallback\n  const hashWithWebCrypto = async (data: string, algorithm: string): Promise<string> => {\n    try {\n      const encoder = new TextEncoder();\n      const encoded = encoder.encode(data);\n      const hashBuffer = await crypto.subtle.digest(algorithm, encoded);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    } catch (error) {\n      console.error(`Failed to hash with ${algorithm}:`, error);\n      return '';\n    }\n  };\n\n  return {\n    csrfProtection,\n    passwordHashing,\n    htmlEscaping,\n    cryptographicHashing\n  };\n}\n\n// Utility function to generate secure random tokens\nexport function generateSecureToken(length: number = 32): string {\n  try {\n    if (typeof Bun !== 'undefined' && Bun.randomUUIDv7) {\n      return Bun.randomUUIDv7();\n    }\n    \n    const array = new Uint8Array(length);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  } catch (error) {\n    console.error('Failed to generate secure token:', error);\n    return Math.random().toString(36).substring(2, length + 2);\n  }\n}\n\n// Utility function for data integrity verification\nexport async function verifyDataIntegrity(data: string, expectedHash: string): Promise<boolean> {\n  try {\n    const { cryptographicHashing } = useBunSecurity();\n    const actualHash = cryptographicHashing.sha256(data);\n    return actualHash === expectedHash;\n  } catch (error) {\n    console.error('Failed to verify data integrity:', error);\n    return false;\n  }\n}
