import { useState, useEffect } from 'react';\n\ninterface BunMarkdownOptions {\n  headingIds?: boolean;\n  wikiLinks?: boolean;\n  latexMath?: boolean;\n  autolinkHeadings?: boolean;\n}\n\ninterface BunMarkdownRenderOptions {\n  heading?: (children: string, { level }: { level: number }) => string;\n  paragraph?: (children: string) => string;\n  strong?: (children: string) => string;\n  em?: (children: string) => string;\n  code?: (children: string) => string;\n  pre?: (children: string) => string;\n  blockquote?: (children: string) => string;\n  list?: (children: string, { ordered }: { ordered: boolean }) => string;\n  listItem?: (children: string) => string;\n  link?: (children: string, { href }: { href: string }) => string;\n  image?: (children: string, { src, alt }: { src: string; alt: string }) => string;\n  table?: (children: string) => string;\n  tableRow?: (children: string) => string;\n  tableCell?: (children: string, { header }: { header: boolean }) => string;\n  strikethrough?: (children: string) => string;\n  taskList?: (children: string, { checked }: { checked: boolean }) => string;\n  [key: string]: ((children: string, options?: any) => string) | undefined;\n}\n\ninterface BunMarkdownReactOptions {\n  components?: {\n    h1?: React.ComponentType<any>;\n    h2?: React.ComponentType<any>;\n    h3?: React.ComponentType<any>;\n    h4?: React.ComponentType<any>;\n    h5?: React.ComponentType<any>;\n    h6?: React.ComponentType<any>;\n    p?: React.ComponentType<any>;\n    strong?: React.ComponentType<any>;\n    em?: React.ComponentType<any>;\n    code?: React.ComponentType<any>;\n    pre?: React.ComponentType<any>;\n    blockquote?: React.ComponentType<any>;\n    ul?: React.ComponentType<any>;\n    ol?: React.ComponentType<any>;\n    li?: React.ComponentType<any>;\n    a?: React.ComponentType<any>;\n    img?: React.ComponentType<any>;\n    table?: React.ComponentType<any>;\n    thead?: React.ComponentType<any>;\n    tbody?: React.ComponentType<any>;\n    tr?: React.ComponentType<any>;\n    th?: React.ComponentType<any>;\n    td?: React.ComponentType<any>;\n    del?: React.ComponentType<any>;\n    input?: React.ComponentType<any>;\n  };\n  reactVersion?: 18 | 19;\n}\n\ninterface BunMarkdownResult {\n  html: string;\n  react: React.ReactElement | null;\n  custom: string | null;\n  metadata: {\n    headings: Array<{ level: number; text: string; id?: string }>;\n    links: Array<{ href: string; text: string }>;\n    images: Array<{ src: string; alt: string }>;\n    tables: number;\n    taskLists: number;\n  };\n}\n\nexport function useBunMarkdown() {\n  const [isReady, setIsReady] = useState(false);\n  const [version, setVersion] = useState<string>('1.3.8');\n\n  useEffect(() => {\n    // Check if Bun markdown API is available\n    if (typeof Bun !== 'undefined' && Bun.markdown) {\n      setIsReady(true);\n      // Get Bun version\n      if (Bun.version) {\n        setVersion(Bun.version);\n      }\n    } else {\n      // Fallback for non-Bun environments\n      setIsReady(true);\n    }\n  }, []);\n\n  const renderToHTML = (markdown: string, options: BunMarkdownOptions = {}): string => {\n    try {\n      if (typeof Bun !== 'undefined' && Bun.markdown && Bun.markdown.html) {\n        return Bun.markdown.html(markdown, options);\n      }\n      \n      // Fallback to basic markdown parsing (simplified)\n      return fallbackMarkdownToHTML(markdown);\n    } catch (error) {\n      console.error('Failed to render markdown to HTML:', error);\n      return `<div class=\"error\">Failed to render markdown: ${error}</div>`;\n    }\n  };\n\n  const renderWithCallbacks = (\n    markdown: string, \n    callbacks: BunMarkdownRenderOptions\n  ): string => {\n    try {\n      if (typeof Bun !== 'undefined' && Bun.markdown && Bun.markdown.render) {\n        return Bun.markdown.render(markdown, callbacks);\n      }\n      \n      // Fallback rendering\n      return fallbackCustomRender(markdown, callbacks);\n    } catch (error) {\n      console.error('Failed to render markdown with callbacks:', error);\n      return `<div class=\"error\">Failed to render markdown: ${error}</div>`;\n    }\n  };\n\n  const renderToReact = (\n    markdown: string, \n    options: BunMarkdownReactOptions = {}\n  ): React.ReactElement | null => {\n    try {\n      if (typeof Bun !== 'undefined' && Bun.markdown && Bun.markdown.react) {\n        return Bun.markdown.react(markdown, options);\n      }\n      \n      // Fallback to basic React rendering\n      return fallbackReactRender(markdown, options);\n    } catch (error) {\n      console.error('Failed to render markdown to React:', error);\n      return React.createElement('div', { className: 'error' }, `Failed to render markdown: ${error}`);\n    }\n  };\n\n  const renderToANSI = (markdown: string): string => {\n    const ansiCallbacks: BunMarkdownRenderOptions = {\n      heading: (children, { level }) => {\n        const colors = ['\\x1b[1;4m', '\\x1b[1;34m', '\\x1b[1;32m', '\\x1b[1;33m', '\\x1b[1;35m', '\\x1b[1;36m'];\n        return `${colors[level - 1] || colors[0]}${children}\\x1b[0m\\n`;\n      },\n      paragraph: (children) => `${children}\\n`,\n      strong: (children) => `\\x1b[1m${children}\\x1b[22m`,\n      em: (children) => `\\x1b[3m${children}\\x1b[23m`,\n      code: (children) => `\\x1b[36m${children}\\x1b[39m`,\n      pre: (children) => `\\x1b[90m${children}\\x1b[39m`,\n      blockquote: (children) => `\\x1b[90m│ ${children.replace(/\\n/g, '\\n│ ')}\\x1b[39m`,\n      link: (children, { href }) => `\\x1b[34m${children}\\x1b[39m (\\x1b[4m${href}\\x1b[24m)`,\n      strikethrough: (children) => `\\x1b[9m${children}\\x1b[29m`,\n      taskList: (children, { checked }) => `${checked ? '✓' : '○'} ${children}`,\n    };\n    \n    return renderWithCallbacks(markdown, ansiCallbacks);\n  };\n\n  const extractMetadata = (markdown: string): BunMarkdownResult['metadata'] => {\n    const metadata: BunMarkdownResult['metadata'] = {\n      headings: [],\n      links: [],\n      images: [],\n      tables: 0,\n      taskLists: 0\n    };\n    \n    // Extract headings\n    const headingRegex = /^(#{1,6})\\s+(.+)$/gm;\n    let match;\n    while ((match = headingRegex.exec(markdown)) !== null) {\n      metadata.headings.push({\n        level: match[1].length,\n        text: match[2].trim(),\n        id: match[2].trim().toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '')\n      });\n    }\n    \n    // Extract links\n    const linkRegex = /\\[([^\\]]+)\\]\\(([^)]+)\\)/g;\n    while ((match = linkRegex.exec(markdown)) !== null) {\n      metadata.links.push({\n        text: match[1],\n        href: match[2]\n      });\n    }\n    \n    // Extract images\n    const imageRegex = /!\\[([^\\]]*)\\]\\(([^)]+)\\)/g;\n    while ((match = imageRegex.exec(markdown)) !== null) {\n      metadata.images.push({\n        alt: match[1],\n        src: match[2]\n      });\n    }\n    \n    // Count tables\n    const tableRows = markdown.match(/^\\|.*\\|$/gm);\n    if (tableRows) {\n      metadata.tables = tableRows.length / 2; // Approximate\n    }\n    \n    // Count task lists\n    const taskItems = markdown.match(/^- \\[[ x]\\]/gm);\n    if (taskItems) {\n      metadata.taskLists = taskItems.length;\n    }\n    \n    return metadata;\n  };\n\n  const processMarkdown = (\n    markdown: string,\n    options: {\n      format?: 'html' | 'react' | 'ansi' | 'custom';\n      htmlOptions?: BunMarkdownOptions;\n      customCallbacks?: BunMarkdownRenderOptions;\n      reactOptions?: BunMarkdownReactOptions;\n    } = {}\n  ): BunMarkdownResult => {\n    const { format = 'html', htmlOptions, customCallbacks, reactOptions } = options;\n    \n    const metadata = extractMetadata(markdown);\n    let html = '';\n    let react: React.ReactElement | null = null;\n    let custom: string | null = null;\n    \n    switch (format) {\n      case 'html':\n        html = renderToHTML(markdown, htmlOptions);\n        break;\n      case 'react':\n        react = renderToReact(markdown, reactOptions);\n        html = renderToHTML(markdown, htmlOptions); // Also generate HTML for metadata\n        break;\n      case 'ansi':\n        custom = renderToANSI(markdown);\n        html = renderToHTML(markdown, htmlOptions);\n        break;\n      case 'custom':\n        if (customCallbacks) {\n          custom = renderWithCallbacks(markdown, customCallbacks);\n        }\n        html = renderToHTML(markdown, htmlOptions);\n        break;\n    }\n    \n    return {\n      html,\n      react,\n      custom,\n      metadata\n    };\n  };\n\n  return {\n    isReady,\n    version,\n    renderToHTML,\n    renderWithCallbacks,\n    renderToReact,\n    renderToANSI,\n    processMarkdown,\n    extractMetadata\n  };\n}\n\n// Fallback implementations for non-Bun environments\nfunction fallbackMarkdownToHTML(markdown: string): string {\n  return markdown\n    .replace(/^### (.*$)/gim, '<h3>$1</h3>')\n    .replace(/^## (.*$)/gim, '<h2>$1</h2>')\n    .replace(/^# (.*$)/gim, '<h1>$1</h1>')\n    .replace(/\\*\\*(.*)\\*\\*/gim, '<strong>$1</strong>')\n    .replace(/\\*(.*)\\*/gim, '<em>$1</em>')\n    .replace(/`([^`]*)`/gim, '<code>$1</code>')\n    .replace(/\\n/gim, '<br>');\n}\n\nfunction fallbackCustomRender(markdown: string, callbacks: BunMarkdownRenderOptions): string {\n  let result = markdown;\n  \n  // Apply callbacks in order\n  if (callbacks.heading) {\n    result = result.replace(/^#{1,6}\\s+(.+)$/gm, (match, text) => {\n      const level = match.match(/^#/)?.length || 1;\n      return callbacks.heading!(text, { level });\n    });\n  }\n  \n  if (callbacks.strong) {\n    result = result.replace(/\\*\\*(.+?)\\*\\*/g, (match, text) => callbacks.strong!(text));\n  }\n  \n  if (callbacks.paragraph) {\n    result = result.replace(/^([^\\n]+)$/gm, (match, text) => callbacks.paragraph!(text));\n  }\n  \n  return result;\n}\n\nfunction fallbackReactRender(markdown: string, options: BunMarkdownReactOptions): React.ReactElement {\n  const html = fallbackMarkdownToHTML(markdown);\n  return React.createElement('div', { \n    dangerouslySetInnerHTML: { __html: html } \n  });\n}\n\n// Utility function for GFM table parsing\nexport function parseGFMTable(markdown: string): {\n  headers: string[];\n  rows: string[][];\n  alignments: ('left' | 'center' | 'right')[];\n} | null {\n  const lines = markdown.split('\\n').filter(line => line.trim().startsWith('|'));\n  \n  if (lines.length < 2) return null;\n  \n  const headerLine = lines[0];\n  const separatorLine = lines[1];\n  const dataLines = lines.slice(2);\n  \n  const headers = headerLine.split('|').slice(1, -1).map(h => h.trim());\n  const alignments = separatorLine.split('|').slice(1, -1).map(a => {\n    const trimmed = a.trim();\n    if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n    if (trimmed.endsWith(':')) return 'right';\n    if (trimmed.startsWith(':')) return 'left';\n    return 'left';\n  });\n  \n  const rows = dataLines.map(line => \n    line.split('|').slice(1, -1).map(cell => cell.trim())\n  );\n  \n  return { headers, rows, alignments };\n}\n\n// Utility function for task list parsing\nexport function parseTaskList(markdown: string): Array<{ text: string; checked: boolean }> {\n  const taskRegex = /^- \\[([ x])\\]\\s+(.+)$/gm;\n  const tasks: Array<{ text: string; checked: boolean }> = [];\n  let match;\n  \n  while ((match = taskRegex.exec(markdown)) !== null) {\n    tasks.push({\n      text: match[2],\n      checked: match[1] === 'x'\n    });\n  }\n  \n  return tasks;\n}
