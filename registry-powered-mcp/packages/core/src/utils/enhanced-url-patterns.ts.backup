/**
 * Enhanced URL Pattern Utilities - v2.4.1
 * Advanced URL pattern matching, validation, and separation utilities
 *
 * Features:
 * - Multi-stage pattern matching with complexity analysis
 * - URL normalization and security validation
 * - Parameter extraction with validation
 * - Fast pre-filtering for performance
 * - URL condition analysis for routing decisions
 */

export interface URLPatternCache {
  pattern: URLPattern;
  normalizedPath: string;
  paramCount: number;
  hasOptionalParams: boolean;
  complexity: number;
  segmentCount: number;
  staticSegments: string[];
  dynamicSegments: string[];
}

export interface URLMatchResult {
  matched: boolean;
  params: Record<string, string>;
  confidence: number;
  patternComplexity: number;
}

export interface URLSecurityAnalysis {
  isValid: boolean;
  riskLevel: 'low' | 'medium' | 'high';
  violations: string[];
  recommendations: string[];
}

/**
 * Enhanced URL Pattern Utilities for high-performance routing
 */
export class EnhancedURLPatternUtils {
  private static patternCache = new Map<string, URLPatternCache>();
  private static readonly MAX_CACHE_SIZE = 1000; // Limit cache size to prevent memory leaks
  private static cacheHits = 0;
  private static cacheMisses = 0;

  /**
   * Advanced URL normalization with security considerations
   */
  static normalizeURL(url: string): string {
    try {
      // Handle relative URLs
      const urlObj = url.startsWith('http') ? new URL(url) : new URL(url, 'http://localhost');

      // Normalize pathname
      let pathname = urlObj.pathname
        .replace(/\/+/g, '/')           // Remove double slashes
        .replace(/\/$/, '')             // Remove trailing slash
        .replace(/^([^/])/, '/$1');     // Ensure leading slash

      urlObj.pathname = pathname;

      // Normalize search params (sort for consistency)
      const sortedParams = new URLSearchParams();
      for (const [key, value] of urlObj.searchParams) {
        sortedParams.set(key, value);
      }
      urlObj.search = sortedParams.toString();

      return urlObj.toString();
    } catch (error) {
      throw new Error(`Invalid URL format: ${url}`);
    }
  }

  /**
   * Enhanced pathname normalization with security checks
   */
  static normalizePathname(pathname: string, options: { security?: boolean } = {}): string {
    const { security = true } = options;

    // Basic normalization
    let normalized = pathname
      .replace(/\/+/g, '/')           // Remove double slashes
      .replace(/\/$/, '')             // Remove trailing slash
      .replace(/^([^/])/, '/$1');     // Ensure leading slash

    if (security) {
      // URL-decode the path for security validation
      let decodedPath;
      try {
        decodedPath = decodeURIComponent(normalized);
      } catch {
        // If decoding fails, treat as suspicious
        throw new Error('Invalid URL encoding');
      }

      // Check length limits (on decoded path to prevent encoding bypass)
      if (decodedPath.length > 2048) {
        throw new Error('Path too long');
      }

      // Prevent common attack vectors (on decoded path)
      const blockedPatterns = [
        /\.\./,           // Path traversal
        /\\/,             // Backslashes
        /[<>'"]/,         // XSS characters
        /javascript:/i,   // JavaScript protocol
        /data:/i,         // Data protocol
        /\0/,             // Null bytes
        /[\x00-\x1F\x7F]/, // Control characters
      ];

      for (const pattern of blockedPatterns) {
        if (pattern.test(decodedPath)) {
          if (pattern.source === '\\0' || pattern.source === '[\\x00-\\x1F\\x7F]') {
            throw new Error('Control characters detected');
          }
          throw new Error(`Security violation: ${pattern.source}`);
        }
      }

      // Allow URL pattern syntax (:param, ?, *, (), []) but prevent dangerous characters
      if (!/^\/[a-zA-Z0-9._~!$&'()*+,;=:@\/\?\*\[\]\(\)\-%]*$/.test(normalized)) {
        throw new Error('Invalid characters in path');
      }
    }

    return normalized;
  }

  /**
   * Extract URL segments with classification
   */
  static analyzePathSegments(pathname: string): {
    segments: string[];
    staticSegments: string[];
    dynamicSegments: string[];
    paramSegments: string[];
    wildcardSegments: string[];
  } {
    const segments = this.normalizePathname(pathname).split('/').filter(Boolean);
    const staticSegments: string[] = [];
    const dynamicSegments: string[] = [];
    const paramSegments: string[] = [];
    const wildcardSegments: string[] = [];

    for (const segment of segments) {
      if (segment.startsWith(':')) {
        dynamicSegments.push(segment);
        paramSegments.push(segment);
      } else if (segment === '*') {
        dynamicSegments.push(segment);
        wildcardSegments.push(segment);
      } else {
        staticSegments.push(segment);
      }
    }

    return {
      segments,
      staticSegments,
      dynamicSegments,
      paramSegments,
      wildcardSegments,
    };
  }

  /**
   * Advanced pattern complexity analysis
   */
  static analyzePatternComplexity(pattern: string): number {
    let complexity = 0;

    // Base pattern length
    complexity += pattern.length;

    // Named parameters (highest complexity)
    const namedParams = (pattern.match(/:\w+/g) || []).length;
    complexity += namedParams * 15;

    // Optional parameters
    const optionalParams = (pattern.match(/:\w+\?/g) || []).length;
    complexity += optionalParams * 5;

    // Wildcards
    const wildcards = (pattern.match(/\*/g) || []).length;
    complexity += wildcards * 8;

    // Groups (regex patterns)
    const groups = (pattern.match(/\([^)]+\)/g) || []).length;
    complexity += groups * 12;

    // Character classes
    const charClasses = (pattern.match(/\[[^\]]+\]/g) || []).length;
    complexity += charClasses * 6;

    // Query parameters in pattern
    if (pattern.includes('?')) {
      complexity += 10;
    }

    return complexity;
  }

  /**
   * Create enhanced pattern cache entry with advanced URLPattern configuration
   */
  static createPatternCache(pattern: string): URLPatternCache {
    // Don't normalize patterns - they need to retain their syntax
    const normalizedPath = pattern;
    const analysis = this.analyzePathSegments(pattern);
    const paramCount = analysis.paramSegments.length;
    const hasOptionalParams = pattern.includes('?');
    const complexity = this.analyzePatternComplexity(pattern);

    // Advanced URLPattern configuration
    const patternConfig: URLPatternInit = {
      pathname: normalizedPath,
    };

    // Add additional pattern components if present in the original pattern
    // Only split on ? or # if they're not part of parameter syntax
    const queryIndex = pattern.indexOf('?');
    if (queryIndex > 0 && !pattern.slice(0, queryIndex).includes(':')) {
      // Handle query parameter patterns (only if ? is not in a parameter)
      const queryPattern = pattern.slice(queryIndex + 1);
      if (queryPattern) {
        patternConfig.search = queryPattern;
      }
    }

    const hashIndex = pattern.indexOf('#');
    if (hashIndex > 0 && !pattern.slice(0, hashIndex).includes(':')) {
      // Handle hash patterns (only if # is not in a parameter)
      const hashPattern = pattern.slice(hashIndex + 1);
      if (hashPattern) {
        patternConfig.hash = hashPattern;
      }
    }

    // Extract protocol, username, password, hostname, port if specified
    const urlMatch = pattern.match(/^(\w+:\/\/)?(?:(\w+)(?::(\w+))?@)?([^\s:/?#]+)(?::(\d+))?/);
    if (urlMatch) {
      const [, protocol, username, password, hostname, port] = urlMatch;
      if (protocol) patternConfig.protocol = protocol.replace('://', '');
      if (username) patternConfig.username = username;
      if (password) patternConfig.password = password;
      if (hostname) patternConfig.hostname = hostname;
      if (port) patternConfig.port = port;
    }

    return {
      pattern: new URLPattern(patternConfig),
      normalizedPath,
      paramCount,
      hasOptionalParams,
      complexity,
      segmentCount: analysis.segments.length,
      staticSegments: analysis.staticSegments,
      dynamicSegments: analysis.dynamicSegments,
    };
  }

  /**
   * Get or create cached pattern analysis
   */
  static getCachedPattern(pattern: string): URLPatternCache {
    if (this.patternCache.has(pattern)) {
      this.cacheHits++;
      return this.patternCache.get(pattern)!;
    }

    // Check cache size limit and evict oldest entries if needed
    if (this.patternCache.size >= this.MAX_CACHE_SIZE) {
      // Simple LRU: remove the first entry (oldest)
      const firstKey = this.patternCache.keys().next().value;
      if (firstKey) {
        this.patternCache.delete(firstKey);
      }
    }

    this.cacheMisses++;
    const cache = this.createPatternCache(pattern);
    this.patternCache.set(pattern, cache);
    return cache;
  }

  /**
   * Get cache performance statistics
   */
  static getCacheStats() {
    const totalRequests = this.cacheHits + this.cacheMisses;
    const hitRate = totalRequests > 0 ? (this.cacheHits / totalRequests) * 100 : 0;

    return {
      cacheSize: this.patternCache.size,
      maxCacheSize: this.MAX_CACHE_SIZE,
      cacheHits: this.cacheHits,
      cacheMisses: this.cacheMisses,
      hitRate: Math.round(hitRate * 100) / 100,
      utilizationPercent: Math.round((this.patternCache.size / this.MAX_CACHE_SIZE) * 100)
    };
  }
  }

  // Note: matchWithConfidence method temporarily disabled due to syntax issues
  // Routing optimization implemented directly in lattice.ts for performance

  /**
   * Fast pre-filtering with confidence scoring
   */
  private static quickPreFilter(pathname: string, cache: URLPatternCache): { passed: boolean; confidence: number } {
    const pathAnalysis = this.analyzePathSegments(pathname);
    let confidence = 1.0;

    // Segment count validation
    if (pathAnalysis.segments.length < cache.segmentCount) {
      if (!cache.hasOptionalParams) {
        return { passed: false, confidence: 0 };
      }
      confidence *= 0.8; // Reduce confidence for missing segments
    }

    // Static segment matching
    let staticMatches = 0;
    for (let i = 0; i < Math.min(pathAnalysis.segments.length, cache.segmentCount); i++) {
      const pathSeg = pathAnalysis.segments[i];
      const patternSeg = cache.normalizedPath.split('/').filter(Boolean)[i];

      if (!patternSeg) continue;

      if (patternSeg.startsWith(':') || patternSeg === '*') {
        continue; // Skip dynamic segments
      }

      if (pathSeg === patternSeg) {
        staticMatches++;
      } else {
        return { passed: false, confidence: 0 }; // Static mismatch
      }
    }

    // Boost confidence for static matches
    if (cache.staticSegments.length > 0) {
      confidence *= (staticMatches / cache.staticSegments.length);
    }

    return { passed: true, confidence };
  }

  /**
   * Extract and validate parameters from all URLPattern components
   */
  private static extractValidatedParameters(result: URLPatternResult, pattern: string): Record<string, string> {
    const params: Record<string, string> = {};

    // Extract pathname parameters
    if (result.pathname.groups) {
      Object.assign(params, result.pathname.groups);
    }

    // Extract search parameters
    if (result.search.groups) {
      // Prefix search params to avoid conflicts with pathname params
      Object.entries(result.search.groups).forEach(([key, value]) => {
        params[`search_${key}`] = value || '';
      });
    }

    // Extract hash parameters
    if (result.hash.groups) {
      Object.entries(result.hash.groups).forEach(([key, value]) => {
        params[`hash_${key}`] = value || '';
      });
    }

    // Extract protocol, hostname, port parameters if matched
    if (result.protocol.groups) {
      Object.entries(result.protocol.groups).forEach(([key, value]) => {
        params[`protocol_${key}`] = value || '';
      });
    }

    if (result.hostname.groups) {
      Object.entries(result.hostname.groups).forEach(([key, value]) => {
        params[`host_${key}`] = value || '';
      });
    }

    if (result.port.groups) {
      Object.entries(result.port.groups).forEach(([key, value]) => {
        params[`port_${key}`] = value || '';
      });
    }

    if (result.username.groups) {
      Object.entries(result.username.groups).forEach(([key, value]) => {
        params[`user_${key}`] = value || '';
      });
    }

    if (result.password.groups) {
      Object.entries(result.password.groups).forEach(([key, value]) => {
        params[`pass_${key}`] = value || '';
      });
    }

    // Validate required parameters
    const allParams = (pattern.match(/:(\w+)/g) || []).map(match => match.substring(1));
    const requiredParams = allParams.filter(param => !pattern.includes(`:${param}?`));

    for (const required of requiredParams) {
      if (!params[required] || params[required] === '') {
        throw new Error(`Missing required parameter: ${required}`);
      }
    }

    return params;
  }

  /**
   * Calculate match confidence score
   */
  private static calculateMatchConfidence(pathname: string, cache: URLPatternCache, params: Record<string, string>): number {
    let confidence = 1.0;

    // Parameter completeness
    const paramCompleteness = Object.keys(params).length / Math.max(1, cache.paramCount);
    confidence *= Math.min(1.0, paramCompleteness);

    // Path segment matching
    const pathSegments = this.analyzePathSegments(pathname);
    const segmentMatchRatio = Math.min(pathSegments.segments.length, cache.segmentCount) /
                             Math.max(pathSegments.segments.length, cache.segmentCount);
    confidence *= segmentMatchRatio;

    // Complexity factor (simpler patterns are more reliable)
    const complexityFactor = Math.max(0.5, 1.0 - (cache.complexity / 100));
    confidence *= complexityFactor;

    return Math.max(0, Math.min(1, confidence));
  }

  /**
   * URL security analysis
   */
  static analyzeSecurity(pathname: string): URLSecurityAnalysis {
    const violations: string[] = [];
    const recommendations: string[] = [];

    // Path traversal checks
    if (pathname.includes('..')) {
      violations.push('Path traversal attempt detected');
      recommendations.push('Block requests with ".." in path');
    }

    // Null byte attacks
    if (pathname.includes('\0')) {
      violations.push('Null byte injection detected');
      recommendations.push('Filter null bytes from input');
    }

    // XSS attempts
    if (/<script|javascript:|data:/i.test(pathname)) {
      violations.push('Potential XSS attempt detected');
      recommendations.push('Sanitize and validate all user input');
    }

    // Extremely long paths
    if (pathname.length > 2048) {
      violations.push('Path length exceeds safety threshold');
      recommendations.push('Implement path length limits');
    }

    // Control characters
    if (/[\x00-\x1F\x7F]/.test(pathname)) {
      violations.push('Control characters detected');
      recommendations.push('Strip control characters from paths');
    }

    // Determine risk level
    let riskLevel: 'low' | 'medium' | 'high' = 'low';
    if (violations.length >= 3) {
      riskLevel = 'high';
    } else if (violations.length >= 1) {
      riskLevel = 'medium';
    }

    return {
      isValid: violations.length === 0,
      riskLevel,
      violations,
      recommendations,
    };
  }

  /**
   * URL condition evaluation for routing decisions
   */
  static evaluateConditions(pathname: string, conditions: {
    allowedPrefixes?: string[];
    blockedPatterns?: RegExp[];
    requiredParams?: string[];
    maxLength?: number;
  }): boolean {
    // Length check
    if (conditions.maxLength && pathname.length > conditions.maxLength) {
      return false;
    }

    // Prefix checks
    if (conditions.allowedPrefixes) {
      const hasValidPrefix = conditions.allowedPrefixes.some(prefix =>
        pathname.startsWith(prefix)
      );
      if (!hasValidPrefix) {
        return false;
      }
    }

    // Blocked pattern checks
    if (conditions.blockedPatterns) {
      for (const pattern of conditions.blockedPatterns) {
        if (pattern.test(pathname)) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Generate URL pattern suggestions for optimization
   */
  static suggestOptimizations(patterns: string[]): {
    suggestions: string[];
    performance: Record<string, number>;
  } {
    const suggestions: string[] = [];
    const performance: Record<string, number> = {};

    for (const pattern of patterns) {
      const cache = this.getCachedPattern(pattern);
      performance[pattern] = cache.complexity;

      // Suggest optimizations
      if (cache.complexity > 50) {
        suggestions.push(`High complexity pattern "${pattern}" (${cache.complexity}) - consider simplifying`);
      }

      if (cache.hasOptionalParams && cache.paramCount > 3) {
        suggestions.push(`Pattern "${pattern}" has many optional parameters - consider separate routes`);
      }

      if (cache.staticSegments.length === 0) {
        suggestions.push(`Pattern "${pattern}" has no static segments - may cause routing conflicts`);
      }
    }

    return { suggestions, performance };
  }

  /**
   * Get cache performance statistics
   */
  static getCacheStats() {
    const totalRequests = this.cacheHits + this.cacheMisses;
    const hitRate = totalRequests > 0 ? (this.cacheHits / totalRequests) * 100 : 0;

    return {
      cacheSize: this.patternCache.size,
      maxCacheSize: this.MAX_CACHE_SIZE,
      cacheHits: this.cacheHits,
      cacheMisses: this.cacheMisses,
      hitRate: Math.round(hitRate * 100) / 100,
      utilizationPercent: Math.round((this.patternCache.size / this.MAX_CACHE_SIZE) * 100)
    };
  }
}