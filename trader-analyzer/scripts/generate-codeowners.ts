#!/usr/bin/env bun
/**
 * [CODEOWNERS.GENERATOR.RG:IMPLEMENTATION] CODEOWNERS File Generator
 * @fileoverview Generate .github/CODEOWNERS from TEAM.md RG markers
 * @description Parses TEAM.md to extract department leads and maintainers, then generates CODEOWNERS file
 * @module scripts/generate-codeowners
 *
 * [[TECH][MODULE][INSTANCE][META:{blueprint=BP-CODEOWNERS-GENERATOR@2.0.0;instance-id=CODEOWNERS-GENERATOR-001;version=2.0.0}]
 * [PROPERTIES:{script={value:"generate-codeowners";@root:"24.3.1.0.0.0.0";@chain:["BP-HUMAN-CAPITAL","BP-CI-CD"];@version:"2.0.0"}}]
 * [CLASS:CodeownersGenerator][#REF:v-2.0.0.BP.CODEOwners.GENERATOR.1.0.A.1.1.SCRIPT.1.1]]
 *
 * @see {@link .github/TEAM.md} - Team structure source
 * @see {@link .github/CODEOWNERS} - Generated CODEOWNERS file
 * @see {@link docs/24.0.0.0.0.0.0-HUMAN-CAPITAL-ORCHESTRATION.md} - Subsystem documentation
 */

import { readFile, writeFile } from 'fs/promises';
import { join } from 'path';

// [CODEOWNERS.PARSING.RG:IMPLEMENTATION] Parse TEAM.md for department ownership
/**
 * Extract department ownership from TEAM.md
 */
async function extractDepartmentOwnership(): Promise<Array<{
	department: string;
	lead: string;
	maintainers: string[];
	paths: string[];
}>> {
	const teamMDPath = join(process.cwd(), '.github', 'TEAM.md');
	const content = await readFile(teamMDPath, 'utf-8');
	const lines = content.split('\n');

	const departments: Array<{
		department: string;
		lead: string;
		maintainers: string[];
		paths: string[];
	}> = [];

	let currentDept: {
		department: string;
		lead: string;
		maintainers: string[];
		paths: string[];
	} | null = null;

	// [CODEOWNERS.PARSING.DEPARTMENT.RG:IMPLEMENTATION] Parse department sections
	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];

		// Detect department marker
		const deptMatch = line.match(/\[TEAM\.DEPARTMENT\.([A-Z.]+)\.RG\]/);
		if (deptMatch) {
			// Save previous department
			if (currentDept) {
				departments.push(currentDept);
			}

			const marker = deptMatch[1];
			currentDept = {
				department: marker.replace(/\./g, '_'),
				lead: '',
				maintainers: [],
				paths: [],
			};
			continue;
		}

		// Extract Lead
		if (currentDept && line.match(/^\*\*Lead\*\*:/)) {
			const leadMatch = line.match(/\*\*Lead\*\*:\s*(.+)/);
			if (leadMatch) {
				currentDept.lead = leadMatch[1].trim();
			}
			continue;
		}

		// Extract Key Areas (paths)
		if (currentDept && line.includes('**Key Areas**:')) {
			// Read next lines until empty line or next section
			for (let j = i + 1; j < lines.length; j++) {
				const keyLine = lines[j];
				if (keyLine.trim() === '' || keyLine.startsWith('**')) {
					break;
				}
				
				// Extract paths from backticks
				const pathMatches = keyLine.match(/`([^`]+)`/g);
				if (pathMatches) {
					pathMatches.forEach((match) => {
						const path = match.replace(/`/g, '').trim();
						if (path && !path.includes('://') && !path.startsWith('#')) {
							currentDept!.paths.push(path);
						}
					});
				}
			}
		}
	}

	// Add last department
	if (currentDept) {
		departments.push(currentDept);
	}

	return departments;
}

// [CODEOWNERS.GENERATION.RG:IMPLEMENTATION] Generate CODEOWNERS content
/**
 * Generate CODEOWNERS file content
 */
async function generateCodeowners(): Promise<string> {
	const departments = await extractDepartmentOwnership();
	
	const lines: string[] = [
		'# CODEOWNERS file generated from .github/TEAM.md',
		'# Auto-generated by scripts/generate-codeowners.ts',
		'# DO NOT EDIT MANUALLY - Regenerate with: bun run scripts/generate-codeowners.ts',
		'',
		'# [CODEOWNERS.GENERATED.RG:CONFIG] Generated CODEOWNERS',
		'',
	];

	// [CODEOWNERS.GENERATION.PATHS.RG:IMPLEMENTATION] Generate path-based ownership
	for (const dept of departments) {
		if (dept.paths.length === 0 || !dept.lead) {
			continue;
		}

		// Add comment with RG marker reference
		const deptName = dept.department.replace(/_/g, ' ').toUpperCase();
		lines.push(`# ${deptName} Department`);
		lines.push(`# RG Marker: [TEAM.DEPARTMENT.${dept.department}.RG]`);
		
		// Normalize paths and add ownership
		const normalizedPaths = new Set<string>();
		for (const path of dept.paths) {
			// Normalize: remove leading ./ and ensure proper format
			let normalized = path.replace(/^\.\//, '').trim();
			// If it's a directory path, ensure it ends with /*
			if (normalized.includes('/') && !normalized.includes('.')) {
				normalized = normalized.endsWith('/') ? `${normalized}*` : `${normalized}/*`;
			}
			normalizedPaths.add(normalized);
		}
		
		// Build owner list
		const owners = [dept.lead, ...dept.maintainers].filter(Boolean);
		const ownerList = owners.map(o => `@${o}`).join(' ');
		
		// Add ownership for each normalized path
		for (const path of Array.from(normalizedPaths).sort()) {
			lines.push(`${path} ${ownerList}`);
		}
		
		lines.push('');
	}

	// Add fallback maintainers
	lines.push('# Fallback: All maintainers');
	lines.push('* @maintainers');
	lines.push('');

	return lines.join('\n');
}

// [CODEOWNERS.MAIN.RG:IMPLEMENTATION] Main execution
/**
 * Generate CODEOWNERS file
 */
async function main() {
	try {
		const codeownersContent = await generateCodeowners();
		const codeownersPath = join(process.cwd(), '.github', 'CODEOWNERS');
		
		await writeFile(codeownersPath, codeownersContent, 'utf-8');
		
		console.log('✅ Generated .github/CODEOWNERS');
		console.log(`   ${codeownersContent.split('\n').length} lines`);
	} catch (error: any) {
		console.error('❌ Error generating CODEOWNERS:', error.message);
		process.exit(1);
	}
}

if (import.meta.main) {
	main();
}
