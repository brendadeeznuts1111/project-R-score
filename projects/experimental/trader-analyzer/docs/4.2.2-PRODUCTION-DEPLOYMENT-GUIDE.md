# Production Deployment Guide: Multi-Layer Correlation Graph

**Version**: 4.2.2.18.0.0.0  
**Component**: Multi-Layer Correlation Graph  
**Status**: Ready for Staging Deployment  
**Last Updated**: 2025-12-07

---

## 4.2.2.18.1.0.0: Pre-Deployment Checklist

### ✅ Critical Items (All Complete)

- [x] Rate limiting: 1000 tokens/sec (4.2.2.14.1.0.0)
- [x] Memory ceiling: 4GB monitoring with GC (4.2.2.14.2.0.0)
- [x] Query timeout: 50ms max (4.2.2.14.3.0.0)
- [x] Sub-5ms latency on critical paths
- [x] Error handling returns null (no uncaught exceptions)
- [x] SQL syntax validated
- [x] Circuit breaker pattern implemented
- [x] Basic audit logging

### ✅ Important Items (All Complete)

- [x] Prometheus metrics endpoint (4.2.2.15.0.0.0)
- [x] Distributed tracing (4.2.2.16.0.0.0)
- [x] Snapshot rotation script (4.2.2.17.0.0.0)
- [x] Worker threads optimization (4.2.2.11.0.0.0)
- [x] SIMD optimization (4.2.2.12.0.0.0)
- [x] Materialized view (4.2.2.8.0.0.0)
- [x] Memory leak fix (4.2.2.10.0.0.0)

---

## 4.2.2.18.2.0.0: Integration Steps

### 4.2.2.18.2.1.0.0: Step 1 - Integrate Prometheus Metrics Endpoint

**Location**: Add to your HTTP server/router

```typescript
// src/api/server.ts or your main server file
import { prometheusMetricsHandler } from './metrics/prometheus';
import { DoDMultiLayerCorrelationGraph } from '../analytics/correlation-engine';

// Initialize engine
const engine = new DoDMultiLayerCorrelationGraph(db);

// Add metrics endpoint
server.get('/metrics', (req) => {
  return prometheusMetricsHandler(engine);
});
```

**Verification**:
```bash
curl http://localhost:3000/metrics
# Should return Prometheus-formatted metrics
```

---

### 4.2.2.18.2.2.0.0: Step 2 - Add Distributed Tracing to API Calls

**Location**: Wrap API handlers with trace context

```typescript
// src/api/dashboard-correlation-graph.ts
import { 
  createTraceContext, 
  extractTraceContext, 
  injectTraceContext,
  withTraceContext 
} from '../utils/tracing';

export async function getCorrelationGraph(
  req: Request,
  engine: DoDMultiLayerCorrelationGraph
): Promise<Response> {
  // Extract trace context from incoming request
  const parentContext = extractTraceContext(req.headers);
  const traceContext = createTraceContext(parentContext);
  
  // Run operation with trace context
  const graph = await withTraceContext(traceContext, async () => {
    return await engine.buildMultiLayerGraph(eventId);
  });
  
  // Inject trace context into response headers
  const responseHeaders = injectTraceContext(traceContext);
  
  return new Response(JSON.stringify(graph), {
    headers: {
      ...Object.fromEntries(responseHeaders),
      'Content-Type': 'application/json',
    },
  });
}
```

**Verification**:
```bash
curl -H "traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01" \
  http://localhost:3000/api/correlation-graph
# Response should include traceparent header
```

---

### 4.2.2.18.2.3.0.0: Step 3 - Set Up Snapshot Rotation (Cron/Systemd)

**Option A: Cron Job** (Linux/macOS)

```bash
# Add to crontab: crontab -e
# Daily snapshot rotation at 2 AM
0 2 * * * cd /path/to/trader-analyzer && bun run snapshot:rotate >> /var/log/snapshot-rotation.log 2>&1
```

**Option B: Systemd Timer** (Linux)

Create `/etc/systemd/system/correlation-snapshot.service`:
```ini
[Unit]
Description=Correlation Graph Snapshot Rotation
After=network.target

[Service]
Type=oneshot
User=your-user
WorkingDirectory=/path/to/trader-analyzer
ExecStart=/usr/bin/bun run snapshot:rotate
```

Create `/etc/systemd/system/correlation-snapshot.timer`:
```ini
[Unit]
Description=Daily Correlation Graph Snapshot Rotation
Requires=correlation-snapshot.service

[Timer]
OnCalendar=daily
OnCalendar=02:00
Persistent=true

[Install]
WantedBy=timers.target
```

Enable:
```bash
sudo systemctl enable correlation-snapshot.timer
sudo systemctl start correlation-snapshot.timer
```

**Verification**:
```bash
# Test manually
bun run snapshot:rotate

# Check snapshots directory
ls -lh snapshots/
```

---

### 4.2.2.18.2.4.0.0: Step 4 - Initialize Production Readiness Matrix

**Run initialization script**:
```bash
bun run init:readiness
```

**Expected output**:
```text
✅ rate_limiting (CRITICAL): PASS
✅ memory_ceiling (CRITICAL): PASS
✅ query_timeout (CRITICAL): PASS
...

=== Production Readiness Summary ===
Total Checks: 20
Passed: 20
Blockers: 0
Compliance: 100.0%

✅ Status: READY FOR PRODUCTION
```

---

## 4.2.2.18.3.0.0: Testing Procedures

### 4.2.2.18.3.1.0.0: Load Testing

**Test rate limiting**:
```bash
# Should allow 1000 requests/sec, reject after
for i in {1..1100}; do
  curl -s http://localhost:3000/api/correlation-graph?eventId=NBA-20250101-0001 &
done
wait
# Check logs for rate limit rejections
```

**Test memory ceiling**:
```typescript
// In test file
import { DoDMultiLayerCorrelationGraph } from '../src/analytics/correlation-engine';

// Simulate high memory usage
const engine = new DoDMultiLayerCorrelationGraph(db);
// Force memory usage above 4GB (if possible in test environment)
// Verify requests are rejected with MEMORY_LIMIT_EXCEEDED
```

**Test query timeout**:
```typescript
// Create a slow query scenario
// Verify warnings are logged for queries > 50ms
```

---

### 4.2.2.18.3.2.0.0: Chaos Engineering Tests

**Test layer degradation**:
```bash
# Kill Layer 4
bun run chaos:kill-layer4 --duration=30s

# Monitor: Should degrade to L1-L3 only, zero downtime
# Verify: Health status shows DEGRADED but not FAILED
```

**Test all layers**:
```bash
bun run chaos:all

# Verify: System continues operating with graceful degradation
```

---

### 4.2.2.18.3.3.0.0: Performance Benchmarks

**Run benchmark suite**:
```bash
bun run bench correlation-engine

# Expected results:
# - Layer 1: ~48 µs
# - Layers 2-4: ~676-690 µs
# - Graph Assembly: ~2.20 ms (or ~0.8 ms with workers)
# - Anomaly Detection: ~3.91-4.76 ms
# - Propagation Prediction: ~365 µs
```

**Cold-cache test**:
```bash
# Verify O(n) scaling with depth
bun run bench correlation-engine --cold-cache

# Should show linear scaling, not constant time
```

---

## 4.2.2.18.4.0.0: Monitoring Setup

### 4.2.2.18.4.1.0.0: Grafana Dashboard Configuration

**Prometheus Scrape Config** (`prometheus.yml`):
```yaml
scrape_configs:
  - job_name: 'correlation-engine'
    scrape_interval: 15s
    static_configs:
      - targets: ['localhost:3000']
    metrics_path: '/metrics'
```

**Grafana Dashboard Queries**:

1. **Graph Build Latency**:
   ```promql
   correlation_engine_graph_build_latency_ms
   ```

2. **Throughput**:
   ```promql
   rate(correlation_engine_graph_builds_total[5m])
   ```

3. **Memory Usage**:
   ```promql
   correlation_engine_memory_usage_bytes
   ```

4. **Error Rate**:
   ```promql
   rate(correlation_engine_errors_total[5m])
   ```

---

### 4.2.2.18.4.2.0.0: Alert Rules

**Create Prometheus alert rules** (`alerts.yml`):
```yaml
groups:
  - name: correlation_engine
    rules:
      - alert: HighLatency
        expr: correlation_engine_graph_build_latency_ms > 5000
        for: 5m
        annotations:
          summary: "Graph build latency exceeds 5ms"
      
      - alert: HighMemoryUsage
        expr: correlation_engine_memory_usage_bytes > 3500000000
        for: 5m
        annotations:
          summary: "Memory usage exceeds 3.5GB"
      
      - alert: HighErrorRate
        expr: rate(correlation_engine_errors_total[5m]) > 0.1
        for: 5m
        annotations:
          summary: "Error rate exceeds 10%"
```

---

## 4.2.2.18.5.0.0: Deployment Constraints

### 4.2.2.18.5.1.0.0: Phase 3: Staging Deployment

**Constraints**:
- **Max load**: 100 graphs/sec per instance (22% of benchmark capacity)
- **Governor limits**: Circuit breaker threshold at 5 failures/min
- **Audit level**: ALL (every operation logged for 7 days)
- **Failover**: Keep Layer 1-3 hot, Layer 4 on standby

**Estimated time to production-ready**: 5 engineering days
- 3 days hardening
- 2 days load testing

---

### 4.2.2.18.5.2.0.0: Single-Instance Benchmarks

**Current Performance**:
- **450 graphs/sec** = 2.20 ms/graph
- **250 anomaly detections/sec** = 4 ms/detection
- **2,700 propagations/sec** = 0.37 ms/prediction

**With Worker Threads** (optional):
- **~800 graphs/sec** = 0.8 ms/graph (63% improvement)

---

## 4.2.2.18.6.0.0: Environment Variables

**Required**:
```bash
# Database path
DATABASE_PATH=/path/to/correlation.db

# Snapshot directory
SNAPSHOT_DIR=./snapshots

# Retention days
RETENTION_DAYS=7

# Memory ceiling (bytes)
MEMORY_CEILING_BYTES=4000000000

# Query timeout (ms)
QUERY_TIMEOUT_MS=50

# Rate limiter config
RATE_LIMITER_TOKENS=1000
RATE_LIMITER_REFILL_RATE=1000
```

**Optional**:
```bash
# Enable worker threads
USE_WORKER_THREADS=true

# Enable SIMD optimization
ENABLE_SIMD=true

# Audit logging level
AUDIT_LEVEL=ALL
```

---

## 4.2.2.18.7.0.0: Rollback Plan

**If issues occur**:

1. **Disable worker threads**:
   ```typescript
   // Set useWorkers = false in buildMultiLayerGraph calls
   await engine.buildMultiLayerGraph(eventId, false);
   ```

2. **Increase query timeout**:
   ```typescript
   // Temporarily increase in config
   queryTimeoutMs: 100 // from 50ms
   ```

3. **Disable rate limiting** (emergency only):
   ```typescript
   // Comment out rate limiter check in buildMultiLayerGraph
   // if (!this.rateLimiter.acquireSync()) { ... }
   ```

4. **Rollback database schema**:
   ```sql
   -- Drop materialized view if causing issues
   DROP VIEW IF EXISTS anomaly_candidates;
   ```

---

## 4.2.2.18.8.0.0: Post-Deployment Validation

### 4.2.2.18.8.1.0.0: Health Checks

**Run health check**:
```bash
curl http://localhost:3000/health

# Expected response:
{
  "status": "HEALTHY",
  "timestamp": 1701974400000,
  "metrics": {
    "dbLatency": 0.5,
    "layerFailures": 0,
    "activeConnections": 10,
    "lastSuccessfulBuild": 1701974400000
  },
  "failover": false
}
```

---

### 4.2.2.18.8.2.0.0: Production Readiness Check

**Query readiness matrix**:
```sql
SELECT 
  COUNT(*) as total_checks,
  SUM(CASE WHEN status = 'PASS' THEN 1 ELSE 0 END) as passed,
  SUM(CASE WHEN severity = 'CRITICAL' AND status = 'FAIL' THEN 1 ELSE 0 END) as blockers
FROM production_readiness_matrix
WHERE component = 'correlation-engine';

-- Expected: 20 total, 20 passed, 0 blockers
```

---

## 4.2.2.18.9.0.0: Documentation Updates

### 4.2.2.18.9.1.0.0: Update Main Documentation

**Files to update**:
- `docs/4.0.0.0.0.0.0-MCP-ALERTING.md` - Add deployment section
- `docs/MULTI-LAYER-CORRELATION-PERFORMANCE-VALIDATION.md` - Mark items as implemented
- `README.md` - Add production deployment section

---

### 4.2.2.18.9.2.0.0: Create Runbook

**Create**: `docs/RUNBOOK-CORRELATION-ENGINE.md`

Include:
- Common issues and solutions
- Performance tuning guide
- Monitoring dashboards
- Escalation procedures

---

## 4.2.2.18.10.0.0: Success Criteria

**Staging deployment is successful when**:

1. ✅ All health checks pass
2. ✅ Metrics are being collected and visible in Grafana
3. ✅ Trace IDs are propagating across layers
4. ✅ Snapshot rotation runs successfully
5. ✅ Performance meets benchmarks (< 5ms latency)
6. ✅ No memory leaks detected over 24-hour period
7. ✅ Rate limiting prevents DoS attacks
8. ✅ Graceful degradation works (chaos tests pass)

---

## 4.2.2.18.11.0.0: Support & Escalation

**For issues**:
1. Check health endpoint: `/health`
2. Review metrics: `/metrics`
3. Check audit logs: `audit_log` table
4. Review production readiness: `production_readiness_matrix` table
5. Escalate if blockers found in readiness matrix

**Emergency contacts**:
- On-call engineer: [TBD]
- Escalation: [TBD]

---

**Status**: ✅ Ready for Staging Deployment  
**Next Review**: After 7 days of staging operation  
**Production Target**: TBD (after staging validation)
