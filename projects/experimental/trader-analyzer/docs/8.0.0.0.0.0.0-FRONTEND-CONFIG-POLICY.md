# Frontend Configuration & Policy Subsystem (8.0.0.0.0.0.0)

**Version**: 8.0.0.0.0.0.0  
**Feature**: Declarative UI Policy Management for Hyper-Bun Frontend  
**Status**: ‚úÖ Integrated  
**Date**: 2024-12-06  
**MCP Integration**: Section 4.1.0.0.0.0.0 under Master Control Program & Alerting Subsystem

---

## Overview

The Frontend Configuration & Policy Subsystem defines declarative manifests and policies governing Hyper-Bun's web-based interfaces, including dashboards and the registry. It centralizes configuration for `HTMLRewriter` transformations, feature flags, role-based access control, and client-side behavior, ensuring consistency, security, and auditability.

**Note**: This subsystem is integrated into the Master Control Program (MCP) & Alerting Subsystem as section **4.1.0.0.0.0.0 Frontend Configuration & Policy Management**. The MCP serves as the operational heart of Hyper-Bun, and frontend policy management is a core aspect of operational control. See [4.0.0.0.0.0.0 MCP & Alerting Subsystem](./4.0.0.0.0.0.0-MCP-ALERTING.md) for the integrated view.

### Key Benefits

- **Declarative Control**: Frontend behavior defined in human-readable, auditable YAML
- **Centralized Policy Management**: Single source of truth for all UI policies
- **Enhanced Auditability**: Version-controlled policy changes provide clear audit trail
- **Dynamic Deployability**: Policies can be updated without code changes
- **Improved Developer Experience**: Clear, consultable manifest instead of code diving
- **Stronger Security Posture**: Declarative RBAC and feature pruning policies

---

## 8.1.0.0.0.0.0: `HyperBunUIPolicyManifest` Definition

### 8.1.1.0.0.0.0: Purpose

A central, version-controlled YAML (or JSON) file that explicitly declares the policies and configurations applied to Hyper-Bun's frontend HTML streams. This manifest acts as the input to the `UIContextRewriter` and other frontend services, providing a single source of truth for all UI transformation policies.

**Key Characteristics**:
- Human-readable YAML format (or JSON)
- Version-controlled alongside code
- Validated against schema
- Hot-reloadable (optional)
- Environment-aware (supports overrides)

### 8.1.2.0.0.0.0: Location

**Primary Location**: `config/ui-policy-manifest.yaml`

**Alternative Formats**:
- `config/ui-policy-manifest.json` (JSON format)
- `config/ui-policy-manifest.yml` (YAML alternative extension)

**Environment-Specific Overrides**:
- `config/ui-policy-manifest.production.yaml` (production overrides)
- `config/ui-policy-manifest.development.yaml` (development overrides)

### 8.1.3.0.0.0.0: Schema Structure

The manifest follows a hierarchical structure organized by policy type:

```yaml
# config/ui-policy-manifest.yaml

# 8.1.3.1.0.0.0: Manifest Metadata
metadata:
  version: "1.0.0"
  last_updated: "2025-12-07T09:00:00Z"
  description: "Centralized policies for Hyper-Bun Dashboard and Registry frontend."
  schema_version: "8.0.0.0.0.0.0"

# 8.1.3.2.0.0.0: Global UI Context Defaults
ui_context_defaults:
  apiBaseUrl: "AUTO_DETECT" # Indicates dynamic detection from request headers
  debugMode: false
  defaultUserRole: "guest"
  # currentTimestamp is always runtime-generated

# 8.1.3.3.0.0.0: Feature Flag Management Policies
feature_flags:
  shadowGraph:
    enabled: true # Default state, can be overridden by env vars or health checks
    description: "Interactive visualization of dark pool market graphs."
    dependencies: ["performanceMonitor.shadowGraphViz"] # Optional: links to health checks
    requires_env: null # Optional: "HYPERBUN_FEATURE_SHADOW_GRAPH=true"
  
  covertSteamAlerts:
    enabled: true
    description: "Real-time alerts for hidden market movements."
    dependencies: []
    requires_env: null
  
  debugPanel:
    enabled: false
    description: "Developer-only panel for UI debugging."
    requires_env: "HYPERBUN_DEBUG_UI=true" # Explicit env var override
    dependencies: []

# 8.1.3.4.0.0.0: HTMLRewriter Transformation Policies
html_rewriter_policies:
  # 8.1.3.4.1.0.0: Context Injection Policy (Core)
  # Simple format (boolean) - recommended for most use cases
  inject_context_script: true # Always true, as defined in 6.1.1.2.2.2.1.0
  
  # Alternative: Advanced format (object) - for custom configuration
  # inject_context_script:
  #   enabled: true
  #   target: "body" # Injection target element (optional)
  #   position: "prepend" # prepend, append, before, after (optional)
  #   script_template: "window.HYPERBUN_UI_CONTEXT = {{CONTEXT_JSON}};" # (optional)

  # 8.1.3.4.2.0.0: Conditional Element Pruning Policies (data-feature)
  data_feature_pruning:
    enabled: true # Master switch for this type of transformation
    target_attribute: "data-feature"
    action: "remove_if_flag_false"
    preserve_content: false # If true, removes element but keeps inner content
    # Actual flags come from feature_flags section

  # 8.1.3.4.3.0.0: Role-Based Access Control Pruning Policies (data-access)
  data_access_pruning:
    enabled: true # Master switch for this type of transformation
    target_attribute: "data-access"
    action: "remove_if_role_mismatch"
    allowed_roles: ["admin", "analyst", "viewer"] # Valid roles
    default_role: "guest" # Role used if not specified in request
    # Roles come from ui_context_defaults.userRole or runtime detected

  # 8.1.3.4.4.0.0: Dynamic Content Implantation Policies (data-server-timestamp)
  dynamic_content_implantation:
    enabled: true # Master switch
    policies:
      - attribute: "data-server-timestamp"
        source_context_key: "currentTimestamp"
        format_function: "toLocaleString" # Client-side format or server-side function call
        fallback: "Loading..." # Text shown if context unavailable

# 8.1.3.5.0.0.0: Security Policies
security_policies:
  content_security_policy:
    enabled: true
    report_only: false # If true, only reports violations without blocking
    directives:
      default_src: "'self'"
      script_src: "'self' 'unsafe-inline'" # Required for inline context script
      style_src: "'self' 'unsafe-inline'"
      img_src: "'self' data: https:"
  
  xss_protection:
    enabled: true
    mode: "block" # block, sanitize, report
  
  context_validation:
    enabled: true
    validate_api_url: true
    validate_feature_flags: true
    validate_user_role: true

# 8.1.3.6.0.0.0: Performance Policies
performance_policies:
  enable_metrics: true
  log_transformation_time: false # Log transformation duration
  log_size_reduction: false # Log HTML size reduction
  enable_caching: false # Cache transformed HTML (experimental)
```

### 8.1.4.0.0.0.0: Schema Validation

The manifest should be validated against a JSON Schema to ensure correctness:

**Schema Location**: `config/ui-policy-manifest.schema.json`

**Validation Points**:
- On `UIPolicyManager` initialization
- Before applying policies to `UIContextRewriter`
- In CI/CD pipeline (pre-commit hooks)

---

## 8.2.0.0.0.0.0: `UIPolicyManager` Service

### 8.2.1.0.0.0.0: Purpose

A Bun-native service (`src/services/ui-policy-manager.ts`) responsible for loading, parsing, validating, and applying the `HyperBunUIPolicyManifest`. It acts as the primary interface for other services (like `UIContextRewriter` and route handlers) to retrieve current UI policies.

**Key Responsibilities**:
- Load and parse manifest file (YAML or JSON)
- Validate manifest against schema
- Resolve feature flags with runtime overrides
- Build `HyperBunUIContext` from manifest defaults
- Provide policies to `UIContextRewriter`
- Support hot-reloading (optional)

### 8.2.2.0.0.0.0: Core Functionality

#### 8.2.2.1.0.0.0: Load & Parse Manifest

Uses Bun-native file APIs to load and parse the manifest:

```typescript
// Bun-native approach using Bun.YAML.parse()
// @see https://bun.com/docs/runtime/yaml Bun YAML API Documentation
const manifestFile = Bun.file('config/ui-policy-manifest.yaml');
const manifestText = await manifestFile.text();
const manifest = Bun.YAML.parse(manifestText); // Native Bun YAML parser (Bun 1.3.3+)
// or JSON.parse(manifestText) for JSON format
```

**Bun YAML API** (Bun v1.3+):
- `Bun.YAML.parse(text)` - Parse YAML string to JavaScript object
- Supports full YAML 1.2 specification
- Native implementation (no external dependencies)
- Follows Bun v1.3 API standards for zero-dependency parsing
- Available in Bun 1.3+
- @see https://bun.com/docs/runtime/yaml Bun YAML API Documentation
- @see https://bun.com/blog/bun-v1.3#apis-standards Bun v1.3 API Standards

**File Detection**:
1. Check for environment-specific manifest (e.g., `ui-policy-manifest.production.yaml`)
2. Fall back to default manifest (`ui-policy-manifest.yaml`)
3. Support both YAML and JSON formats

#### 8.2.2.2.0.0.0: Schema Validation

Validates the loaded manifest against a predefined JSON schema:

```typescript
import Ajv from 'ajv';

const ajv = new Ajv();
const validate = ajv.compile(schema);
const valid = validate(manifest);

if (!valid) {
  throw new Error(`Manifest validation failed: ${ajv.errorsText(validate.errors)}`);
}
```

**Validation Benefits**:
- Prevents malformed policies
- Ensures type safety
- Catches configuration errors early
- Provides clear error messages

#### 8.2.2.3.0.0.0: Policy Resolution

Resolves `feature_flags` by combining manifest defaults with runtime overrides:

**Resolution Order** (highest priority first):
1. Runtime overrides (from health checks, request context)
2. Environment variable overrides (if specified in `requires_env`)
3. Manifest default values

**Example Resolution**:
```typescript
// Manifest: shadowGraph.enabled = true
// Env: HYPERBUN_FEATURE_SHADOW_GRAPH=false
// Runtime: { shadowGraph: true } (from health check)
// Result: shadowGraph = true (runtime override wins)
```

#### 8.2.2.4.0.0.0: Provide Policies to `UIContextRewriter`

Exposes methods for `UIContextRewriter` to query which transformations are enabled:

```typescript
getHTMLRewriterPolicies(): HTMLRewriterPolicies {
  return this.manifest.html_rewriter_policies;
}

isTransformationEnabled(transformation: string): boolean {
  return this.manifest.html_rewriter_policies[transformation]?.enabled ?? false;
}
```

### 8.2.3.0.0.0.0: Integration Flow

The `UIPolicyManager` follows a clear integration pattern with other services:

```typescript
// src/services/ui-policy-manager.ts - Snippet
import { readFileSync } from 'fs'; // Or Bun.file().text() for YAML, then parse
import YAML from 'js-yaml'; // Assuming js-yaml for YAML parsing
import { HyperBunUIContext } from './ui-context-rewriter';

export class UIPolicyManager {
  private manifest: any; // Type with schema validation later

  private constructor() {
    const manifestPath = './config/ui-policy-manifest.yaml';
    const manifestContent = readFileSync(manifestPath, 'utf8'); // Bun.file(manifestPath).text()
    this.manifest = YAML.load(manifestContent);
    // ... (perform schema validation here)
    console.log("8.2.2.1.0.0.0: UI Policy Manifest loaded and parsed.");
  }

  private static instance: UIPolicyManager;

  public static getInstance(): UIPolicyManager {
    if (!UIPolicyManager.instance) {
      UIPolicyManager.instance = new UIPolicyManager();
    }
    return UIPolicyManager.instance;
  }

  /**
   * 8.2.2.3.0.0.0: Resolves feature flags based on manifest and runtime overrides.
   */
  getFeatureFlags(runtimeOverrides: Record<string, boolean> = {}): Record<string, boolean> {
    const resolvedFlags: Record<string, boolean> = {};
    for (const flagName in this.manifest.feature_flags) {
      const policy = this.manifest.feature_flags[flagName];
      let enabled = policy.enabled;

      // Override by explicit env var if specified in policy
      if (policy.requires_env && process.env[policy.requires_env.split('=')[0]] === policy.requires_env.split('=')[1]) {
        enabled = true; // Env var explicitly enables
      } else if (policy.requires_env && process.env[policy.requires_env.split('=')[0]] !== policy.requires_env.split('=')[1]) {
        enabled = false; // Env var explicitly disables (if required)
      }

      // Apply runtime overrides (e.g., from performance monitor health checks)
      if (runtimeOverrides[flagName] !== undefined) {
        enabled = runtimeOverrides[flagName];
      }

      resolvedFlags[flagName] = enabled;
    }
    return resolvedFlags;
  }

  /**
   * 8.2.2.4.0.0.0: Provides HTMLRewriter policies.
   */
  getHTMLRewriterPolicies(): any { // Specific type would be defined
    return this.manifest.html_rewriter_policies;
  }

  /**
   * 8.2.2.3.0.0.0 (cont.): Builds the HyperBunUIContext based on manifest defaults and runtime data.
   */
  buildUIContext(request: Request, runtimeFeatureFlags: Record<string, boolean> = {}): HyperBunUIContext {
    const defaults = this.manifest.ui_context_defaults;
    const apiBaseUrl = defaults.apiBaseUrl === "AUTO_DETECT"
      ? request.headers.get('X-Forwarded-Proto') + '://' + request.headers.get('Host')
      : defaults.apiBaseUrl;

    const featureFlags = this.getFeatureFlags(runtimeFeatureFlags);
    const userRole = request.headers.get('X-User-Role') as HyperBunUIContext['userRole'] || 'guest'; // Assuming auth middleware sets this

    return {
      apiBaseUrl,
      featureFlags,
      userRole,
      debugMode: defaults.debugMode || (process.env.HYPERBUN_DEBUG === 'true'),
      currentTimestamp: Date.now()
    };
  }
}
```

**Key Methods**:
- `getInstance()` - Singleton access
- `getFeatureFlags(overrides?)` - Resolve feature flags with runtime overrides
- `getHTMLRewriterPolicies()` - Get transformation policies
- `buildUIContext(request, runtimeFlags?)` - Build UI context from manifest defaults and runtime data
- `reload()` - Hot-reload manifest (optional)

---

## 8.3.0.0.0.0.0: Integration with `HTMLRewriter` & Route Handlers

### 8.3.1.0.0.0.0: `UIContextRewriter` Adaptation

The `UIContextRewriter` will no longer hardcode transformation rules but will query the `UIPolicyManager` for the active policies:

```typescript
// src/services/ui-context-rewriter.ts - Adapted createRewriter method snippet
// ...
export class UIContextRewriter {
  private context: HyperBunUIContext;
  private policies: any; // Loaded from UIPolicyManager

  constructor(context: HyperBunUIContext, policies: any) { // Inject policies
    this.context = context;
    this.policies = policies;
  }

  createRewriter(): HTMLRewriter {
    const rewriter = new HTMLRewriter();
    const htmlRewriterPolicies = this.policies.html_rewriter_policies;

    if (htmlRewriterPolicies.inject_context_script) {
      rewriter.on("body", { /* ... context injection ... */ });
    }

    if (htmlRewriterPolicies.data_feature_pruning?.enabled) {
      const targetAttr = htmlRewriterPolicies.data_feature_pruning.target_attribute;
      rewriter.on(`[${targetAttr}]`, { /* ... feature flag pruning ... */ });
    }
    // ... similar for data_access_pruning and dynamic_content_implantation
    return rewriter;
  }
}
```

### 8.3.2.0.0.0.0: Route Handler Orchestration

Route handlers will use the `UIPolicyManager` to build the context and obtain policies:

```typescript
// src/api/routes.ts (and dashboard-routes.ts) - Adapted fetch handler snippet
// ...
import { UIPolicyManager } from '../services/ui-policy-manager';
const uiPolicyManager = UIPolicyManager.getInstance();

// ... inside fetch(request) ...
const runtimeFeatureFlags = {
    shadowGraph: performanceMonitor.isFeatureHealthy('shadowGraphViz') // Runtime health check
};
const uiContext = uiPolicyManager.buildUIContext(request, runtimeFeatureFlags);
const htmlRewriterPolicies = uiPolicyManager.getHTMLRewriterPolicies();

const rewriter = new UIContextRewriter(uiContext, htmlRewriterPolicies).createRewriter();
// ... rest of response serving ...
```

---

## 8.4.0.0.0.0.0: Strategic Benefits for Hyper-Bun

### 8.4.1.0.0.0.0: Declarative Control

Frontend behavior is now defined in human-readable, auditable YAML, separating configuration from code logic. This enables:

- **Non-developer configuration**: Operations teams can update policies without code changes
- **Clear documentation**: Manifest serves as living documentation of UI behavior
- **Version control**: Policy changes tracked in git with clear diffs

### 8.4.2.0.0.0.0: Centralized Policy Management

A single source of truth for all UI policies simplifies updates and ensures consistency:

- **Consistency**: All frontend interfaces use same policies
- **Single update point**: Change policy once, affects all interfaces
- **Reduced duplication**: No scattered configuration across files

### 8.4.3.0.0.0.0: Enhanced Auditability

Changes to UI behavior are version-controlled in the manifest:

- **Git history**: Clear audit trail of policy changes
- **Change attribution**: Who changed what and when
- **Rollback capability**: Easy to revert policy changes

### 8.4.4.0.0.0.0: Dynamic Deployability

Policies can be updated and hot-reloaded (if `UIPolicyManager` implements watch mechanism):

- **Zero-downtime updates**: Update policies without code deployment
- **A/B testing**: Enable/disable features via policy changes
- **Emergency kill switches**: Disable features instantly via policy

### 8.4.5.0.0.0.0: Improved Developer Experience

Developers no longer need to dive into `UIContextRewriter` code:

- **Clear manifest**: All policies visible in one place
- **Self-documenting**: Manifest describes behavior
- **Faster onboarding**: New developers understand UI behavior quickly

### 8.4.6.0.0.0.0: Stronger Security Posture

Declarative policies for RBAC and feature pruning enhance security:

- **Explicit permissions**: Clear role-based access rules
- **Defense in depth**: Policies enforced at multiple layers
- **Audit trail**: Security policy changes tracked in git

---

## Integration Examples

### Example 1: Basic Policy Usage

```typescript
// Load policies
const policyManager = UIPolicyManager.getInstance();

// Build context
const context = policyManager.buildUIContext(request);

// Get policies
const policies = policyManager.getHTMLRewriterPolicies();

// Create rewriter with policies
const rewriter = new UIContextRewriter(context, policies).createRewriter();
```

### Example 2: Runtime Feature Flag Override

```typescript
// Check health status
const shadowGraphHealthy = await performanceMonitor.checkHealth('shadowGraphViz');

// Override feature flag based on health
const runtimeFlags = {
  shadowGraph: shadowGraphHealthy
};

// Build context with overrides
const context = policyManager.buildUIContext(request, runtimeFlags);
```

### Example 3: Environment-Specific Policies

```typescript
// Load environment-specific manifest
const env = process.env.NODE_ENV || 'development';
const manifestPath = `config/ui-policy-manifest.${env}.yaml`;

// PolicyManager automatically detects and loads environment-specific manifest
const policyManager = UIPolicyManager.getInstance(manifestPath);
```

---

## Best Practices

### 1. Version Control

- Always commit manifest changes with descriptive messages
- Use semantic versioning in manifest metadata
- Tag releases with manifest versions

### 2. Testing

- Validate manifest in CI/CD pipeline
- Test policy changes in staging before production
- Use environment-specific manifests for testing

### 3. Security

- Never commit sensitive data in manifest
- Use environment variables for secrets
- Validate all policy inputs

### 4. Documentation

- Document each feature flag's purpose
- Explain RBAC role requirements
- Note dependencies between features

---

## Verification Commands

### Validate Manifest (8.2.6.0.0.0.0)

The validation script (`scripts/validate-ui-policy-manifest.ts`) provides comprehensive manifest validation:

```bash
# Basic validation (default manifest: config/ui-policy-manifest.yaml)
bun run validate:manifest

# Specify custom path
bun run validate:manifest ./config/production-manifest.yaml

# CI/CD validation (non-zero exit on error)
bun run validate:manifest:ci

# Validate with custom path in CI
bun run validate:manifest:ci ./config/production-manifest.yaml
```

**Validation Features**:
- ‚úÖ YAML/JSON parsing validation (uses `Bun.YAML.parse()`)
- ‚úÖ Required sections check (metadata, ui_context_defaults, feature_flags, html_rewriter_policies)
- ‚úÖ Type validation (booleans, arrays, objects)
- ‚úÖ Schema version check (validates against 8.0.0.0.0.0.0)
- ‚úÖ Warning for missing optional fields
- ‚úÖ Detailed error messages with file paths
- ‚úÖ Summary statistics (feature flags count, policies count)

**Example Output**:
```text
üîç Validating UI Policy Manifest: config/ui-policy-manifest.yaml

üìã Manifest Metadata:
   Version: 1.0.0
   Schema Version: 8.0.0.0.0.0.0
   Last Updated: 2025-12-07T09:00:00Z

‚úÖ Manifest is valid!

üìä Summary:
   Feature Flags: 3
   Policies: 4
```

### Verify Policy Loading

```bash
# Test policy manager loading
bun run src/services/ui-policy-manager.ts

# Test with different environments
NODE_ENV=production bun run src/services/ui-policy-manager.ts
```

### Ripgrep Discovery Patterns

```bash
# Find all version 8.0.0.0.0.0.0 references
rg "8\.0\.0\.0\.0\.0\.0"

# Find UIPolicyManager usage
rg "UIPolicyManager|ui-policy-manager"

# Find manifest references
rg "ui-policy-manifest|HyperBunUIPolicyManifest"
```

---

## 8.5.0.0.0.0.0: Integration with MCP & Alerting Subsystem (4.0.0.0.0.0.0)

The Frontend Configuration & Policy Subsystem is integrated with the Master Control Program (MCP) & Alerting Subsystem, providing AI-accessible tools for policy management and monitoring.

### 8.5.1.0.0.0.0: MCP Tools

**Location**: `src/mcp/tools/ui-policy-management.ts`

**Available Tools**:
- `ui-policy-get-manifest` - Get current UI Policy Manifest configuration
- `ui-policy-get-metrics` - Get UI Policy Manager metrics and health status
- `ui-policy-validate-manifest` - Validate UI Policy Manifest file
- `ui-policy-reload-manifest` - Hot-reload manifest without restart
- `ui-policy-get-feature-flags` - Get feature flag states
- `ui-policy-check-health` - Check health status and alert on issues

**Usage Example**:
```typescript
// Via MCP server
const tools = createUIPolicyManagementTools();
// Tools are automatically registered when MCP server starts
```

### 8.5.2.0.0.0.0: Alerting Integration

UI Policy Manager metrics are integrated with the alerting subsystem:

- **Health Monitoring**: `ui-policy-check-health` tool provides health status
- **Error Tracking**: Errors tracked via `policyMetrics` service
- **Prometheus Export**: Metrics available at `/api/ui-policy/metrics?format=prometheus`
- **WebSocket Alerts**: Real-time metric updates via `/ws/ui-policy-metrics`

### 8.5.3.0.0.0.0: MCP Server Registration

UI Policy Management tools are automatically registered when the MCP server starts:

```typescript
// scripts/mcp-server.ts
const uiPolicyTools = createUIPolicyManagementTools();
server.registerTools(uiPolicyTools);
```

---

## Related Documentation

- [UI Context Rewriter Implementation](../src/services/ui-context-rewriter.ts) - Core HTMLRewriter service
- **[Integration Guide](./INTEGRATION-GUIDE.md)** - How UI Policy Management integrates with PORT constants, CLI tools, HTMLRewriter, and Registry HTML access
- [Registry HTML Transformations](./REGISTRY-HTML-TRANSFORMATIONS-VISUAL-GUIDE.md) - Visual guide to transformations
- [Registry HTML Access](./REGISTRY-HTML-ACCESS.md) - Access guide for registry.html
- [HTMLRewriter Quick Start](./guides/HTML-REWRITER-QUICK-START.md) - Quick start guide
- [Component Sitemap](../COMPONENT-SITEMAP.md) - Component reference
- [MCP Server Documentation](../MCP-SERVER.md) - Master Control Program server
- [4.0.0.0.0.0.0 MCP & Alerting Subsystem](./4.0.0.0.0.0.0.0-MCP-ALERTING.md) - MCP subsystem documentation

---

## Version History

- **8.0.0.0.0.0.0** (2024-12-06): Initial implementation of Frontend Configuration & Policy Subsystem
  - Created `HyperBunUIPolicyManifest` schema
  - Implemented `UIPolicyManager` service
  - Integrated with `UIContextRewriter`
  - Added route handler orchestration

---

**Ripgrep Pattern**: `8\.0\.0\.0\.0\.0\.0|FRONTEND-CONFIG-POLICY|UIPolicyManager|ui-policy-manifest`
