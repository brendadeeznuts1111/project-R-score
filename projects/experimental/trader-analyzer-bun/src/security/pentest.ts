/**
 * @fileoverview Penetration Testing Scanner
 * @module security/pentest
 *
 * Automated security scanner for web applications and APIs
 * IMPORTANT: Only use on systems you own or have explicit authorization to test
 */

import type {
	ApiPentestConfig,
	AuthConfig,
	PentestConfig,
	PentestResult,
	ScannerCallbacks,
	SeverityLevel,
	Vulnerability,
	VulnerabilityCategory,
} from "./types";

// Common injection payloads (safe/detection-only)
const SQL_INJECTION_PAYLOADS = [
	"' OR '1'='1",
	"' OR '1'='1' --",
	"1' OR '1'='1",
	"1 OR 1=1",
	"' UNION SELECT NULL--",
	"'; DROP TABLE users--",
	"1; SELECT * FROM users",
	"admin'--",
];

const XSS_PAYLOADS = [
	"<script>alert(1)</script>",
	"<img src=x onerror=alert(1)>",
	"<svg onload=alert(1)>",
	"javascript:alert(1)",
	'"><script>alert(1)</script>',
	"'-alert(1)-'",
	"<body onload=alert(1)>",
];

const SSRF_PAYLOADS = [
	"http://localhost",
	"http://127.0.0.1",
	"http://[::1]",
	"http://169.254.169.254", // AWS metadata
	"http://metadata.google.internal", // GCP metadata
	"file:///etc/passwd",
];

const PATH_TRAVERSAL_PAYLOADS = [
	"../../../etc/passwd",
	"..\\..\\..\\windows\\system32\\config\\sam",
	"....//....//....//etc/passwd",
	"%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
];

const COMMAND_INJECTION_PAYLOADS = [
	"; ls -la",
	"| cat /etc/passwd",
	"`id`",
	"$(whoami)",
	"; sleep 5",
];

/**
 * Web Penetration Tester
 */
export class WebPentester {
	private config: Required<PentestConfig>;
	private callbacks: ScannerCallbacks;
	private vulnerabilities: Vulnerability[] = [];
	private requestCount = 0;
	private urlsTested = new Set<string>();
	private parametersTested = new Set<string>();
	private authToken?: string;

	constructor(config: PentestConfig, callbacks?: ScannerCallbacks) {
		this.config = {
			target: config.target,
			scope: config.scope ?? [new URL(config.target).hostname],
			excludePatterns: config.excludePatterns ?? [],
			authConfig: config.authConfig ?? { type: "none" },
			depth: config.depth ?? "standard",
			checks: config.checks ?? "all",
			maxRequests: config.maxRequests ?? 1000,
			rateLimit: config.rateLimit ?? 10,
			timeout: config.timeout ?? 10000,
			followRedirects: config.followRedirects ?? true,
			userAgent: config.userAgent ?? "NEXUS-Security-Scanner/1.0",
			headers: config.headers ?? {},
			cookies: config.cookies ?? {},
		};
		this.callbacks = callbacks ?? {};
	}

	/**
	 * Run full penetration test
	 */
	async scan(): Promise<PentestResult> {
		const startTime = Date.now();

		console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ”’ NEXUS Security Scanner                                â•‘
â•‘  Target: ${this.config.target.slice(0, 45).padEnd(45)}â•‘
â•‘  Depth: ${this.config.depth.padEnd(46)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `);

		// Authenticate if needed
		await this.authenticate();

		// Phase 1: Reconnaissance
		console.log("Phase 1: Reconnaissance...");
		const discoveredUrls = await this.crawl();

		// Phase 2: Security Headers Check
		console.log("Phase 2: Security Headers...");
		await this.checkSecurityHeaders();

		// Phase 3: SSL/TLS Check
		console.log("Phase 3: SSL/TLS...");
		await this.checkSSL();

		// Phase 4: Vulnerability Scanning
		console.log("Phase 4: Vulnerability Scanning...");

		const checks =
			this.config.checks === "all"
				? ([
						"injection",
						"xss",
						"csrf",
						"ssrf",
						"idor",
						"misconfig",
						"cors",
					] as VulnerabilityCategory[])
				: this.config.checks;

		for (const url of discoveredUrls) {
			if (this.requestCount >= this.config.maxRequests) break;

			this.callbacks.onProgress?.({
				current: this.requestCount,
				total: this.config.maxRequests,
				url,
			});

			for (const check of checks) {
				await this.runCheck(url, check);
			}
		}

		const endTime = Date.now();

		const result: PentestResult = {
			target: this.config.target,
			startTime,
			endTime,
			duration: endTime - startTime,
			requestCount: this.requestCount,
			vulnerabilities: this.vulnerabilities,
			summary: this.getSummary(),
			coverage: {
				urlsTested: this.urlsTested.size,
				parametersTested: this.parametersTested.size,
				endpointsTested: discoveredUrls.length,
			},
		};

		this.callbacks.onComplete?.(result);
		this.printSummary(result);

		return result;
	}

	/**
	 * Authenticate with target
	 */
	private async authenticate(): Promise<void> {
		const { authConfig } = this.config;
		if (authConfig.type === "none") return;

		try {
			switch (authConfig.type) {
				case "bearer":
					this.authToken = authConfig.credentials?.token;
					break;

				case "basic": {
					const creds = `${authConfig.credentials?.username}:${authConfig.credentials?.password}`;
					this.authToken = `Basic ${btoa(creds)}`;
					break;
				}

				case "cookie":
					// Perform login to get session cookie
					if (authConfig.loginUrl) {
						const response = await this.makeRequest(authConfig.loginUrl, {
							method: authConfig.loginMethod ?? "POST",
							body: JSON.stringify(authConfig.loginBody),
							headers: { "Content-Type": "application/json" },
						});
						// Extract cookies from response
						const setCookie = response.headers.get("set-cookie");
						if (setCookie) {
							// Parse and store cookies
							console.log("  Authentication successful");
						}
					}
					break;
			}
		} catch (error) {
			this.callbacks.onError?.(error as Error, "authentication");
		}
	}

	/**
	 * Crawl target to discover URLs
	 */
	private async crawl(): Promise<string[]> {
		const urls = new Set<string>([this.config.target]);
		const visited = new Set<string>();
		const toVisit = [this.config.target];

		const maxCrawl =
			this.config.depth === "crawl-all"
				? 500
				: this.config.depth === "deep"
					? 100
					: this.config.depth === "standard"
						? 50
						: 20;

		while (toVisit.length > 0 && visited.size < maxCrawl) {
			const url = toVisit.shift()!;
			if (visited.has(url)) continue;
			visited.add(url);

			try {
				const response = await this.makeRequest(url);
				const html = await response.text();

				// Extract links
				const linkRegex = /href=["']([^"']+)["']/gi;
				let match;
				while ((match = linkRegex.exec(html)) !== null) {
					try {
						const link = new URL(match[1], url);
						if (this.isInScope(link.href) && !visited.has(link.href)) {
							urls.add(link.href);
							toVisit.push(link.href);
						}
					} catch {}
				}

				// Extract forms
				const formRegex = /<form[^>]*action=["']([^"']*)["'][^>]*>/gi;
				while ((match = formRegex.exec(html)) !== null) {
					try {
						const formUrl = new URL(match[1] || url, url);
						if (this.isInScope(formUrl.href)) {
							urls.add(formUrl.href);
						}
					} catch {}
				}
			} catch (error) {
				// Skip failed URLs
			}
		}

		console.log(`  Discovered ${urls.size} URLs`);
		return Array.from(urls);
	}

	/**
	 * Check if URL is in scope
	 */
	private isInScope(url: string): boolean {
		try {
			const parsed = new URL(url);

			// Check if in allowed scope
			const inScope = this.config.scope.some((s) =>
				s.startsWith("*.")
					? parsed.hostname.endsWith(s.slice(1))
					: parsed.hostname === s,
			);

			// Check if excluded
			const excluded = this.config.excludePatterns.some(
				(p) => url.includes(p) || new RegExp(p).test(url),
			);

			return inScope && !excluded;
		} catch {
			return false;
		}
	}

	/**
	 * Check security headers
	 */
	private async checkSecurityHeaders(): Promise<void> {
		try {
			const response = await this.makeRequest(this.config.target, {
				method: "HEAD",
			});

			const requiredHeaders = [
				"Strict-Transport-Security",
				"Content-Security-Policy",
				"X-Content-Type-Options",
				"X-Frame-Options",
				"X-XSS-Protection",
				"Referrer-Policy",
			];

			for (const header of requiredHeaders) {
				if (!response.headers.get(header)) {
					this.addVulnerability({
						category: "headers",
						severity: header === "Strict-Transport-Security" ? "medium" : "low",
						title: `Missing ${header} Header`,
						description: `The ${header} header is not set, which may expose the application to certain attacks.`,
						url: this.config.target,
						remediation: `Add the ${header} header to all responses.`,
						references: ["https://owasp.org/www-project-secure-headers/"],
					});
				}
			}

			// Check for information disclosure headers
			const serverHeader = response.headers.get("Server");
			if (serverHeader && /\d/.test(serverHeader)) {
				this.addVulnerability({
					category: "misconfig",
					severity: "info",
					title: "Server Version Disclosure",
					description: `The Server header discloses version information: ${serverHeader}`,
					url: this.config.target,
					evidence: serverHeader,
					remediation: "Remove or obfuscate the Server header.",
					references: [
						"https://owasp.org/www-project-web-security-testing-guide/",
					],
				});
			}
		} catch (error) {
			this.callbacks.onError?.(error as Error, "security-headers");
		}
	}

	/**
	 * Check SSL/TLS configuration
	 */
	private async checkSSL(): Promise<void> {
		const url = new URL(this.config.target);

		// Check if HTTPS
		if (url.protocol !== "https:") {
			this.addVulnerability({
				category: "ssl",
				severity: "high",
				title: "No HTTPS",
				description:
					"The application does not use HTTPS, exposing all traffic to interception.",
				url: this.config.target,
				remediation: "Enable HTTPS with a valid SSL certificate.",
				references: ["https://letsencrypt.org/"],
			});
			return;
		}

		// Basic TLS check via fetch
		try {
			await fetch(this.config.target, {
				method: "HEAD",
				signal: AbortSignal.timeout(5000),
			});
			console.log("  SSL/TLS: OK");
		} catch (error) {
			if ((error as Error).message.includes("certificate")) {
				this.addVulnerability({
					category: "ssl",
					severity: "high",
					title: "SSL Certificate Issue",
					description: `SSL certificate validation failed: ${(error as Error).message}`,
					url: this.config.target,
					remediation: "Fix the SSL certificate configuration.",
					references: ["https://www.ssllabs.com/ssltest/"],
				});
			}
		}
	}

	/**
	 * Run specific vulnerability check
	 */
	private async runCheck(
		url: string,
		category: VulnerabilityCategory,
	): Promise<void> {
		switch (category) {
			case "injection":
				await this.checkSQLInjection(url);
				await this.checkCommandInjection(url);
				break;
			case "xss":
				await this.checkXSS(url);
				break;
			case "ssrf":
				await this.checkSSRF(url);
				break;
			case "cors":
				await this.checkCORS(url);
				break;
			case "csrf":
				await this.checkCSRF(url);
				break;
			case "idor":
				await this.checkIDOR(url);
				break;
		}
	}

	/**
	 * Check for SQL Injection
	 */
	private async checkSQLInjection(url: string): Promise<void> {
		const parsedUrl = new URL(url);

		for (const [param, value] of parsedUrl.searchParams) {
			this.parametersTested.add(`${url}:${param}`);

			for (const payload of SQL_INJECTION_PAYLOADS.slice(0, 3)) {
				const testUrl = new URL(url);
				testUrl.searchParams.set(param, payload);

				try {
					const response = await this.makeRequest(testUrl.href);
					const body = await response.text();

					// Check for SQL error messages
					const sqlErrors = [
						"SQL syntax",
						"mysql_",
						"ORA-",
						"PostgreSQL",
						"sqlite3",
						"ODBC",
						"SQLite",
						"syntax error",
						"unclosed quotation",
					];

					for (const error of sqlErrors) {
						if (body.toLowerCase().includes(error.toLowerCase())) {
							this.addVulnerability({
								category: "injection",
								severity: "critical",
								title: "SQL Injection",
								description: `Possible SQL injection vulnerability in parameter "${param}"`,
								url,
								method: "GET",
								parameter: param,
								payload,
								evidence: `Response contains: ${error}`,
								remediation:
									"Use parameterized queries or prepared statements.",
								references: [
									"https://owasp.org/www-community/attacks/SQL_Injection",
								],
								cwe: 89,
							});
							return;
						}
					}
				} catch {}

				await this.rateLimit();
			}
		}
	}

	/**
	 * Check for XSS
	 */
	private async checkXSS(url: string): Promise<void> {
		const parsedUrl = new URL(url);

		for (const [param] of parsedUrl.searchParams) {
			for (const payload of XSS_PAYLOADS.slice(0, 3)) {
				const testUrl = new URL(url);
				testUrl.searchParams.set(param, payload);

				try {
					const response = await this.makeRequest(testUrl.href);
					const body = await response.text();

					// Check if payload is reflected
					if (body.includes(payload)) {
						this.addVulnerability({
							category: "xss",
							severity: "high",
							title: "Reflected XSS",
							description: `XSS payload reflected in response for parameter "${param}"`,
							url,
							method: "GET",
							parameter: param,
							payload,
							evidence: "Payload reflected without encoding",
							remediation: "Encode all user input before rendering in HTML.",
							references: ["https://owasp.org/www-community/attacks/xss/"],
							cwe: 79,
						});
						return;
					}
				} catch {}

				await this.rateLimit();
			}
		}
	}

	/**
	 * Check for SSRF
	 */
	private async checkSSRF(url: string): Promise<void> {
		const parsedUrl = new URL(url);

		for (const [param, value] of parsedUrl.searchParams) {
			// Only test URL-like parameters
			if (!value.includes("http") && !value.includes("url")) continue;

			for (const payload of SSRF_PAYLOADS.slice(0, 2)) {
				const testUrl = new URL(url);
				testUrl.searchParams.set(param, payload);

				try {
					const response = await this.makeRequest(testUrl.href);
					const body = await response.text();

					// Check for signs of SSRF
					if (
						body.includes("root:") ||
						body.includes("localhost") ||
						body.includes("127.0.0.1") ||
						response.status === 200
					) {
						this.addVulnerability({
							category: "ssrf",
							severity: "high",
							title: "Server-Side Request Forgery (SSRF)",
							description: `Possible SSRF in parameter "${param}"`,
							url,
							parameter: param,
							payload,
							remediation:
								"Validate and whitelist allowed URLs. Block internal IPs.",
							references: [
								"https://owasp.org/www-community/attacks/Server_Side_Request_Forgery",
							],
							cwe: 918,
						});
						return;
					}
				} catch {}

				await this.rateLimit();
			}
		}
	}

	/**
	 * Check for CORS misconfiguration
	 */
	private async checkCORS(url: string): Promise<void> {
		try {
			// Test with arbitrary origin
			const response = await this.makeRequest(url, {
				headers: { Origin: "https://evil.com" },
			});

			const acao = response.headers.get("Access-Control-Allow-Origin");
			const acac = response.headers.get("Access-Control-Allow-Credentials");

			if (acao === "*" && acac === "true") {
				this.addVulnerability({
					category: "cors",
					severity: "high",
					title: "CORS Misconfiguration",
					description: "CORS allows any origin with credentials",
					url,
					evidence: `ACAO: ${acao}, ACAC: ${acac}`,
					remediation:
						"Restrict allowed origins and avoid using credentials with wildcard.",
					references: [
						"https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny",
					],
				});
			} else if (acao === "https://evil.com") {
				this.addVulnerability({
					category: "cors",
					severity: "medium",
					title: "CORS Reflects Arbitrary Origin",
					description: "CORS reflects the Origin header without validation",
					url,
					evidence: `Origin reflected: ${acao}`,
					remediation: "Validate Origin against a whitelist.",
					references: [
						"https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny",
					],
				});
			}
		} catch {}
	}

	/**
	 * Check for CSRF
	 */
	private async checkCSRF(url: string): Promise<void> {
		try {
			const response = await this.makeRequest(url);
			const html = await response.text();

			// Check for forms without CSRF tokens
			const formRegex =
				/<form[^>]*method=["']post["'][^>]*>([\s\S]*?)<\/form>/gi;
			let match;

			while ((match = formRegex.exec(html)) !== null) {
				const formContent = match[1];

				// Look for CSRF token fields
				const hasCSRF = /csrf|token|_token|authenticity_token/i.test(
					formContent,
				);

				if (!hasCSRF) {
					this.addVulnerability({
						category: "csrf",
						severity: "medium",
						title: "Missing CSRF Protection",
						description: "POST form found without apparent CSRF token",
						url,
						evidence: "Form missing CSRF token input",
						remediation:
							"Implement CSRF tokens for all state-changing requests.",
						references: ["https://owasp.org/www-community/attacks/csrf"],
						cwe: 352,
					});
				}
			}
		} catch {}
	}

	/**
	 * Check for IDOR
	 */
	private async checkIDOR(url: string): Promise<void> {
		const parsedUrl = new URL(url);

		// Look for numeric IDs in path or params
		const idPatterns = [
			/\/(\d+)(?:\/|$)/,
			/[?&]id=(\d+)/,
			/[?&]user_?id=(\d+)/,
		];

		for (const pattern of idPatterns) {
			const pathMatch = parsedUrl.pathname.match(pattern);
			const searchMatch = parsedUrl.search.match(pattern);

			if (pathMatch || searchMatch) {
				const originalId = (pathMatch || searchMatch)![1];
				const testId = String(parseInt(originalId) + 1);

				// Try incrementing the ID
				const testUrl = url.replace(originalId, testId);

				try {
					const response = await this.makeRequest(testUrl);

					if (response.status === 200) {
						this.addVulnerability({
							category: "idor",
							severity: "medium",
							title: "Potential IDOR",
							description: "Sequential ID enumeration may be possible",
							url,
							evidence: `Accessed ${testUrl} successfully`,
							remediation:
								"Use unpredictable identifiers and implement proper authorization.",
							references: [
								"https://owasp.org/www-project-web-security-testing-guide/",
							],
							cwe: 639,
						});
					}
				} catch {}
			}
		}
	}

	/**
	 * Check for Command Injection
	 */
	private async checkCommandInjection(url: string): Promise<void> {
		const parsedUrl = new URL(url);

		for (const [param] of parsedUrl.searchParams) {
			// Time-based detection
			const payload = "; sleep 5";
			const testUrl = new URL(url);
			testUrl.searchParams.set(param, payload);

			try {
				const startTime = Date.now();
				await this.makeRequest(testUrl.href);
				const duration = Date.now() - startTime;

				if (duration > 4500) {
					this.addVulnerability({
						category: "injection",
						severity: "critical",
						title: "Command Injection",
						description: `Possible command injection in parameter "${param}"`,
						url,
						parameter: param,
						payload,
						evidence: `Response delayed by ${duration}ms`,
						remediation: "Never pass user input to shell commands.",
						references: [
							"https://owasp.org/www-community/attacks/Command_Injection",
						],
						cwe: 78,
					});
				}
			} catch {}

			await this.rateLimit();
		}
	}

	/**
	 * Make HTTP request with rate limiting
	 */
	private async makeRequest(
		url: string,
		options?: RequestInit,
	): Promise<Response> {
		this.requestCount++;
		this.urlsTested.add(url);

		const headers: Record<string, string> = {
			"User-Agent": this.config.userAgent,
			...this.config.headers,
			...((options?.headers as Record<string, string>) ?? {}),
		};

		if (this.authToken) {
			headers["Authorization"] = this.authToken;
		}

		// Add cookies
		if (Object.keys(this.config.cookies).length > 0) {
			headers["Cookie"] = Object.entries(this.config.cookies)
				.map(([k, v]) => `${k}=${v}`)
				.join("; ");
		}

		return fetch(url, {
			...options,
			headers,
			redirect: this.config.followRedirects ? "follow" : "manual",
			signal: AbortSignal.timeout(this.config.timeout),
		});
	}

	/**
	 * Rate limiting
	 */
	private async rateLimit(): Promise<void> {
		const delay = 1000 / this.config.rateLimit;
		await new Promise((resolve) => setTimeout(resolve, delay));
	}

	/**
	 * Add vulnerability
	 */
	private addVulnerability(
		partial: Omit<Vulnerability, "id" | "timestamp">,
	): void {
		const vuln: Vulnerability = {
			id: `vuln-${Date.now()}-${Math.random().toString(36).slice(2)}`,
			timestamp: Date.now(),
			...partial,
		};

		this.vulnerabilities.push(vuln);
		this.callbacks.onVulnerabilityFound?.(vuln);

		const emoji =
			vuln.severity === "critical"
				? "ğŸ”´"
				: vuln.severity === "high"
					? "ğŸŸ "
					: vuln.severity === "medium"
						? "ğŸŸ¡"
						: vuln.severity === "low"
							? "ğŸŸ¢"
							: "âšª";

		console.log(`  ${emoji} ${vuln.severity.toUpperCase()}: ${vuln.title}`);
	}

	/**
	 * Get summary counts
	 */
	private getSummary(): PentestResult["summary"] {
		const counts = {
			critical: 0,
			high: 0,
			medium: 0,
			low: 0,
			info: 0,
			total: 0,
		};

		for (const vuln of this.vulnerabilities) {
			counts[vuln.severity]++;
			counts.total++;
		}

		return counts;
	}

	/**
	 * Print final summary
	 */
	private printSummary(result: PentestResult): void {
		const { summary, duration, coverage } = result;

		console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“Š Scan Complete                                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Duration: ${(duration / 1000).toFixed(1)}s                                         â•‘
â•‘  Requests: ${result.requestCount.toString().padEnd(44)}â•‘
â•‘  URLs Tested: ${coverage.urlsTested.toString().padEnd(41)}â•‘
â•‘  Parameters: ${coverage.parametersTested.toString().padEnd(42)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ”´ Critical: ${summary.critical.toString().padEnd(40)}â•‘
â•‘  ğŸŸ  High: ${summary.high.toString().padEnd(44)}â•‘
â•‘  ğŸŸ¡ Medium: ${summary.medium.toString().padEnd(42)}â•‘
â•‘  ğŸŸ¢ Low: ${summary.low.toString().padEnd(45)}â•‘
â•‘  âšª Info: ${summary.info.toString().padEnd(44)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `);
	}
}

/**
 * API Penetration Tester
 */
export class ApiPentester extends WebPentester {
	private apiConfig: ApiPentestConfig;

	constructor(config: ApiPentestConfig, callbacks?: ScannerCallbacks) {
		super(config, callbacks);
		this.apiConfig = config;
	}

	/**
	 * Scan API with OpenAPI spec
	 */
	async scanApi(): Promise<PentestResult> {
		if (this.apiConfig.openApiSpec) {
			await this.loadOpenApiSpec();
		}

		return this.scan();
	}

	/**
	 * Load and parse OpenAPI specification
	 */
	private async loadOpenApiSpec(): Promise<void> {
		try {
			const spec = this.apiConfig.openApiSpec!;
			let openApi: any;

			if (spec.startsWith("http")) {
				const response = await fetch(spec);
				openApi = await response.json();
			} else {
				const file = Bun.file(spec);
				const text = await file.text();
				openApi =
					spec.endsWith(".yaml") || spec.endsWith(".yml")
						? JSON.parse(text) // Would need yaml parser
						: JSON.parse(text);
			}

			console.log(`  Loaded OpenAPI spec: ${openApi.info?.title ?? "Unknown"}`);

			// Extract endpoints from spec
			// This is simplified - full implementation would parse all paths/methods
			if (openApi.paths) {
				for (const [path, methods] of Object.entries(openApi.paths)) {
					console.log(`  Found endpoint: ${path}`);
				}
			}
		} catch (error) {
			console.error("  Failed to load OpenAPI spec:", (error as Error).message);
		}
	}
}

/**
 * Create a web pentester
 */
export function createWebPentester(
	config: PentestConfig,
	callbacks?: ScannerCallbacks,
): WebPentester {
	return new WebPentester(config, callbacks);
}

/**
 * Create an API pentester
 */
export function createApiPentester(
	config: ApiPentestConfig,
	callbacks?: ScannerCallbacks,
): ApiPentester {
	return new ApiPentester(config, callbacks);
}

/**
 * Quick security scan (simplified)
 */
export async function quickScan(target: string): Promise<PentestResult> {
	const pentester = new WebPentester({
		target,
		depth: "quick",
		maxRequests: 50,
		checks: ["headers", "cors", "ssl", "csrf"],
	});
	return pentester.scan();
}
