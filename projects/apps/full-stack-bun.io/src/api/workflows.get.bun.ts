/**
 * Workflows API Endpoint
 * GET /api/workflows - List and query workflows
 */

import { structuredLog } from "../shared/utils";
import { readdirSync, existsSync } from "fs";
import { join } from "path";
import { z } from "zod";
import { inspect } from "bun";

const querySchema = z.object({
  type: z.enum(['yaml', 'temporal', 'prompt']).optional(),
  status: z.enum(['active', 'inactive']).optional(),
  limit: z.coerce.number().min(1).max(50).default(10),
  offset: z.coerce.number().min(0).default(0)
});

export async function GET(request: Request) {
  const startTime = performance.now();

  try {
    const url = new URL(request.url);
    const queryParams = Object.fromEntries(url.searchParams);

    const query = querySchema.parse(queryParams);

    const workflowsDir = join(process.cwd(), '.cursor', 'workflows');
    let workflows: any[] = [];

    if (existsSync(workflowsDir)) {
      const files = readdirSync(workflowsDir).filter(f => f.endsWith('.yaml'));

      for (const file of files.slice(query.offset, query.offset + query.limit)) {
        try {
          const content = await Bun.file(join(workflowsDir, file)).text();
          const workflow = parseWorkflowMetadata(content, file);
          workflows.push(workflow);
        } catch (error) {
          console.warn(`Failed to parse workflow ${file}:`, error);
        }
      }
    }

    const responseTime = performance.now() - startTime;

    const response = {
      workflows,
      pagination: {
        total: workflows.length,
        limit: query.limit,
        offset: query.offset,
        hasMore: false // Simplified for this demo
      },
      metadata: {
        responseTime: `${responseTime.toFixed(2)}ms`,
        timestamp: new Date().toISOString(),
        filters: query
      }
    };

    structuredLog("Workflows query completed", {
      count: workflows.length,
      filters: query,
      responseTime
    });

    return Response.json(response, {
      headers: { "x-response-time": `${responseTime.toFixed(2)}ms` }
    });

  } catch (error) {
    const responseTime = performance.now() - startTime;

    structuredLog("Workflows query failed", { error: inspect(error), responseTime });

    if (error instanceof z.ZodError) {
      return Response.json({
        error: "Invalid query parameters",
        details: error.errors
      }, {
        status: 400,
        headers: { "x-response-time": `${responseTime.toFixed(2)}ms` }
      });
    }

    return Response.json({
      error: "Failed to query workflows",
      details: error.message
    }, {
      status: 500,
      headers: { "x-response-time": `${responseTime.toFixed(2)}ms` }
    });
  }
}

function parseWorkflowMetadata(content: string, filename: string): any {
  const lines = content.split('\n');
  const metadata: any = {
    id: filename.replace('.yaml', ''),
    filename,
    name: filename.replace('.yaml', '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
    type: 'yaml',
    status: 'active'
  };

  // Extract basic metadata from YAML comments and content
  for (const line of lines.slice(0, 10)) {
    if (line.startsWith('#')) {
      const comment = line.substring(1).trim();
      if (comment.includes('Generated by Cursor Workflow Designer')) {
        metadata.source = 'designer';
      }
    }

    if (line.includes('name:')) {
      const match = line.match(/name:\s*(.+)/);
      if (match) metadata.name = match[1].trim();
    }

    if (line.includes('version:')) {
      const match = line.match(/version:\s*(.+)/);
      if (match) metadata.version = match[1].trim();
    }

    if (line.includes('description:')) {
      const match = line.match(/description:\s*(.+)/);
      if (match) metadata.description = match[1].trim();
    }
  }

  // Count steps/activities
  const stepMatches = content.match(/- name:/g);
  metadata.stepCount = stepMatches ? stepMatches.length : 0;

  // Check for human approval
  metadata.hasHumanApproval = content.includes('humanApproval: true');

  // Estimate complexity
  if (metadata.stepCount > 10) {
    metadata.complexity = 'high';
  } else if (metadata.stepCount > 5) {
    metadata.complexity = 'medium';
  } else {
    metadata.complexity = 'low';
  }

  metadata.lastModified = new Date().toISOString(); // Simplified

  return metadata;
}
