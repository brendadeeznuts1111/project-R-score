#!/usr/bin/env bun

/**
 * Topic Git Hooks Manager
 *
 * Manages git hooks for automatic topic routing of commits.
 * Routes commit messages to appropriate Telegram topics based on patterns.
 */

import { $ } from "bun";
import { parse } from "yaml";
import { appendToFile, readTextFile } from "./lib/bytes.ts";

const TOPICS_CONFIG = `${import.meta.dir}/../config/telegram-topics.yaml`;
const PROJECTS_CONFIG = `${import.meta.dir}/../config/project-topics.yaml`;

interface ProjectConfig {
	path: string;
	repo?: string;
	default_topic: number;
	topics?: Record<number, string[]>;
	notifications?: {
		on_push?: boolean;
		on_commit?: boolean;
		on_merge?: boolean;
	};
}

interface Config {
	projects: Record<string, ProjectConfig>;
}

async function loadConfig(): Promise<Config> {
	const content = await readTextFile(PROJECTS_CONFIG);
	if (!content) throw new Error("Failed to load projects config");
	return parse(content) as Config;
}

function determineTopic(message: string, project: ProjectConfig): number {
	const lowerMsg = message.toLowerCase();

	// Check project-specific patterns
	if (project.topics) {
		for (const [topicId, patterns] of Object.entries(project.topics)) {
			for (const pattern of patterns) {
				const cleanPattern = pattern.replace(/:\*$/, "").toLowerCase();
				if (lowerMsg.includes(cleanPattern)) {
					return parseInt(topicId);
				}
			}
		}
	}

	// Default patterns
	if (message.match(/^(fix|bug|hotfix|error)/i)) return 2; // Alerts
	if (message.match(/^(feat|feature|implement|add)/i)) return 7; // Development
	if (message.match(/^(docs|doc|readme|wiki)/i)) return 1; // General
	if (message.match(/^(test|testing|spec)/i)) return 7; // Development
	if (message.match(/^(refactor|cleanup|style)/i)) return 7; // Development
	if (message.match(/^(chore|maint|update)/i)) return 5; // Logs

	return project.default_topic;
}

async function routeCommit(
	projectName: string,
	hash: string,
	message: string,
	author: string,
) {
	const config = await loadConfig();
	const project = config.projects[projectName];

	if (!project) {
		console.log(`‚ö†Ô∏è Project ${projectName} not found in config`);
		return;
	}

	const topicId = determineTopic(message, project);
	const topicNames: Record<number, string> = {
		1: "General üì¢",
		2: "Alerts üö®",
		5: "Logs üìä",
		7: "Development üíª",
	};

	const shortHash = hash.substring(0, 7);
	const shortMsg = message.split("\n")[0].substring(0, 50);

	console.log(`üì® Routing commit to Topic ${topicId} (${topicNames[topicId]}):`);
	console.log(`   ${shortHash} by ${author}: ${shortMsg}`);

	// In production, this would send to Telegram API
	// For now, log to file
	const logEntry = {
		timestamp: new Date().toISOString(),
		project: projectName,
		topic: topicId,
		hash: shortHash,
		author,
		message: shortMsg,
	};

	const logFile = `${import.meta.dir}/../logs/topic-routing.jsonl`;
	await appendToFile(logFile, JSON.stringify(logEntry) + "\n", {
		rotate: true,
		maxSize: 10 * 1024 * 1024,
	});

	return { topicId, topicName: topicNames[topicId] };
}

async function installHooks(projectPath: string, projectName: string) {
	const hookDir = `${projectPath}/.git/hooks`;

	// Create post-commit hook for topic routing
	const postCommitHook = `#!/bin/sh
# Topic Routing Hook - Auto-generated by tier1380-openclaw
# Routes commits to appropriate Telegram topics

HASH=$(git rev-parse HEAD)
MESSAGE=$(git log -1 --pretty=%B)
AUTHOR=$(git log -1 --pretty=%an)

# Route to topic
bun ${import.meta.dir}/topic-git-hooks.ts route "${projectName}" "$HASH" "$MESSAGE" "$AUTHOR"
`;

	// Create post-merge hook
	const postMergeHook = `#!/bin/sh
# Topic Routing Hook - Post Merge
# Notifies when branches are merged

HASH=$(git rev-parse HEAD)
BRANCH=$(git branch --show-current)
AUTHOR=$(git log -1 --pretty=%an)

bun ${import.meta.dir}/topic-git-hooks.ts merge "${projectName}" "$BRANCH" "$HASH" "$AUTHOR"
`;

	// Write hooks
	await Bun.write(`${hookDir}/post-commit-topic`, postCommitHook);
	await Bun.write(`${hookDir}/post-merge-topic`, postMergeHook);

	// Make executable
	await $`chmod +x ${hookDir}/post-commit-topic`.quiet();
	await $`chmod +x ${hookDir}/post-merge-topic`.quiet();

	// Also add to main hooks if they exist
	const mainPostCommit = `${hookDir}/post-commit`;
	const mainPostMerge = `${hookDir}/post-merge`;

	// Append to existing hooks if not already present
	try {
		const existingCommit = await readTextFile(mainPostCommit);
		if (!existingCommit.includes("topic-git-hooks.ts")) {
			await Bun.write(
				mainPostCommit,
				existingCommit +
					`\n# Topic routing\nbun ${import.meta.dir}/topic-git-hooks.ts route "${projectName}" "$HASH" "$MESSAGE" "$AUTHOR"\n`,
				{ append: false },
			);
		}
	} catch {
		// Hook doesn't exist, skip
	}

	console.log(`‚úÖ Installed topic hooks for ${projectName} at ${projectPath}`);
}

async function uninstallHooks(projectPath: string) {
	const hookDir = `${projectPath}/.git/hooks`;

	await $`rm -f ${hookDir}/post-commit-topic ${hookDir}/post-merge-topic`.quiet();
	console.log(`üóëÔ∏è Removed topic hooks from ${projectPath}`);
}

async function listInstalledHooks() {
	const config = await loadConfig();

	console.log("üìã Installed Topic Hooks:");
	console.log("=".repeat(60));

	for (const [name, project] of Object.entries(config.projects)) {
		const hookDir = `${project.path}/.git/hooks`;
		const hasCommitHook = await Bun.file(`${hookDir}/post-commit-topic`).exists();
		const hasMergeHook = await Bun.file(`${hookDir}/post-merge-topic`).exists();

		const status = hasCommitHook && hasMergeHook ? "‚úÖ Installed" : "‚ùå Not installed";
		console.log(`${status} ${name}`);
		console.log(`   Path: ${project.path}`);
		console.log(`   Default Topic: ${project.default_topic}`);
		console.log();
	}
}

async function handleMerge(
	projectName: string,
	branch: string,
	hash: string,
	author: string,
) {
	const config = await loadConfig();
	const project = config.projects[projectName];

	if (!project) return;

	// Merges go to General (1) by default
	const topicId = 1;

	console.log(`üîÄ Merge detected on ${branch} by ${author}`);
	console.log(`üì® Routed to Topic ${topicId} (General)`);

	const logEntry = {
		timestamp: new Date().toISOString(),
		type: "merge",
		project: projectName,
		topic: topicId,
		branch,
		hash: hash.substring(0, 7),
		author,
	};

	const logFile = `${import.meta.dir}/../logs/topic-routing.jsonl`;
	await appendToFile(logFile, JSON.stringify(logEntry) + "\n", {
		rotate: true,
		maxSize: 10 * 1024 * 1024,
	});
}

// CLI
const [, , command, ...args] = process.argv;

switch (command) {
	case "route":
		// Called by git hook: route <project> <hash> <message> <author>
		if (args.length >= 4) {
			const [project, hash, ...rest] = args;
			const author = rest.pop() || "unknown";
			const message = rest.join(" ");
			await routeCommit(project, hash, message, author);
		}
		break;

	case "merge":
		// Called by git hook: merge <project> <branch> <hash> <author>
		if (args.length >= 4) {
			const [project, branch, hash, author] = args;
			await handleMerge(project, branch, hash, author);
		}
		break;

	case "install":
		if (args[0]) {
			const config = await loadConfig();
			const project = config.projects[args[0]];
			if (project) {
				await installHooks(project.path, args[0]);
			} else {
				console.error(`‚ùå Project ${args[0]} not found`);
				process.exit(1);
			}
		} else {
			// Install for all projects
			const config = await loadConfig();
			for (const [name, project] of Object.entries(config.projects)) {
				if (await Bun.file(`${project.path}/.git`).exists()) {
					await installHooks(project.path, name);
				}
			}
		}
		break;

	case "uninstall":
		if (args[0]) {
			const config = await loadConfig();
			const project = config.projects[args[0]];
			if (project) {
				await uninstallHooks(project.path);
			}
		} else {
			const config = await loadConfig();
			for (const [name, project] of Object.entries(config.projects)) {
				await uninstallHooks(project.path);
			}
		}
		break;

	case "list":
		await listInstalledHooks();
		break;

	default:
		console.log(`
Topic Git Hooks Manager

Usage:
  topic-git-hooks install [project]    Install hooks for project(s)
  topic-git-hooks uninstall [project]  Remove hooks from project(s)
  topic-git-hooks list                 List installed hooks
  
Arguments:
  project    Project name (optional, defaults to all)
`);
}
