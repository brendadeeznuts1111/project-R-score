#!/usr/bin/env bun
// scripts/compare-profiles.js - Profile comparison and analysis tool

import { existsSync, readFileSync } from "node:fs";

class ProfileComparator {
	parseProfile(filePath) {
		if (!existsSync(filePath)) {
			throw new Error(`Profile file not found: ${filePath}`);
		}

		const content = readFileSync(filePath, "utf-8");
		const lines = content.split("\n");
		const metrics = [];
		let totalExecutionTime = 0;

		// Parse profile data (simplified for Bun's MD format)
		for (const line of lines) {
			if (line.includes("|") && !line.startsWith("| Function")) {
				const parts = line
					.split("|")
					.map((p) => p.trim())
					.filter((p) => p);
				if (parts.length >= 4) {
					const totalTime = parseFloat(parts[1]) || 0;
					const callCount = parseInt(parts[2], 10) || 0;
					const functionName = parts[0];

					if (functionName && totalTime > 0) {
						metrics.push({
							functionName,
							totalTime,
							callCount,
							averageTime: callCount > 0 ? totalTime / callCount : 0,
							percentage: 0, // Will be calculated
						});
						totalExecutionTime += totalTime;
					}
				}
			}
		}

		// Calculate percentages
		metrics.forEach((metric) => {
			metric.percentage =
				totalExecutionTime > 0
					? (metric.totalTime / totalExecutionTime) * 100
					: 0;
		});

		return metrics.sort((a, b) => b.totalTime - a.totalTime);
	}

	compareMetrics(baseline, current) {
		const baselineMap = new Map(baseline.map((m) => [m.functionName, m]));
		const currentMap = new Map(current.map((m) => [m.functionName, m]));

		const improvements = [];
		const regressions = [];

		// Find improvements and regressions
		for (const [name, currentMetric] of currentMap) {
			const baselineMetric = baselineMap.get(name);

			if (baselineMetric) {
				const timeDiff = currentMetric.totalTime - baselineMetric.totalTime;
				const percentDiff = (timeDiff / baselineMetric.totalTime) * 100;

				const comparison = {
					functionName: name,
					totalTime: currentMetric.totalTime,
					callCount: currentMetric.callCount,
					averageTime: currentMetric.averageTime,
					percentage: percentDiff,
				};

				if (timeDiff < 0) {
					improvements.push(comparison);
				} else if (timeDiff > 0) {
					regressions.push(comparison);
				}
			}
		}

		const baselineTotal = baseline.reduce((sum, m) => sum + m.totalTime, 0);
		const currentTotal = current.reduce((sum, m) => sum + m.totalTime, 0);
		const timeChange = ((currentTotal - baselineTotal) / baselineTotal) * 100;

		// Calculate performance score (0-100)
		const improvementScore = improvements.reduce(
			(sum, m) => sum + Math.abs(m.percentage),
			0,
		);
		const regressionScore = regressions.reduce(
			(sum, m) => sum + Math.abs(m.percentage),
			0,
		);
		const performanceScore = Math.max(
			0,
			Math.min(100, 50 + improvementScore - regressionScore),
		);

		return {
			baseline: "",
			current: "",
			improvements: improvements.sort((a, b) => b.percentage - a.percentage),
			regressions: regressions.sort((a, b) => b.percentage - a.percentage),
			summary: {
				totalTimeChange: timeChange,
				functionCountChange: current.length - baseline.length,
				performanceScore,
			},
		};
	}

	generateReport(comparison) {
		const report = [
			"# üìä Performance Profile Comparison Report",
			`Generated: ${new Date().toISOString()}`,
			"",
			"## üìà Summary",
			`- Total execution time change: ${comparison.summary.totalTimeChange.toFixed(2)}%`,
			`- Function count change: ${comparison.summary.functionCountChange}`,
			`- Performance score: ${comparison.summary.performanceScore.toFixed(1)}/100`,
			"",
			"## üöÄ Performance Improvements",
			...comparison.improvements.map(
				(m) =>
					`‚úÖ **${m.functionName}**: ${m.percentage.toFixed(2)}% faster (${m.totalTime.toFixed(2)}ms ‚Üí ${m.totalTime.toFixed(2)}ms)`,
			),
			"",
			"## ‚ö†Ô∏è Performance Regressions",
			...comparison.regressions.map(
				(m) =>
					`‚ùå **${m.functionName}**: ${m.percentage.toFixed(2)}% slower (${m.totalTime.toFixed(2)}ms ‚Üí ${m.totalTime.toFixed(2)}ms)`,
			),
			"",
			"---",
			`*Report generated by Smart Profile Comparator*`,
		].join("\n");

		return report;
	}

	async compare(baselinePath, currentPath, outputPath) {
		try {
			console.log("üìä Loading baseline profile...");
			const baseline = this.parseProfile(baselinePath);

			console.log("üìä Loading current profile...");
			const current = this.parseProfile(currentPath);

			console.log("üîç Analyzing performance changes...");
			const comparison = this.compareMetrics(baseline, current);
			comparison.baseline = baselinePath;
			comparison.current = currentPath;

			const report = this.generateReport(comparison);

			if (outputPath) {
				await Bun.write(outputPath, report);
				console.log(`‚úÖ Comparison report saved to: ${outputPath}`);
			} else {
				console.log(`\n${report}`);
			}
		} catch (error) {
			console.error(`‚ùå Profile comparison failed: ${error.message}`);
			process.exit(1);
		}
	}
}

// CLI Interface
async function main() {
	const args = process.argv.slice(2);
	let baselinePath = "";
	let currentPath = "";
	let outputPath = "";

	for (let i = 0; i < args.length; i++) {
		const arg = args[i];

		if (arg === "--baseline") {
			baselinePath = args[i + 1];
			i++;
		} else if (arg === "--current") {
			currentPath = args[i + 1];
			i++;
		} else if (arg === "--output") {
			outputPath = args[i + 1];
			i++;
		} else if (arg === "--help") {
			console.log(`
üìä Smart Profile Comparator - Compare performance profiles

USAGE:
  bun compare-profiles.js --baseline <path> --current <path> [--output <path>]

OPTIONS:
  --baseline <path>     Path to baseline profile file
  --current <path>      Path to current profile file
  --output <path>       Save report to file (optional)
  --help               Show this help

EXAMPLES:
  bun compare-profiles.js --baseline profiles/baseline.md --current profiles/current.md
  bun compare-profiles.js --baseline profiles/baseline.md --current profiles/current.md --output reports/comparison.md
`);
			process.exit(0);
		}
	}

	if (!baselinePath || !currentPath) {
		console.error("‚ùå Both --baseline and --current paths are required");
		process.exit(1);
	}

	const comparator = new ProfileComparator();
	await comparator.compare(baselinePath, currentPath, outputPath);
}

if (import.meta.main) {
	main().catch(console.error);
}

export { ProfileComparator };
