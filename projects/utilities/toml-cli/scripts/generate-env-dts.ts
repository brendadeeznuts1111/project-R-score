#!/usr/bin/env bun
/**
 * Generate TypeScript type definitions for Bun feature flags
 *
 * Creates env.d.ts with all available features for compile-time validation
 * Extracts features from:
 * - Base features (DEBUG, PREMIUM_SECRETS, etc.)
 * - Domain-based features (@duoplus, @internal, etc.)
 * - Scope features (ENTERPRISE, DEVELOPMENT, etc.)
 *
 * Run: bun scripts/generate-env-dts.ts
 * Or add to package.json: "generate:types": "bun scripts/generate-env-dts.ts"
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';

// Hardcoded domains from config
const DOMAINS: Record<string, string[]> = {
  'api.duoplus.io': ['ENTERPRISE'],
  'dev.duoplus.io': ['DEVELOPMENT'],
  'internal.duoplus.io': ['INTERNAL'],
  'github.com': ['GITHUB'],
  'gitlab.com': ['GITLAB'],
};

// --- 1. Domain → Feature Conversion
function domainToFeature(domain: string): string {
  return (
    domain
      .toLowerCase()
      .replace(/[^a-z0-9.-]/g, '_') // normalize special chars
      .replace(/\./g, '_') // dots → underscores
      .replace(/-/g, '_') // dashes → underscores
      .replace(/_+/g, '_') // collapse multiple _
      .replace(/^_+|_+$/g, '') // trim leading/trailing _
      .toUpperCase() + '_TENANT'
  );
}

// --- 2. Extract scope features
const scopeFeatures = new Set<string>();
for (const scopes of Object.values(DOMAINS)) {
  for (const scope of scopes) {
    scopeFeatures.add(scope.replace(/-/g, '_').toUpperCase());
  }
}

// --- 3. Base + computed features
const BASE_FEATURES = [
  'DEBUG', // Enable console logging/debug output
  'PREMIUM_SECRETS', // Enable secret management
  'R2_STORAGE', // Enable Cloudflare R2 integration
  'VAULT_INTEGRATION', // Enable external vault
  'CONTENT_DISPOSITION_EXPORTS', // Enable S3 export headers
  'CACHE_COMPRESSION', // Enable gzip caching
  'ANALYTICS_TRACKING', // Enable analytics collection
  'AUDIT_LOGGING', // Enable detailed audit logs
  'MOCK_API', // Use mock APIs for testing
  'PRIVATE_REGISTRY', // Enable private npm registry
  'SCOPING_MATRIX', // Enable DuoPlus scoping matrix
  'BETA_FEATURES', // Enable experimental features
  'ENTERPRISE_ONLY', // Enterprise-only features
  'RATE_LIMITING', // Enable rate limiting
  'WEBHOOK_SIGNING', // Enable webhook signature verification
] as const;

const domainFeatures = [...new Set(Object.keys(DOMAINS).map(domainToFeature))];

const allFeatures = [...BASE_FEATURES, ...scopeFeatures, ...domainFeatures];

const uniqueFeatures = [...new Set(allFeatures)].sort();

// --- 4. Generate TypeScript definitions
const content = `// ⚠️ AUTO-GENERATED by scripts/generate-env-dts.ts
// DO NOT EDIT MANUALLY
// Regenerated on: ${new Date().toISOString()}
//
// Usage:
//   bun build --feature=DEBUG --feature=PREMIUM_SECRETS ./app.ts
//   bun run --feature=MOCK_API ./app.ts
//   bun test --feature=MOCK_API
//
// Type-safe feature checking:
//   if (process.env.DEBUG === "true") { ... }
//   Bun.env("PREMIUM_SECRETS") → type-checked

declare module "bun:bundle" {
  interface Registry {
    features: ${uniqueFeatures.map((f) => `"${f}"`).join(' | ')};
  }
}

// Feature flag utilities
export const Features = {
${uniqueFeatures.map((f) => `  ${f}: "${f}"`).join(',\n')},
} as const;

export type FeatureFlag = typeof Features[keyof typeof Features];

// Helper function for runtime checks
export function isFeatureEnabled(feature: FeatureFlag): boolean {
  return process.env[feature] === "true";
}

// Helper for build-time feature detection
export function feature(name: FeatureFlag): boolean {
  // At runtime, check env variable; at build time, Bun checks actual flags
  return typeof process.env[name] !== "undefined";
}
`;

// --- 5. Safe atomic write
function safeWrite(filePath: string, newContent: string) {
  let existingContent = '';
  if (existsSync(filePath)) {
    try {
      existingContent = readFileSync(filePath, 'utf8');
    } catch {
      // Ignore read errors
    }
  }

  if (existingContent.trim() !== newContent.trim()) {
    writeFileSync(filePath, newContent, 'utf8');
    console.log(`✅ Updated ${filePath} (${uniqueFeatures.length} features)`);
    return true;
  } else {
    console.log(`ℹ️  ${filePath} unchanged`);
    return false;
  }
}

// --- 6. Main execution
function main() {
  try {
    const outputPath = './env.d.ts';
    const changed = safeWrite(outputPath, content);

    console.log(`\nGenerated ${uniqueFeatures.length} feature flags:`);
    console.log('  Base Features:', BASE_FEATURES.length);
    console.log('  Domain Features:', domainFeatures.length);
    console.log('  Scope Features:', scopeFeatures.size);

    if (changed) {
      console.log('\nFeature list:');
      console.log(uniqueFeatures.map((f) => `  • ${f}`).join('\n'));
      console.log(`\nUpdate TypeScript for type checking:`);
      console.log(`  bunx tsc --noEmit`);
    }

    process.exit?.(0) ?? Bun.exit(0);
  } catch (err) {
    console.error('❌ Failed to generate env.d.ts:', err);
    process.exit?.(1) ?? Bun.exit(1);
  }
}

if (import.meta.main) {
  main();
}
