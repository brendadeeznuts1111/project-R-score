#!/usr/bin/env bun
/**
 * Profile Generation Script
 * 
 * Discovers all project directories and generates heap profile.md files
 * using Bun's --heap-prof-md flag.
 */

import { existsSync, readdirSync, statSync } from 'fs';
import { join, dirname, basename } from 'path';
import { $ } from 'bun';
import { 
  createProfilingError, 
  handleProfilingError,
  ProfilingErrorCode,
  type ProfilingError 
} from './profiling-errors.ts';

interface ProjectInfo {
  path: string;
  name: string;
  entryPoint: string | null;
  hasPackageJson: boolean;
}

const ROOT_DIR = '/Users/nolarose/Projects';
const MAX_DEPTH = 3; // Max depth for project discovery

// Parse command line arguments
const args = Bun.argv.slice(2);
const DRY_RUN = args.includes('--dry-run') || args.includes('-n');
const CPU_PROF = args.includes('--cpu-prof') || args.includes('--cpu');
const HEAP_PROF_ONLY = args.includes('--heap-only');
const BOTH = args.includes('--both');
// Heap profiling format: 'md' (markdown), 'v8' (V8 snapshot), or 'both'
const HEAP_FORMAT_ARG = args.find(arg => arg.startsWith('--heap-format='))?.split('=')[1] || 'md';
const HEAP_FORMAT = HEAP_FORMAT_ARG === 'v8' ? 'v8' : HEAP_FORMAT_ARG === 'both' ? 'both' : 'md';
// Custom output directory
const HEAP_PROF_DIR_ARG = args.find(arg => arg.startsWith('--heap-prof-dir='))?.split('=')[1];
const CPU_PROF_DIR_ARG = args.find(arg => arg.startsWith('--cpu-prof-dir='))?.split('=')[1];
// Default to heap profiling if nothing specified, or both if --both is specified
const HEAP_PROF = BOTH || (!CPU_PROF && !HEAP_PROF_ONLY) || (HEAP_PROF_ONLY);
const CPU_PROF_FINAL = BOTH || CPU_PROF;
const HEAP_PROF_FINAL = BOTH || HEAP_PROF;

/**
 * Create a minimal test script for profiling when no entry point exists
 */
async function createMinimalTestScript(projectPath: string): Promise<string | null> {
  const testScriptPath = join(projectPath, '__profile_test__.ts');
  
  try {
    // Check if it already exists
    if (existsSync(testScriptPath)) {
      return '__profile_test__.ts';
    }
    
    // Create a minimal script that imports the project
    const testScript = `#!/usr/bin/env bun
/**
 * Minimal test script for profiling
 * Auto-generated by generate-all-profiles.ts
 */

// Try to import the project's main exports
try {
  // Attempt common import patterns
  const pkg = await import('./package.json');
  console.log('Project:', pkg.name || 'unknown');
  
  // Try importing index files
  try {
    await import('./index.ts');
  } catch {}
  
  try {
    await import('./src/index.ts');
  } catch {}
  
  try {
    await import('./lib/index.ts');
  } catch {}
  
  // Small delay to ensure profiling captures the state
  await new Promise(resolve => setTimeout(resolve, 100));
  
  console.log('Profile test completed');
} catch (error) {
  console.error('Error in profile test:', error);
}
`;
    
    await Bun.write(testScriptPath, testScript);
    return '__profile_test__.ts';
  } catch (error) {
    return null;
  }
}

/**
 * Find entry point for a project directory
 */
async function findEntryPoint(projectPath: string, createTestScript: boolean = true): Promise<string | null> {
  try {
    const entryPoints = [
      'index.ts',
      'main.ts',
      'src/index.ts',
      'lib/index.ts',
      'server.ts',
      'server/server.ts',
      'server/server-enhanced.ts',
    ];

    for (const entry of entryPoints) {
      try {
        const fullPath = join(projectPath, entry);
        if (existsSync(fullPath)) {
          return entry;
        }
      } catch (e) {
        // Continue to next entry point
        continue;
      }
    }

    // Check package.json for scripts
    const packageJsonPath = join(projectPath, 'package.json');
    if (existsSync(packageJsonPath)) {
      try {
        const pkgContent = await Bun.file(packageJsonPath).text();
        // Use Bun.JSONC.parse() for JSONC support (comments, trailing commas)
        // Reference: https://bun.com/blog/bun-v1.3.6#bun-jsonc-api-for-parsing-json-with-comments
        const content = Bun.JSONC.parse(pkgContent);
        
        // Check for main field
        if (content.main) {
          const mainPath = join(projectPath, content.main);
          if (existsSync(mainPath)) {
            return content.main;
          }
        }
        
        if (content.scripts) {
          // Try to find a main script
          const mainScripts = ['start', 'dev', 'main', 'index', 'build', 'test'];
          for (const scriptName of mainScripts) {
            if (content.scripts[scriptName]) {
              const script = content.scripts[scriptName];
              // Extract the file from script (e.g., "bun run server.ts" -> "server.ts")
              const match = script.match(/(\S+\.ts)/);
              if (match) {
                const scriptFile = match[1];
                const scriptPath = join(projectPath, scriptFile);
                if (existsSync(scriptPath)) {
                  return scriptFile;
                }
              }
            }
          }
        }
      } catch (e) {
        // Ignore JSON parse errors - continue
      }
    }
    
    // If no entry point found and createTestScript is enabled, create a minimal test script
    if (createTestScript) {
      const testScript = await createMinimalTestScript(projectPath);
      if (testScript) {
        return testScript;
      }
    }
  } catch (error) {
    // Fail safely - return null if any error occurs
    return null;
  }

  return null;
}

/**
 * Discover all project directories
 */
async function discoverProjects(rootDir: string, depth = 0): Promise<ProjectInfo[]> {
  const projects: ProjectInfo[] = [];

  try {
    // Explicitly include lib/ directory
    const libPath = join(rootDir, 'lib');
    if (existsSync(libPath)) {
      try {
        if (statSync(libPath).isDirectory()) {
          const libIndex = join(libPath, 'index.ts');
          if (existsSync(libIndex)) {
            projects.push({
              path: libPath,
              name: 'lib',
              entryPoint: 'index.ts',
              hasPackageJson: existsSync(join(libPath, 'package.json')),
            });
          }
        }
      } catch (e) {
        // Fail safely - skip lib if there's an error
      }
    }
  } catch (error) {
    // Fail safely - continue without lib if there's an error
  }

  // Find all directories with package.json (max depth 2 from root)
  async function findPackageJsonDirs(dir: string, currentDepth: number): Promise<void> {
    if (currentDepth > MAX_DEPTH) return;

    try {
      const entries = readdirSync(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        try {
          if (entry.isDirectory()) {
            // Skip node_modules, .git, etc.
            if (entry.name.startsWith('.') || entry.name === 'node_modules') {
              continue;
            }

            const fullPath = join(dir, entry.name);
            
            try {
              const packageJsonPath = join(fullPath, 'package.json');

          if (existsSync(packageJsonPath)) {
            // Found a project directory
            try {
              // Don't create test scripts during discovery - only when actually profiling
              const entryPoint = await findEntryPoint(fullPath, false);
              projects.push({
                path: fullPath,
                name: entry.name,
                entryPoint,
                hasPackageJson: true,
              });
            } catch (e) {
              // Fail safely - add project without entry point
              projects.push({
                path: fullPath,
                name: entry.name,
                entryPoint: null,
                hasPackageJson: true,
              });
            }
              } else {
                // Recurse into subdirectories
                await findPackageJsonDirs(fullPath, currentDepth + 1);
              }
            } catch (e) {
              // Fail safely - skip this directory
              continue;
            }
          }
        } catch (e) {
          // Fail safely - skip this entry
          continue;
        }
      }
    } catch (e) {
      // Ignore permission errors and continue
    }
  }

  try {
    await findPackageJsonDirs(rootDir, 0);
  } catch (error) {
    // Fail safely - continue with projects found so far
  }

  // Also check root-level projects explicitly mentioned in plan
  const rootLevelProjects = [
    'monorepo',
    'native-addon-tool',
    'warstrike-refractions',
    'clawdbot',
    'registry-migration',
    'shared',
    'frontend-spec',
    'rust-bun-plugin',
  ];

  for (const projectName of rootLevelProjects) {
    try {
      const projectPath = join(rootDir, projectName);
      if (existsSync(projectPath)) {
        try {
          if (statSync(projectPath).isDirectory()) {
            // Check if already added
            if (!projects.find(p => p.path === projectPath)) {
              try {
                // Don't create test scripts during discovery
                const entryPoint = await findEntryPoint(projectPath, false);
                projects.push({
                  path: projectPath,
                  name: projectName,
                  entryPoint,
                  hasPackageJson: existsSync(join(projectPath, 'package.json')),
                });
              } catch (e) {
                // Fail safely - add without entry point
                projects.push({
                  path: projectPath,
                  name: projectName,
                  entryPoint: null,
                  hasPackageJson: existsSync(join(projectPath, 'package.json')),
                });
              }
            }
          }
        } catch (e) {
          // Fail safely - skip this project
          continue;
        }
      }
    } catch (error) {
      // Fail safely - skip this project
      continue;
    }
  }

  return projects;
}

/**
 * Generate profiles for a project (CPU, heap, or both)
 */
async function generateProfile(
  project: ProjectInfo, 
  dryRun: boolean, 
  originalCwd: string,
  cpuProf: boolean,
  heapProf: boolean,
  heapFormat: 'md' | 'v8' | 'both' = 'md',
  heapProfDir?: string,
  cpuProfDir?: string
): Promise<{ cpu: boolean; heap: boolean }> {
  // Determine output paths
  const cpuDir = cpuProfDir || project.path;
  const heapDir = heapProfDir || project.path;
  
  const cpuProfilePath = join(cpuDir, 'cpu-profile.md');
  const heapProfileMdPath = join(heapDir, 'profile.md');
  const heapProfileV8Path = join(heapDir, `${project.name}.heapsnapshot`);
  const result = { cpu: false, heap: false };

  console.log(`\nüìä ${dryRun ? '[DRY RUN] ' : ''}Generating profile for: ${project.name}`);
  console.log(`   Path: ${project.path}`);
  
  // Handle missing entry point
  if (!project.entryPoint) {
    if (dryRun) {
      console.log(`   ‚ö†Ô∏è  No entry point found`);
      console.log(`   üîç [DRY RUN] Would try to create test script or skip`);
      return result;
    } else {
      // Try to create a test script as fallback
      console.log(`   ‚ö†Ô∏è  No entry point found, attempting to create test script...`);
      try {
        const testScript = await createMinimalTestScript(project.path);
        if (testScript) {
          project.entryPoint = testScript;
          console.log(`   ‚úÖ Created minimal test script: ${testScript}`);
        } else {
          const error = createProfilingError(
            ProfilingErrorCode.ENTRY_POINT_NOT_FOUND,
            { project: project.name, path: project.path }
          );
          error.log();
          return result;
        }
      } catch (error) {
        const profilingError = handleProfilingError(
          error,
          ProfilingErrorCode.ENTRY_POINT_NOT_FOUND,
          { project: project.name, path: project.path }
        );
        profilingError.log();
        return result;
      }
    }
  }
  
  // Entry point exists (either found or created)
  console.log(`   Entry point: ${project.entryPoint}`);
  if (project.entryPoint === '__profile_test__.ts') {
    console.log(`   ‚ö†Ô∏è  Using auto-generated test script (no root entry point found)`);
  }
  
  console.log(`   CPU Profiling: ${cpuProf ? '‚úÖ' : '‚ùå'}`);
  if (cpuProf && cpuProfDir) {
    console.log(`   CPU Output Dir: ${cpuProfDir}`);
  }
  console.log(`   Heap Profiling: ${heapProf ? '‚úÖ' : '‚ùå'}`);
  if (heapProf) {
    console.log(`   Heap Format: ${heapFormat === 'both' ? 'Markdown + V8' : heapFormat === 'v8' ? 'V8 Snapshot' : 'Markdown'}`);
    if (heapProfDir) {
      console.log(`   Heap Output Dir: ${heapProfDir}`);
    }
  }

  if (dryRun) {
    if (cpuProf) {
      console.log(`   üîç [DRY RUN] Would generate CPU profile at: ${cpuProfilePath}`);
    }
    if (heapProf) {
      if (heapFormat === 'md' || heapFormat === 'both') {
        console.log(`   üîç [DRY RUN] Would generate heap markdown at: ${heapProfileMdPath}`);
      }
      if (heapFormat === 'v8' || heapFormat === 'both') {
        console.log(`   üîç [DRY RUN] Would generate heap snapshot at: ${heapProfileV8Path}`);
      }
    }
    return { cpu: cpuProf, heap: heapProf }; // Return true for dry run
  }

  try {
    const entryPointPath = join(project.path, project.entryPoint);
    
    // Verify entry point exists
    if (!existsSync(entryPointPath)) {
      console.log(`   ‚ö†Ô∏è  Entry point not found: ${entryPointPath}`);
      return false;
    }

    // Store original directory and change to project directory
    const previousCwd = process.cwd();
    
    try {
      process.chdir(project.path);

      // Build bun command with profiling flags
      let cmd: any;
      const cmdParts: string[] = ['bun'];
      
      // CPU profiling flags
      if (cpuProf) {
        cmdParts.push('--cpu-prof-md');
        if (cpuProfDir) {
          cmdParts.push(`--cpu-prof-dir`, cpuProfDir);
        }
        cmdParts.push('--cpu-prof-name', 'cpu-profile.md');
      }
      
      // Heap profiling flags
      if (heapProf) {
        if (heapFormat === 'md' || heapFormat === 'both') {
          cmdParts.push('--heap-prof-md');
          if (heapProfDir) {
            cmdParts.push(`--heap-prof-dir`, heapProfDir);
          }
          cmdParts.push('--heap-prof-name', 'profile.md');
        }
        if (heapFormat === 'v8' || heapFormat === 'both') {
          cmdParts.push('--heap-prof');
          if (heapProfDir) {
            cmdParts.push(`--heap-prof-dir`, heapProfDir);
          }
          cmdParts.push('--heap-prof-name', `${project.name}.heapsnapshot`);
        }
      }
      
      cmdParts.push(project.entryPoint);
      
      // Execute command using template literal syntax
      cmd = $(cmdParts).quiet();
      
      // Run bun with profiling with timeout
      const execResult = await Promise.race([
        cmd,
        new Promise<{ exitCode: number }>((resolve) => 
          setTimeout(() => resolve({ exitCode: 124 }), 30000) // 30 second timeout
        ),
      ]);

      // Restore original directory
      process.chdir(previousCwd);

      if (execResult.exitCode === 0) {
        // Check if CPU profile was created
        if (cpuProf) {
          if (existsSync(cpuProfilePath)) {
            try {
              const stats = statSync(cpuProfilePath);
              console.log(`   ‚úÖ CPU profile generated: ${(stats.size / 1024).toFixed(2)} KB`);
              result.cpu = true;
            } catch (e) {
              console.log(`   ‚ö†Ô∏è  CPU profile created but could not read stats`);
              result.cpu = true; // Still count as success
            }
          } else {
            console.log(`   ‚ö†Ô∏è  CPU profile command succeeded but cpu-profile.md not found`);
          }
        }

        // Check if heap profiles were created
        if (heapProf) {
          let heapSuccess = false;
          
          if (heapFormat === 'md' || heapFormat === 'both') {
            if (existsSync(heapProfileMdPath)) {
              try {
                const stats = statSync(heapProfileMdPath);
                console.log(`   ‚úÖ Heap markdown generated: ${(stats.size / 1024).toFixed(2)} KB`);
                heapSuccess = true;
              } catch (e) {
                console.log(`   ‚ö†Ô∏è  Heap markdown created but could not read stats`);
                heapSuccess = true;
              }
            } else if (heapFormat === 'md') {
              console.log(`   ‚ö†Ô∏è  Heap markdown command succeeded but profile.md not found`);
            }
          }
          
          if (heapFormat === 'v8' || heapFormat === 'both') {
            if (existsSync(heapProfileV8Path)) {
              try {
                const stats = statSync(heapProfileV8Path);
                console.log(`   ‚úÖ Heap snapshot generated: ${(stats.size / 1024).toFixed(2)} KB`);
                heapSuccess = true;
              } catch (e) {
                console.log(`   ‚ö†Ô∏è  Heap snapshot created but could not read stats`);
                heapSuccess = true;
              }
            } else if (heapFormat === 'v8') {
              const error = createProfilingError(
                ProfilingErrorCode.PROFILE_FILE_NOT_CREATED,
                { 
                  project: project.name, 
                  expectedPath: heapProfileV8Path,
                  format: 'v8-snapshot'
                }
              );
              error.log();
            }
          }
          
          result.heap = heapSuccess;
        }

        return result;
      } else if (execResult.exitCode === 124) {
        const error = createProfilingError(
          ProfilingErrorCode.PROFILE_TIMEOUT,
          { project: project.name, entryPoint: project.entryPoint }
        );
        error.log();
        return result;
      } else {
        const error = createProfilingError(
          ProfilingErrorCode.PROFILE_GENERATION_FAILED,
          { 
            project: project.name, 
            entryPoint: project.entryPoint,
            exitCode: execResult.exitCode 
          }
        );
        error.log();
        return result;
      }
    } catch (chdirError) {
      // Restore original directory even on error
      try {
        process.chdir(previousCwd);
      } catch (e) {
        // If we can't restore, try originalCwd
        try {
          process.chdir(originalCwd);
        } catch (e2) {
          // Last resort - ignore
        }
      }
      throw chdirError;
    }
  } catch (error) {
    // Ensure we're back in original directory
    try {
      process.chdir(originalCwd);
    } catch (e) {
      // Ignore if we can't change back
    }
    
    const profilingError = handleProfilingError(
      error,
      ProfilingErrorCode.PROFILE_GENERATION_FAILED,
      { project: project.name, entryPoint: project.entryPoint }
    );
    profilingError.log();
    return result;
  }
}

/**
 * Main execution
 */
async function main() {
  const originalCwd = process.cwd();
  
  try {
    if (DRY_RUN) {
      console.log('üîç [DRY RUN MODE] Discovering projects...\n');
    } else {
      console.log('üîç Discovering projects...\n');
    }
    
    const projects = await discoverProjects(ROOT_DIR);
    
    console.log(`Found ${projects.length} projects:\n`);
    projects.forEach(p => {
      console.log(`  - ${p.name} (${p.path})`);
      if (p.entryPoint) {
        console.log(`    Entry: ${p.entryPoint}`);
      } else {
        console.log(`    ‚ö†Ô∏è  No entry point`);
      }
    });

  const profileType = BOTH ? 'CPU + Heap' : CPU_PROF_FINAL && !HEAP_PROF_FINAL ? 'CPU' : HEAP_PROF_FINAL && !CPU_PROF_FINAL ? 'Heap' : 'CPU + Heap';
  
  if (DRY_RUN) {
    console.log(`\n\nüîç [DRY RUN MODE] Would generate ${profileType} profiles for ${projects.filter(p => p.entryPoint).length} projects...\n`);
  } else {
    console.log(`\n\nüöÄ Generating ${profileType} profiles...\n`);
  }

  const results = {
    cpuSuccess: 0,
    heapSuccess: 0,
    cpuFailed: 0,
    heapFailed: 0,
    skipped: 0,
  };

  for (const project of projects) {
    try {
      const profileResult = await generateProfile(
        project, 
        DRY_RUN, 
        originalCwd, 
        CPU_PROF_FINAL, 
        HEAP_PROF_FINAL,
        HEAP_FORMAT as 'md' | 'v8' | 'both',
        HEAP_PROF_DIR_ARG,
        CPU_PROF_DIR_ARG
      );
      
      if (profileResult.cpu) {
        results.cpuSuccess++;
      } else if (CPU_PROF_FINAL) {
        results.cpuFailed++;
      }
      
      if (profileResult.heap) {
        results.heapSuccess++;
      } else if (HEAP_PROF_FINAL) {
        results.heapFailed++;
      }
      
      if (!project.entryPoint) {
        results.skipped++;
      }
      } catch (error) {
        // Fail safely - continue with next project
        const profilingError = handleProfilingError(
          error,
          ProfilingErrorCode.PROFILE_GENERATION_FAILED,
          { project: project.name, entryPoint: project.entryPoint }
        );
        profilingError.log();
        if (project.entryPoint) {
          if (CPU_PROF_FINAL) results.cpuFailed++;
          if (HEAP_PROF_FINAL) results.heapFailed++;
        } else {
          results.skipped++;
        }
      }
  }

  console.log(`\n\nüìà Summary:`);
  if (DRY_RUN) {
    if (CPU_PROF_FINAL) {
      console.log(`   üîç [DRY RUN] CPU profiles would succeed: ${results.cpuSuccess}`);
      console.log(`   üîç [DRY RUN] CPU profiles would fail: ${results.cpuFailed}`);
    }
    if (HEAP_PROF_FINAL) {
      console.log(`   üîç [DRY RUN] Heap profiles would succeed: ${results.heapSuccess}`);
      console.log(`   üîç [DRY RUN] Heap profiles would fail: ${results.heapFailed}`);
    }
    console.log(`   ‚è≠Ô∏è  Skipped: ${results.skipped}`);
  } else {
    if (CPU_PROF_FINAL) {
      console.log(`   ‚úÖ CPU Success: ${results.cpuSuccess}`);
      console.log(`   ‚ùå CPU Failed: ${results.cpuFailed}`);
    }
    if (HEAP_PROF_FINAL) {
      console.log(`   ‚úÖ Heap Success: ${results.heapSuccess}`);
      console.log(`   ‚ùå Heap Failed: ${results.heapFailed}`);
    }
    console.log(`   ‚è≠Ô∏è  Skipped: ${results.skipped}`);
  }
  console.log(`   üìä Total: ${projects.length}`);
  
  if (!DRY_RUN) {
    console.log(`\nüí° Usage:`);
    console.log(`   CPU only:              bun run scripts/generate-all-profiles.ts --cpu-prof`);
    console.log(`   Heap markdown:         bun run scripts/generate-all-profiles.ts (default)`);
    console.log(`   Heap V8 snapshot:      bun run scripts/generate-all-profiles.ts --heap-format=v8`);
    console.log(`   Heap both formats:     bun run scripts/generate-all-profiles.ts --heap-format=both`);
    console.log(`   Both CPU + Heap:       bun run scripts/generate-all-profiles.ts --both`);
    console.log(`   Custom output dir:     bun run scripts/generate-all-profiles.ts --heap-prof-dir=./profiles`);
    console.log(`   Dry run:               bun run scripts/generate-all-profiles.ts --dry-run`);
    console.log(`\n   Examples:`);
    console.log(`   # Generate V8 snapshots in ./profiles:`);
    console.log(`   bun run scripts/generate-all-profiles.ts --heap-format=v8 --heap-prof-dir=./profiles`);
    console.log(`   # Generate both markdown and V8 formats:`);
    console.log(`   bun run scripts/generate-all-profiles.ts --heap-format=both`);
  }
    
    // Ensure we're back in original directory
    try {
      process.chdir(originalCwd);
    } catch (e) {
      // Ignore if we can't change back
    }
  } catch (error) {
    // Ensure we're back in original directory even on fatal error
    try {
      process.chdir(originalCwd);
    } catch (e) {
      // Ignore if we can't change back
    }
    
    const profilingError = handleProfilingError(
      error,
      ProfilingErrorCode.PROFILE_GENERATION_FAILED,
      { phase: 'main-execution' }
    );
    console.error(`\n‚ùå Fatal error:`);
    profilingError.log();
    process.exit(1);
  }
}

if (import.meta.main) {
  await main();
}
