#!/usr/bin/env bun

/**
 * üéØ Enhanced WikiMode System with Barbershop Integration
 * 
 * A comprehensive wiki template management system that integrates with the Barbershop
 * demo ecosystem to provide advanced wiki generation, profiling, and management capabilities.
 */

// Mock MCPWikiGenerator for demo purposes
class MCPWikiGenerator {
  static getWikiTemplates(): WikiTemplate[] {
    return [
      {
        name: 'Confluence Integration',
        description: 'Integration template for Confluence wiki pages',
        format: 'markdown',
        workspace: 'enterprise',
        examples: true,
        sections: 8,
        useCase: 'Enterprise documentation',
        complexity: 'Advanced',
        integration: 'Confluence API',
      },
      {
        name: 'GitHub Wiki',
        description: 'GitHub wiki template for project documentation',
        format: 'markdown',
        workspace: 'github',
        examples: true,
        sections: 6,
        useCase: 'Open source projects',
        complexity: 'Medium',
        integration: 'GitHub API',
      },
      {
        name: 'Notion Sync',
        description: 'Notion workspace synchronization template',
        format: 'html',
        workspace: 'notion',
        examples: false,
        sections: 5,
        useCase: 'Team collaboration',
        complexity: 'Simple',
        integration: 'Notion API',
      },
      {
        name: 'Internal Docs Portal',
        description: 'Internal documentation portal template',
        format: 'html',
        workspace: 'internal',
        examples: true,
        sections: 10,
        useCase: 'Internal knowledge base',
        complexity: 'Advanced',
        integration: 'Custom API',
      },
      {
        name: 'API Reference',
        description: 'API documentation template with examples',
        format: 'markdown',
        workspace: 'api',
        examples: true,
        sections: 7,
        useCase: 'API documentation',
        complexity: 'Medium',
        integration: 'OpenAPI/Swagger',
      },
    ];
  }

  async generateWiki(template: WikiTemplate, customData?: any): Promise<{ content: string }> {
    const { name, description, sections } = template;
    const content = `# ${customData?.title || name}

${description}

## Sections (${sections})

${Array.from({ length: sections }, (_, i) => `
### Section ${i + 1}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

**Features:**
- Advanced wiki generation
- Barbershop integration
- Performance profiling
- Collaborative editing

**Integration Points:**
- Dashboard widgets
- Analytics tracking
- Real-time synchronization
`).join('')}

---

*Generated by Enhanced WikiMode with Barbershop Integration*
*Generated at: ${new Date().toISOString()}*
`;

    return { content };
  }
}

// Mock other dependencies for demo
const mockWikiProfile = async (file: string) => ({
  performance: {
    generationTime: Math.random() * 200 + 50,
    optimizationScore: Math.floor(Math.random() * 30) + 70,
  },
  content: {
    wordCount: Math.floor(Math.random() * 1000) + 200,
    sectionCount: Math.floor(Math.random() * 10) + 3,
  },
});

const mockJuniorProfileWithWiki = async (file: string, options: any) => ({
  profile: {
    performance: {
      generationTime: Math.random() * 150 + 30,
      memoryUsage: Math.random() * 50 + 10,
    },
  },
  wikiMode: options.wikiMode,
});

const mockProfileReader = {
  resolveUploaderConfig: () => ({ endpoint: 'localhost', apiKey: 'demo-key' }),
};

// Mock imports for demo
const wikiProfile = mockWikiProfile;
const juniorProfileWithWiki = mockJuniorProfileWithWiki;
const ProfileReader = class {
  constructor(config: any) {}
};
const resolveUploaderConfig = mockProfileReader.resolveUploaderConfig;

import { styled, FW_COLORS, colorBar } from '../lib/theme/colors.ts';
import { EXIT_CODES, exitWithCode } from '../lib/utils/exit-codes.ts';

// Mock Barbershop types for demo
interface BarberRecord {
  id: string;
  name: string;
  code: string;
  skills: string[];
  commissionRate: string;
  status: string;
}

const mockMasterTokenManager = {
  validateToken: () => true,
  generateToken: () => 'demo-token',
};

// Mock master token manager
const masterTokenManager = mockMasterTokenManager;

// Base WikiTemplate interface
interface WikiTemplate {
  name: string;
  description: string;
  format: string;
  workspace: string;
  examples: boolean;
  sections: number;
  useCase: string;
  complexity: 'Simple' | 'Medium' | 'Advanced';
  integration: string;
}

interface EnhancedWikiTemplate extends WikiTemplate {
  // Enhanced template properties
  barbershopIntegration?: {
    enabled: boolean;
    dashboardWidgets?: string[];
    profileIntegration?: boolean;
    analyticsTracking?: boolean;
  };
  performanceMetrics?: {
    generationTime?: number;
    profileData?: any;
    optimizationScore?: number;
  };
  collaboration?: {
    sharedEditing?: boolean;
    versionControl?: boolean;
    realTimeSync?: boolean;
  };
}

interface WikiModeConfig {
  // Core configuration
  templates: EnhancedWikiTemplate[];
  outputPath: string;
  profileMode: boolean;
  barbershopMode: boolean;
  
  // Enhanced features
  realTimeProfiling: boolean;
  collaborativeEditing: boolean;
  performanceOptimization: boolean;
  dashboardIntegration: boolean;
  
  // Barbershop specific
  barbershopEndpoint?: string;
  dashboardWidgets?: string[];
  analyticsEnabled?: boolean;
}

interface WikiGenerationResult {
  template: EnhancedWikiTemplate;
  content: string;
  metadata: {
    generatedAt: string;
    generationTime: number;
    templateUsed: string;
    barbershopIntegration: boolean;
  };
  performance?: {
    profileData?: any;
    optimizationScore?: number;
    recommendations?: string[];
  };
  barbershopData?: {
    dashboardWidgets?: any[];
    analyticsData?: any;
    barberProfiles?: BarberRecord[];
  };
}

class EnhancedWikiMode {
  private config: WikiModeConfig;
  private profileReader: ProfileReader;
  private isRunning = false;
  private cleanupHandlers: (() => void)[] = [];
  private generationHistory: WikiGenerationResult[] = [];

  private constructor(config: WikiModeConfig) {
    this.config = config;
    this.profileReader = new ProfileReader(resolveUploaderConfig());
    this.setupExitHandlers();
  }

  static async create(config: Partial<WikiModeConfig> = {}): Promise<EnhancedWikiMode> {
    const defaultConfig: WikiModeConfig = {
      templates: await EnhancedWikiMode.loadEnhancedTemplates(),
      outputPath: './wiki-output',
      profileMode: true,
      barbershopMode: true,
      realTimeProfiling: true,
      collaborativeEditing: true,
      performanceOptimization: true,
      dashboardIntegration: true,
      barbershopEndpoint: 'http://localhost:3000',
      dashboardWidgets: ['analytics', 'performance', 'collaboration'],
      analyticsEnabled: true,
    };

    const wikiMode = new EnhancedWikiMode({ ...defaultConfig, ...config });
    return wikiMode;
  }

  private static async loadEnhancedTemplates(): Promise<EnhancedWikiTemplate[]> {
    const baseTemplates = MCPWikiGenerator.getWikiTemplates();
    
    return baseTemplates.map(template => ({
      ...template,
      barbershopIntegration: {
        enabled: true,
        dashboardWidgets: ['wiki-stats', 'template-performance', 'collaboration-metrics'],
        profileIntegration: true,
        analyticsTracking: true,
      },
      performanceMetrics: {
        generationTime: 0,
        optimizationScore: 85,
      },
      collaboration: {
        sharedEditing: true,
        versionControl: true,
        realTimeSync: true,
      },
    }));
  }

  private setupExitHandlers(): void {
    const cleanup = () => {
      if (this.isRunning) {
        console.log(styled('\nüëã Shutting down Enhanced WikiMode...', 'muted'));
        this.cleanup();
        exitWithCode(EXIT_CODES.SUCCESS);
      }
    };

    process.on('SIGINT', cleanup);
    process.on('SIGTERM', cleanup);
    this.cleanupHandlers.push(cleanup);
  }

  private cleanup(): void {
    this.cleanupHandlers.forEach(handler => {
      try {
        handler();
      } catch (error) {
        console.error(styled('Cleanup error:', 'error'), error);
      }
    });
    this.cleanupHandlers = [];
    this.isRunning = false;
  }

  /**
   * Generate wiki content with enhanced features and Barbershop integration
   */
  async generateWiki(templateName: string, customData?: any): Promise<WikiGenerationResult> {
    const startTime = performance.now();
    
    try {
      const template = this.config.templates.find(t => t.name === templateName);
      if (!template) {
        throw new Error(`Template "${templateName}" not found`);
      }

      console.log(styled(`üîß Generating wiki using template: ${templateName}`, 'info'));

      // Base wiki generation
      const generator = new MCPWikiGenerator();
      const baseResult = await generator.generateWiki(template, customData);

      // Enhanced features
      let profileData = null;
      let barbershopData = null;

      if (this.config.profileMode) {
        console.log(styled('üìä Running performance profile...', 'muted'));
        profileData = await this.runPerformanceProfile(baseResult.content);
      }

      if (this.config.barbershopMode) {
        console.log(styled('üèóÔ∏è Integrating with Barbershop system...', 'muted'));
        barbershopData = await this.integrateWithBarbershop(template, baseResult.content);
      }

      const generationTime = performance.now() - startTime;

      const result: WikiGenerationResult = {
        template,
        content: baseResult.content,
        metadata: {
          generatedAt: new Date().toISOString(),
          generationTime,
          templateUsed: templateName,
          barbershopIntegration: this.config.barbershopMode,
        },
        performance: profileData ? {
          profileData,
          optimizationScore: this.calculateOptimizationScore(profileData),
          recommendations: this.generateOptimizationRecommendations(profileData),
        } : undefined,
        barbershopData,
      };

      // Store in history
      this.generationHistory.push(result);
      
      console.log(styled(`‚úÖ Wiki generated in ${generationTime.toFixed(2)}ms`, 'success'));
      return result;

    } catch (error) {
      console.error(styled('‚ùå Wiki generation failed:', 'error'), error);
      throw error;
    }
  }

  /**
   * Run performance profiling on generated content
   */
  private async runPerformanceProfile(content: string): Promise<any> {
    try {
      // Create temporary file for profiling
      const tempFile = `${this.config.outputPath}/temp-profile-${Date.now()}.md`;
      await Bun.write(tempFile, content);

      // Run wiki profiler
      const profileResult = await wikiProfile(tempFile);
      
      // Clean up temp file
      try {
        const tempFileObj = Bun.file(tempFile);
        if (await tempFileObj.exists()) {
          await Bun.write(tempFile, ''); // Clear the file content
        }
      } catch (error) {
        // Ignore cleanup errors
      }

      return profileResult;
    } catch (error) {
      console.warn(styled('Profile analysis failed:', 'warning'), error);
      return null;
    }
  }

  /**
   * Integrate with Barbershop system
   */
  private async integrateWithBarbershop(template: EnhancedWikiTemplate, content: string): Promise<any> {
    try {
      const barbershopData: any = {};

      // Dashboard widgets integration
      if (template.barbershopIntegration?.dashboardWidgets) {
        barbershopData.dashboardWidgets = await this.generateDashboardWidgets(
          template.barbershopIntegration.dashboardWidgets,
          content
        );
      }

      // Analytics data
      if (this.config.analyticsEnabled) {
        barbershopData.analyticsData = await this.generateAnalyticsData(content);
      }

      // Mock barber profiles (in real implementation, this would fetch from Barbershop API)
      barbershopData.barberProfiles = await this.fetchBarberProfiles();

      return barbershopData;
    } catch (error) {
      console.warn(styled('Barbershop integration failed:', 'warning'), error);
      return null;
    }
  }

  /**
   * Generate dashboard widgets for Barbershop integration
   */
  private async generateDashboardWidgets(widgets: string[], content: string): Promise<any[]> {
    return widgets.map(widgetType => {
      switch (widgetType) {
        case 'wiki-stats':
          return {
            type: 'wiki-stats',
            title: 'Wiki Statistics',
            data: {
              wordCount: content.split(/\s+/).length,
              sectionCount: (content.match(/^#+\s/gm) || []).length,
              linkCount: (content.match(/\[.*?\]\(.*?\)/g) || []).length,
              lastUpdated: new Date().toISOString(),
            },
          };

        case 'template-performance':
          return {
            type: 'template-performance',
            title: 'Template Performance',
            data: {
              renderTime: Math.random() * 100, // Mock performance data
              optimizationScore: 85 + Math.random() * 15,
              recommendations: ['Optimize image sizes', 'Minify CSS'],
            },
          };

        case 'collaboration-metrics':
          return {
            type: 'collaboration-metrics',
            title: 'Collaboration Metrics',
            data: {
              activeContributors: Math.floor(Math.random() * 10) + 1,
              recentEdits: Math.floor(Math.random() * 50) + 10,
              averageResponseTime: Math.floor(Math.random() * 3600) + 300, // seconds
            },
          };

        default:
          return {
            type: 'generic',
            title: widgetType,
            data: {},
          };
      }
    });
  }

  /**
   * Generate analytics data for the content
   */
  private async generateAnalyticsData(content: string): Promise<any> {
    return {
      contentMetrics: {
        readabilityScore: 75 + Math.random() * 25,
        complexityScore: 30 + Math.random() * 70,
        engagementPrediction: 60 + Math.random() * 40,
      },
      seoMetrics: {
        titleOptimization: 80 + Math.random() * 20,
        metaDescriptionLength: content.length > 160 ? 'optimal' : 'needs-improvement',
        keywordDensity: Math.random() * 5,
      },
      performanceMetrics: {
        loadTimePrediction: Math.random() * 2000, // ms
        sizeOptimization: 70 + Math.random() * 30,
        cacheEfficiency: 80 + Math.random() * 20,
      },
    };
  }

  /**
   * Fetch barber profiles from Barbershop system
   */
  private async fetchBarberProfiles(): Promise<BarberRecord[]> {
    // Mock data - in real implementation, this would fetch from Barbershop API
    return [
      {
        id: '1',
        name: 'Master Barber',
        code: 'MB001',
        skills: ['wiki-editing', 'content-curation', 'template-design'],
        commissionRate: '15%',
        status: 'active',
      },
      {
        id: '2',
        name: 'Content Specialist',
        code: 'CS002',
        skills: ['markdown', 'documentation', 'technical-writing'],
        commissionRate: '12%',
        status: 'active',
      },
    ];
  }

  /**
   * Calculate optimization score based on profile data
   */
  private calculateOptimizationScore(profileData: any): number {
    if (!profileData) return 50;

    let score = 50;
    
    // Add points for various metrics
    if (profileData.performance?.generationTime < 100) score += 20;
    if (profileData.content?.wordCount > 500) score += 10;
    if (profileData.structure?.sectionCount > 5) score += 10;
    if (profileData.links?.internalLinks > 3) score += 10;

    return Math.min(100, score);
  }

  /**
   * Generate optimization recommendations
   */
  private generateOptimizationRecommendations(profileData: any): string[] {
    const recommendations: string[] = [];

    if (!profileData) return recommendations;

    if (profileData.performance?.generationTime > 200) {
      recommendations.push('Consider optimizing template for faster generation');
    }

    if (profileData.content?.wordCount < 300) {
      recommendations.push('Add more comprehensive content');
    }

    if (profileData.structure?.sectionCount < 3) {
      recommendations.push('Improve document structure with more sections');
    }

    if (profileData.links?.internalLinks < 2) {
      recommendations.push('Add more internal links for better navigation');
    }

    return recommendations;
  }

  /**
   * Display enhanced wiki matrix dashboard
   */
  async displayEnhancedMatrix(): Promise<void> {
    console.log(styled('\nüèóÔ∏è Enhanced WikiMode - Barbershop Integration Dashboard', 'enterprise'));
    console.log(colorBar('enterprise', 60));

    // Display templates with enhanced information
    const tableData = this.config.templates.map(template => ({
      'Template Name': styled(template.name, 'success'),
      'Format': styled(template.format, 'info'),
      'Workspace': styled(template.workspace, 'muted'),
      'Barbershop': template.barbershopIntegration?.enabled ? styled('‚úÖ', 'success') : styled('‚ùå', 'error'),
      'Profiling': template.barbershopIntegration?.profileIntegration ? styled('‚úÖ', 'success') : styled('‚ùå', 'error'),
      'Analytics': template.barbershopIntegration?.analyticsTracking ? styled('‚úÖ', 'success') : styled('‚ùå', 'error'),
      'Collaboration': template.collaboration?.sharedEditing ? styled('‚úÖ', 'success') : styled('‚ùå', 'error'),
    }));

    console.log(Bun.inspect.table(tableData));
    console.log('');

    // Display generation history
    if (this.generationHistory.length > 0) {
      console.log(styled('üìä Recent Generation History:', 'info'));
      const historyData = this.generationHistory.slice(-5).map((result, index) => ({
        '#': index + 1,
        'Template': result.template.name,
        'Time': `${result.metadata.generationTime.toFixed(2)}ms`,
        'Barbershop': result.metadata.barbershopIntegration ? styled('‚úÖ', 'success') : styled('‚ùå', 'error'),
        'Score': result.performance?.optimizationScore ? `${result.performance.optimizationScore}%` : 'N/A',
      }));

      console.log(Bun.inspect.table(historyData));
      console.log('');
    }

    // Display configuration
    console.log(styled('‚öôÔ∏è Configuration:', 'info'));
    console.log(`  Profile Mode: ${this.config.profileMode ? styled('Enabled', 'success') : styled('Disabled', 'error')}`);
    console.log(`  Barbershop Mode: ${this.config.barbershopMode ? styled('Enabled', 'success') : styled('Disabled', 'error')}`);
    console.log(`  Real-time Profiling: ${this.config.realTimeProfiling ? styled('Enabled', 'success') : styled('Disabled', 'error')}`);
    console.log(`  Collaborative Editing: ${this.config.collaborativeEditing ? styled('Enabled', 'success') : styled('Disabled', 'error')}`);
    console.log(`  Analytics: ${this.config.analyticsEnabled ? styled('Enabled', 'success') : styled('Disabled', 'error')}`);
    console.log('');
  }

  /**
   * Run interactive mode with enhanced features
   */
  async runInteractiveMode(): Promise<void> {
    console.log(styled('\nüéØ Enhanced WikiMode Interactive Mode', 'enterprise'));
    console.log(styled('Type "help" for commands or "exit" to quit', 'muted'));

    this.isRunning = true;

    while (this.isRunning) {
      try {
        // Dynamic import for readline
        const { createInterface } = await import('node:readline/promises');
        const rl = createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        const answer = await rl.question(styled('\nwikimode> ', 'enterprise'));
        rl.close();

        const [command, ...args] = answer.trim().split(' ');

        switch (command.toLowerCase()) {
          case 'help':
            this.displayHelp();
            break;

          case 'list':
            await this.displayEnhancedMatrix();
            break;

          case 'generate':
            if (args.length === 0) {
              console.log(styled('Usage: generate <template-name>', 'warning'));
              break;
            }
            await this.generateAndDisplay(args[0]);
            break;

          case 'profile':
            if (args.length === 0) {
              console.log(styled('Usage: profile <template-name>', 'warning'));
              break;
            }
            await this.generateWithProfile(args[0]);
            break;

          case 'barbershop':
            await this.showBarbershopIntegration();
            break;

          case 'history':
            this.showGenerationHistory();
            break;

          case 'export':
            await this.exportResults(args[0]);
            break;

          case 'exit':
          case 'quit':
            this.isRunning = false;
            break;

          default:
            if (command) {
              console.log(styled(`Unknown command: ${command}`, 'error'));
              console.log(styled('Type "help" for available commands', 'muted'));
            }
        }
      } catch (error) {
        console.error(styled('Command error:', 'error'), error);
      }
    }

    this.cleanup();
  }

  private displayHelp(): void {
    console.log(styled('\nüìö Enhanced WikiMode Commands:', 'info'));
    console.log(styled('  help                    Show this help message', 'muted'));
    console.log(styled('  list                    Display enhanced template matrix', 'muted'));
    console.log(styled('  generate <template>     Generate wiki content', 'muted'));
    console.log(styled('  profile <template>      Generate with performance profiling', 'muted'));
    console.log(styled('  barbershop              Show Barbershop integration status', 'muted'));
    console.log(styled('  history                 Show generation history', 'muted'));
    console.log(styled('  export [format]         Export results (json|markdown|html)', 'muted'));
    console.log(styled('  exit                    Exit interactive mode', 'muted'));
    console.log('');
  }

  private async generateAndDisplay(templateName: string): Promise<void> {
    try {
      const result = await this.generateWiki(templateName);
      
      console.log(styled('\nüìÑ Generated Content Preview:', 'success'));
      console.log(colorBar('success', 40));
      
      // Show first 500 characters of content
      const preview = result.content.substring(0, 500) + (result.content.length > 500 ? '...' : '');
      console.log(preview);
      console.log('');

      // Show metadata
      console.log(styled('üìä Metadata:', 'info'));
      console.log(`  Generated: ${result.metadata.generatedAt}`);
      console.log(`  Time: ${result.metadata.generationTime.toFixed(2)}ms`);
      console.log(`  Barbershop Integration: ${result.metadata.barbershopIntegration ? 'Yes' : 'No'}`);
      
      if (result.performance) {
        console.log(`  Optimization Score: ${result.performance.optimizationScore}%`);
      }
    } catch (error) {
      console.error(styled('Generation failed:', 'error'), error);
    }
  }

  private async generateWithProfile(templateName: string): Promise<void> {
    try {
      const result = await this.generateWiki(templateName);
      
      console.log(styled('\nüìä Performance Profile Results:', 'info'));
      console.log(colorBar('info', 40));

      if (result.performance) {
        console.log(`Optimization Score: ${result.performance.optimizationScore}%`);
        
        if (result.performance.recommendations.length > 0) {
          console.log(styled('\nüí° Recommendations:', 'warning'));
          result.performance.recommendations.forEach(rec => {
            console.log(`  ‚Ä¢ ${rec}`);
          });
        }
      }

      if (result.barbershopData) {
        console.log(styled('\nüèóÔ∏è Barbershop Integration:', 'success'));
        console.log(`  Dashboard Widgets: ${result.barbershopData.dashboardWidgets?.length || 0}`);
        console.log(`  Analytics Data: ${result.barbershopData.analyticsData ? 'Available' : 'N/A'}`);
        console.log(`  Barber Profiles: ${result.barbershopData.barberProfiles?.length || 0}`);
      }
    } catch (error) {
      console.error(styled('Profile generation failed:', 'error'), error);
    }
  }

  private async showBarbershopIntegration(): Promise<void> {
    console.log(styled('\nüèóÔ∏è Barbershop Integration Status:', 'info'));
    console.log(colorBar('enterprise', 50));
    
    console.log(`Endpoint: ${this.config.barbershopEndpoint || 'Not configured'}`);
    console.log(`Dashboard Widgets: ${this.config.dashboardWidgets?.join(', ') || 'None'}`);
    console.log(`Analytics: ${this.config.analyticsEnabled ? 'Enabled' : 'Disabled'}`);
    console.log(`Mode: ${this.config.barbershopMode ? 'Active' : 'Inactive'}`);
    console.log('');

    // Show template integration status
    console.log(styled('Template Integration Status:', 'muted'));
    const integrationData = this.config.templates.map(template => ({
      'Template': template.name,
      'Enabled': template.barbershopIntegration?.enabled ? styled('‚úÖ', 'success') : styled('‚ùå', 'error'),
      'Widgets': template.barbershopIntegration?.dashboardWidgets?.length || 0,
      'Analytics': template.barbershopIntegration?.analyticsTracking ? styled('‚úÖ', 'success') : styled('‚ùå', 'error'),
    }));

    console.log(Bun.inspect.table(integrationData));
  }

  private showGenerationHistory(): void {
    console.log(styled('\nüìú Generation History:', 'info'));
    console.log(colorBar('muted', 40));

    if (this.generationHistory.length === 0) {
      console.log(styled('No generation history yet', 'muted'));
      return;
    }

    const historyData = this.generationHistory.map((result, index) => ({
      '#': index + 1,
      'Template': result.template.name,
      'Time': `${result.metadata.generationTime.toFixed(2)}ms`,
      'Barbershop': result.metadata.barbershopIntegration ? 'Yes' : 'No',
      'Score': result.performance?.optimizationScore ? `${result.performance.optimizationScore}%` : 'N/A',
      'Generated': new Date(result.metadata.generatedAt).toLocaleTimeString(),
    }));

    console.log(Bun.inspect.table(historyData));
  }

  private async exportResults(format: string = 'json'): Promise<void> {
    if (this.generationHistory.length === 0) {
      console.log(styled('No results to export', 'warning'));
      return;
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    let filename: string;
    let content: string;

    switch (format.toLowerCase()) {
      case 'json':
        filename = `${this.config.outputPath}/wiki-export-${timestamp}.json`;
        content = JSON.stringify(this.generationHistory, null, 2);
        break;

      case 'markdown':
        filename = `${this.config.outputPath}/wiki-export-${timestamp}.md`;
        content = this.generateMarkdownExport();
        break;

      case 'html':
        filename = `${this.config.outputPath}/wiki-export-${timestamp}.html`;
        content = this.generateHtmlExport();
        break;

      default:
        console.log(styled('Unsupported format. Use: json, markdown, or html', 'error'));
        return;
    }

    try {
      await Bun.write(filename, content);
      console.log(styled(`‚úÖ Exported to ${filename}`, 'success'));
    } catch (error) {
      console.error(styled('Export failed:', 'error'), error);
    }
  }

  private generateMarkdownExport(): string {
    let markdown = '# Enhanced WikiMode Export\n\n';
    markdown += `Generated: ${new Date().toISOString()}\n\n`;

    this.generationHistory.forEach((result, index) => {
      markdown += `## ${index + 1}. ${result.template.name}\n\n`;
      markdown += `**Generated:** ${result.metadata.generatedAt}\n`;
      markdown += `**Time:** ${result.metadata.generationTime.toFixed(2)}ms\n`;
      markdown += `**Barbershop Integration:** ${result.metadata.barbershopIntegration ? 'Yes' : 'No'}\n\n`;

      if (result.performance) {
        markdown += `**Optimization Score:** ${result.performance.optimizationScore}%\n\n`;
      }

      markdown += '### Content Preview\n\n';
      markdown += result.content.substring(0, 500) + '...\n\n';
      markdown += '---\n\n';
    });

    return markdown;
  }

  private generateHtmlExport(): string {
    let html = `
<!DOCTYPE html>
<html>
<head>
    <title>Enhanced WikiMode Export</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }
        .header { border-bottom: 2px solid #e0e0e0; padding-bottom: 20px; margin-bottom: 30px; }
        .result { border: 1px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 20px; }
        .metadata { background: #f5f5f5; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .content { background: #fafafa; padding: 15px; border-radius: 4px; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Enhanced WikiMode Export</h1>
        <p>Generated: ${new Date().toISOString()}</p>
    </div>
`;

    this.generationHistory.forEach((result, index) => {
      html += `
    <div class="result">
        <h2>${index + 1}. ${result.template.name}</h2>
        <div class="metadata">
            <strong>Generated:</strong> ${result.metadata.generatedAt}<br>
            <strong>Time:</strong> ${result.metadata.generationTime.toFixed(2)}ms<br>
            <strong>Barbershop Integration:</strong> ${result.metadata.barbershopIntegration ? 'Yes' : 'No'}
        </div>
        <div class="content">${result.content.substring(0, 500)}...</div>
    </div>
`;
    });

    html += '</body></html>';
    return html;
  }
}

// CLI execution
async function main() {
  try {
    const args = process.argv.slice(2);
    const command = args[0];

    const wikiMode = await EnhancedWikiMode.create();

    switch (command) {
      case 'interactive':
      case 'i':
        await wikiMode.runInteractiveMode();
        break;

      case 'list':
      case 'l':
        await wikiMode.displayEnhancedMatrix();
        break;

      case 'generate':
      case 'g':
        if (args.length < 2) {
          console.error(styled('Usage: bun run enhanced-wikimode.ts generate <template-name>', 'error'));
          process.exit(1);
        }
        await wikiMode.generateAndDisplay(args[1]);
        break;

      case 'profile':
      case 'p':
        if (args.length < 2) {
          console.error(styled('Usage: bun run enhanced-wikimode.ts profile <template-name>', 'error'));
          process.exit(1);
        }
        await wikiMode.generateWithProfile(args[1]);
        break;

      case 'help':
      case 'h':
        console.log(styled('üéØ Enhanced WikiMode - Barbershop Integration', 'enterprise'));
        console.log('');
        console.log(styled('Usage:', 'info'));
        console.log('  bun run enhanced-wikimode.ts <command> [options]');
        console.log('');
        console.log(styled('Commands:', 'info'));
        console.log('  interactive, i          Start interactive mode');
        console.log('  list, l                 Display enhanced template matrix');
        console.log('  generate, g <template>  Generate wiki content');
        console.log('  profile, p <template>   Generate with performance profiling');
        console.log('  help, h                 Show this help');
        console.log('');
        break;

      default:
        console.log(styled('üéØ Enhanced WikiMode - Barbershop Integration', 'enterprise'));
        console.log(styled('Starting interactive mode...', 'info'));
        await wikiMode.runInteractiveMode();
        break;
    }
  } catch (error) {
    console.error(styled('‚ùå Enhanced WikiMode failed:', 'error'), error);
    process.exit(1);
  }
}

if (import.meta.main) {
  main();
}

export { EnhancedWikiMode, type WikiModeConfig, type WikiGenerationResult, type EnhancedWikiTemplate };
