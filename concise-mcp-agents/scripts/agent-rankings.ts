#!/usr/bin/env bun

// [AGENT][LIST][FULL][AGENT-LIST-001][v2.8][ACTIVE]

// [DATAPIPE][CORE][DA-CO-86C][v2.8.0][ACTIVE]

import { fetchData, aggregateAgents } from "./datapipe.ts";
import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

interface AgentRanking {
  rank: number;
  agent: string;
  profit: number;
  roi: number;
  bets: number;
  winRate: number;
  volume: number;
  avgBet: number;
  lastBet?: string;
}

class AgentRankingsSystem {
  private rankings: AgentRanking[] = [];
  private lastUpdate: Date = new Date();

  async generateRankings(state?: string): Promise<AgentRanking[]> {
    console.log(`üìä Generating live agent rankings...`);

    try {
      // Fetch data from datapipe
      const rawData = await fetchData(state);
      const agentStats = aggregateAgents(rawData);

      // Convert to rankings format
      this.rankings = agentStats.map((agent, index) => ({
        rank: index + 1,
        agent: agent.name,
        profit: Math.round(agent.stats.profit * 100) / 100,
        roi: agent.stats.bets > 0 ? Math.round((agent.stats.profit / agent.stats.volume) * 10000) / 100 : 0,
        bets: agent.stats.bets,
        winRate: agent.stats.winrate,
        volume: Math.round(agent.stats.volume * 100) / 100,
        avgBet: agent.stats.bets > 0 ? Math.round((agent.stats.volume / agent.stats.bets) * 100) / 100 : 0
      }));

      this.lastUpdate = new Date();

      console.log(`‚úÖ Generated rankings for ${this.rankings.length} agents`);
      return this.rankings;

    } catch (error) {
      console.error(`‚ùå Failed to generate rankings: ${error.message}`);
      return [];
    }
  }

  formatTable(rankings: AgentRanking[], limit: number = 50): string {
    const header = '| Rank | Agent | Profit | ROI | Bets | Win% |\n|----------|-----------|------------|---------|----------|----------|';

    const rows = rankings.slice(0, limit).map(agent =>
      `| **${agent.rank}** | **${agent.agent}** | **$${agent.profit.toLocaleString()}** | **${agent.roi}%** | ${agent.bets.toLocaleString()} | **${agent.winRate}%** |`
    );

    if (rankings.length > limit) {
      rows.push(`| ... | **${rankings.length - limit}+** | **Total $${rankings.reduce((sum, a) => sum + a.profit, 0).toLocaleString()}** | **${(rankings.reduce((sum, a) => sum + a.profit, 0) / rankings.reduce((sum, a) => sum + a.volume, 0) * 100).toFixed(1)}%** | **${rankings.reduce((sum, a) => sum + a.bets, 0).toLocaleString()}** | **${(rankings.reduce((sum, a) => sum + a.bets * a.winRate, 0) / rankings.reduce((sum, a) => sum + a.bets, 0)).toFixed(1)}%** |`);
    }

    return `${header}\n${rows.join('\n')}`;
  }

  formatDetailedTable(rankings: AgentRanking[], limit: number = 20): string {
    const header = '| Rank | Agent | Profit | Volume | Avg Bet | Bets | Win% | ROI |\n|----------|-----------|------------|------------|---------|----------|----------|---------|';

    const rows = rankings.slice(0, limit).map(agent =>
      `| ${agent.rank} | **${agent.agent}** | **$${agent.profit.toLocaleString()}** | $${agent.volume.toLocaleString()} | $${agent.avgBet} | ${agent.bets} | ${agent.winRate}% | ${agent.roi}% |`
    );

    return `${header}\n${rows.join('\n')}`;
  }

  getTopAgents(count: number = 5): AgentRanking[] {
    return this.rankings.slice(0, count);
  }

  getAgentStats(agentName: string): AgentRanking | null {
    return this.rankings.find(agent =>
      agent.agent.toLowerCase() === agentName.toLowerCase()
    ) || null;
  }

  async exportToMarkdown(filename?: string): Promise<string> {
    const rankings = await this.generateRankings();
    const timestamp = this.lastUpdate.toISOString().slice(0, 16).replace('T', ' ');

    const content = `# [AGENT][RANKINGS][LIVE][AGENT-RANK-001][v2.8][ACTIVE]

**üöÄ LIVE AGENTS ‚Äì From Datapipe *Top 50 ranked. Profit leaders. Last updated: ${timestamp}***

${this.formatTable(rankings)}

---

## üìä Detailed Rankings (Top 20)

${this.formatDetailedTable(rankings)}

---

## üèÜ Top Performers Summary

${this.generateSummary(rankings)}

---

## üìà Performance Heatmap

${this.generateHeatmap(rankings)}

---

*Generated by Agent Rankings System v2.8 ‚Ä¢ Live data from Datapipe API*
`;

    if (filename) {
      const vaultPath = process.env.OBSIDIAN_VAULT || process.cwd();
      const outputPath = join(vaultPath, 'dashboards', filename);

      try {
        mkdirSync(join(vaultPath, 'dashboards'), { recursive: true });
        writeFileSync(outputPath, content);
        console.log(`üìÑ Exported rankings to: ${outputPath}`);
      } catch (error) {
        console.error(`‚ùå Failed to export: ${error.message}`);
      }
    }

    return content;
  }

  private generateSummary(rankings: AgentRanking[]): string {
    const totalProfit = rankings.reduce((sum, a) => sum + a.profit, 0);
    const totalVolume = rankings.reduce((sum, a) => sum + a.volume, 0);
    const totalBets = rankings.reduce((sum, a) => sum + a.bets, 0);
    const avgWinRate = rankings.reduce((sum, a) => sum + a.winRate, 0) / rankings.length;

    return `### Overall Statistics
- **Total Agents:** ${rankings.length}
- **Total Profit:** $${totalProfit.toLocaleString()}
- **Total Volume:** $${totalVolume.toLocaleString()}
- **Total Bets:** ${totalBets.toLocaleString()}
- **Average Win Rate:** ${avgWinRate.toFixed(1)}%
- **Average ROI:** ${(totalProfit / totalVolume * 100).toFixed(1)}%

### Top 3 Leaders
${rankings.slice(0, 3).map((agent, i) =>
  `${i + 1}. **${agent.agent}** - $${agent.profit.toLocaleString()} profit (${agent.roi}% ROI)`
).join('\n')}`;
  }

  private generateHeatmap(rankings: AgentRanking[]): string {
    // Create a simple text-based heatmap
    const tiers = [
      { name: 'Elite', minProfit: 5000, color: 'üî•' },
      { name: 'Pro', minProfit: 1000, color: '‚≠ê' },
      { name: 'Solid', minProfit: 100, color: '‚úÖ' },
      { name: 'Developing', minProfit: -100, color: 'üìà' },
      { name: 'Challenging', minProfit: -1000, color: '‚ö†Ô∏è' },
      { name: 'Critical', minProfit: -10000, color: 'üö®' }
    ];

    let heatmap = '';
    for (const tier of tiers) {
      const agents = rankings.filter(a => a.profit >= tier.minProfit);
      if (agents.length > 0) {
        heatmap += `**${tier.color} ${tier.name} ($${tier.minProfit.toLocaleString()}+):** ${agents.length} agents\n`;
      }
    }

    return heatmap;
  }

  async getTelegramSummary(): Promise<string> {
    const rankings = await this.generateRankings();
    const top3 = rankings.slice(0, 3);
    const totalProfit = rankings.reduce((sum, a) => sum + a.profit, 0);

    return `üèÜ *Top 3 Agents:*
${top3.map((a, i) => `${i + 1}. ${a.agent}: $${a.profit.toLocaleString()} (${a.roi}% ROI)`).join('\n')}

üìä *Overall:* ${rankings.length} agents, $${totalProfit.toLocaleString()} total profit

_Last updated: ${this.lastUpdate.toLocaleTimeString()}_`;
  }
}

// CLI Interface
async function main() {
  const rankings = new AgentRankingsSystem();
  const command = process.argv[2];

  switch (command) {
    case 'list':
      const limit = parseInt(process.argv[3]) || 50;
      const agents = await rankings.generateRankings();
      console.log(`\nüöÄ LIVE AGENTS ‚Äì From Datapipe *Top ${limit} ranked. Profit leaders.*\n`);
      console.log(rankings.formatTable(agents, limit));
      break;

    case 'top':
      const topCount = parseInt(process.argv[3]) || 5;
      const topAgents = await rankings.generateRankings();
      console.log(`üèÜ TOP ${topCount} AGENTS:`);
      topAgents.slice(0, topCount).forEach((agent, i) => {
        console.log(`${i + 1}. ${agent.agent}: +$${agent.profit.toLocaleString()} (${agent.winRate}% win, ${agent.roi}% ROI) - ${agent.bets} bets`);
      });
      break;

    case 'export':
      const filename = process.argv[3] || 'agent-rankings.md';
      await rankings.exportToMarkdown(filename);
      break;

    case 'telegram':
      const summary = await rankings.getTelegramSummary();
      console.log(summary);
      break;

    case 'stats':
      const agentName = process.argv[3];
      if (!agentName) {
        console.log('Usage: bun agents:stats <agent_name>');
        break;
      }

      await rankings.generateRankings();
      const stats = rankings.getAgentStats(agentName);

      if (stats) {
        console.log(`üìä ${agentName} Statistics:`);
        console.log(`   Rank: #${stats.rank}`);
        console.log(`   Profit: $${stats.profit.toLocaleString()}`);
        console.log(`   ROI: ${stats.roi}%`);
        console.log(`   Bets: ${stats.bets}`);
        console.log(`   Win Rate: ${stats.winRate}%`);
        console.log(`   Volume: $${stats.volume.toLocaleString()}`);
        console.log(`   Avg Bet: $${stats.avgBet}`);
      } else {
        console.log(`‚ùå Agent "${agentName}" not found`);
      }
      break;

    default:
      console.log(`üöÄ Agent Rankings System

USAGE:
  bun agents:list [limit]     # List top agents (default: 50)
  bun agents:top [count]      # Show top N agents (default: 5)
  bun agents:export [file]    # Export to markdown (default: agent-rankings.md)
  bun agents:telegram         # Get Telegram-formatted summary
  bun agents:stats <name>     # Get specific agent statistics

EXAMPLES:
  bun agents:top              # Top 5 agents
  bun agents:list 20          # Top 20 agents table
  bun agents:stats ESPORTS    # ESPORTS agent details
  bun agents:export           # Export rankings to dashboards/
`);
  }
}

// Export for use in other scripts
export { AgentRankingsSystem, type AgentRanking };

// CLI execution
if (import.meta.main) {
  main().catch(console.error);
}
