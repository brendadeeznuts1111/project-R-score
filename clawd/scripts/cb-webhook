#!/usr/bin/env bun
/**
 * cb-webhook - Webhook receiver and event trigger
 * Usage: cb-webhook [--port 18792] [--daemon]
 *
 * Endpoints:
 *   POST /hook/:name     Trigger a named hook
 *   POST /skill/:name    Execute a skill
 *   GET  /status         Server status
 *   GET  /hooks          List registered hooks
 */

const DEFAULT_PORT = 18792;
const HOOKS_FILE = `${Bun.env.HOME}/.clawdbot/hooks.json`;
const LOG_FILE = "/tmp/clawdbot/webhook.log";

interface Hook {
  name: string;
  secret?: string;
  action: "skill" | "command" | "notify";
  target: string;
  enabled: boolean;
  lastTriggered?: string;
  triggerCount: number;
}

interface HooksConfig {
  hooks: Hook[];
}

// Display helpers
const green = (t: string) => `\x1b[32m${t}\x1b[0m`;
const red = (t: string) => `\x1b[31m${t}\x1b[0m`;
const dim = (t: string) => `\x1b[2m${t}\x1b[0m`;

async function loadHooks(): Promise<HooksConfig> {
  try {
    const file = Bun.file(HOOKS_FILE);
    if (await file.exists()) {
      return await file.json();
    }
  } catch {}

  // Default hooks
  return {
    hooks: [
      {
        name: "health",
        action: "command",
        target: "bun ~/clawd/scripts/cb-status --json",
        enabled: true,
        triggerCount: 0
      },
      {
        name: "restart",
        action: "command",
        target: "bun ~/clawd/scripts/cb-restart --soft",
        enabled: true,
        triggerCount: 0
      },
      {
        name: "test",
        action: "command",
        target: "bun ~/clawd/scripts/cb-test --json",
        enabled: true,
        triggerCount: 0
      }
    ]
  };
}

async function saveHooks(config: HooksConfig) {
  await Bun.write(HOOKS_FILE, JSON.stringify(config, null, 2));
}

async function logEvent(event: string, data: any) {
  const line = JSON.stringify({
    time: new Date().toISOString(),
    event,
    ...data
  }) + "\n";

  await Bun.write(LOG_FILE, line, { append: true });
}

async function executeHook(hook: Hook, payload: any): Promise<{ ok: boolean; output?: string; error?: string }> {
  const start = Date.now();

  try {
    if (hook.action === "command") {
      const proc = Bun.spawn(["bash", "-c", hook.target], {
        stdout: "pipe",
        stderr: "pipe",
        env: {
          ...Bun.env,
          WEBHOOK_PAYLOAD: JSON.stringify(payload)
        }
      });

      const [stdout, stderr] = await Promise.all([
        new Response(proc.stdout).text(),
        new Response(proc.stderr).text()
      ]);

      const code = await proc.exited;

      return {
        ok: code === 0,
        output: stdout || stderr
      };
    }

    if (hook.action === "notify") {
      // Send to Telegram via gateway
      const res = await fetch("http://127.0.0.1:18789/api/send", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          message: `Webhook triggered: ${hook.name}\n${JSON.stringify(payload, null, 2)}`
        })
      });

      return { ok: res.ok };
    }

    return { ok: false, error: `Unknown action: ${hook.action}` };
  } catch (err: any) {
    return { ok: false, error: err.message };
  }
}

function createServer(port: number, hooksConfig: HooksConfig) {
  const startTime = Date.now();
  let requestCount = 0;

  return Bun.serve({
    port,
    async fetch(req) {
      const url = new URL(req.url);
      const path = url.pathname;
      const method = req.method;

      requestCount++;

      // CORS headers
      const corsHeaders = {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, X-Webhook-Secret"
      };

      if (method === "OPTIONS") {
        return new Response(null, { headers: corsHeaders });
      }

      // GET /status
      if (path === "/status" && method === "GET") {
        const uptime = Math.round((Date.now() - startTime) / 1000);
        return Response.json({
          ok: true,
          uptime,
          requests: requestCount,
          hooks: hooksConfig.hooks.length,
          enabledHooks: hooksConfig.hooks.filter(h => h.enabled).length
        }, { headers: corsHeaders });
      }

      // GET /hooks
      if (path === "/hooks" && method === "GET") {
        return Response.json({
          hooks: hooksConfig.hooks.map(h => ({
            name: h.name,
            action: h.action,
            enabled: h.enabled,
            triggerCount: h.triggerCount,
            lastTriggered: h.lastTriggered
          }))
        }, { headers: corsHeaders });
      }

      // POST /hook/:name
      if (path.startsWith("/hook/") && method === "POST") {
        const hookName = path.slice(6);
        const hook = hooksConfig.hooks.find(h => h.name === hookName);

        if (!hook) {
          return Response.json({ ok: false, error: "Hook not found" }, { status: 404, headers: corsHeaders });
        }

        if (!hook.enabled) {
          return Response.json({ ok: false, error: "Hook disabled" }, { status: 403, headers: corsHeaders });
        }

        // Check secret if configured
        if (hook.secret) {
          const providedSecret = req.headers.get("X-Webhook-Secret");
          if (providedSecret !== hook.secret) {
            await logEvent("hook_auth_failed", { hook: hookName });
            return Response.json({ ok: false, error: "Invalid secret" }, { status: 401, headers: corsHeaders });
          }
        }

        // Parse payload
        let payload = {};
        try {
          if (req.headers.get("content-type")?.includes("application/json")) {
            payload = await req.json();
          }
        } catch {}

        await logEvent("hook_triggered", { hook: hookName, payload });

        // Execute hook
        const result = await executeHook(hook, payload);

        // Update stats
        hook.triggerCount++;
        hook.lastTriggered = new Date().toISOString();
        await saveHooks(hooksConfig);

        return Response.json({
          ok: result.ok,
          hook: hookName,
          output: result.output,
          error: result.error
        }, { headers: corsHeaders });
      }

      // POST /skill/:name
      if (path.startsWith("/skill/") && method === "POST") {
        const skillName = path.slice(7);
        const skillPath = `${Bun.env.HOME}/clawd/skills/${skillName}.md`;

        const file = Bun.file(skillPath);
        if (!await file.exists()) {
          return Response.json({ ok: false, error: "Skill not found" }, { status: 404, headers: corsHeaders });
        }

        await logEvent("skill_triggered", { skill: skillName });

        // For now, just acknowledge - actual skill execution would go through gateway
        return Response.json({
          ok: true,
          skill: skillName,
          message: "Skill trigger acknowledged"
        }, { headers: corsHeaders });
      }

      // 404
      return Response.json({ ok: false, error: "Not found" }, { status: 404, headers: corsHeaders });
    }
  });
}

async function main() {
  const args = Bun.argv.slice(2);

  const portArg = args.find(a => a.startsWith("--port="));
  const port = portArg ? parseInt(portArg.split("=")[1]) : DEFAULT_PORT;
  const daemonMode = args.includes("--daemon");
  const helpMode = args.includes("--help") || args.includes("-h");

  if (helpMode) {
    console.log(`
  ${green("cb-webhook")} - Webhook receiver and event trigger

  Usage: cb-webhook [options]

  Options:
    --port=PORT   Port to listen on (default: ${DEFAULT_PORT})
    --daemon      Run in background
    --help        Show this help

  Endpoints:
    POST /hook/:name     Trigger a named hook
    POST /skill/:name    Execute a skill
    GET  /status         Server status
    GET  /hooks          List registered hooks

  Configuration:
    Hooks are stored in ~/.clawdbot/hooks.json

  Examples:
    cb-webhook                          # Start on default port
    cb-webhook --port=8080              # Custom port
    curl -X POST localhost:18792/hook/health
    curl localhost:18792/status
`);
    return;
  }

  // Ensure log directory exists
  await Bun.spawn(["mkdir", "-p", "/tmp/clawdbot"]).exited;

  const hooksConfig = await loadHooks();
  await saveHooks(hooksConfig); // Ensure file exists

  console.log("\n┌─────────────────────────────────────────┐");
  console.log("│          CLAWDBOT WEBHOOK               │");
  console.log("└─────────────────────────────────────────┘\n");

  console.log(`  Port:   ${green(String(port))}`);
  console.log(`  Hooks:  ${hooksConfig.hooks.length} configured`);
  console.log(`  Config: ${dim(HOOKS_FILE)}`);
  console.log(`  Log:    ${dim(LOG_FILE)}`);
  console.log();
  console.log("  Endpoints:");
  console.log(`    GET  http://localhost:${port}/status`);
  console.log(`    GET  http://localhost:${port}/hooks`);
  console.log(`    POST http://localhost:${port}/hook/:name`);
  console.log();

  for (const hook of hooksConfig.hooks) {
    const status = hook.enabled ? green("●") : dim("○");
    console.log(`    ${status} /hook/${hook.name} → ${hook.action}:${hook.target.slice(0, 40)}${hook.target.length > 40 ? "..." : ""}`);
  }

  console.log();
  console.log(`  ${dim("Press Ctrl+C to stop")}`);
  console.log();

  const server = createServer(port, hooksConfig);
  await logEvent("server_started", { port });
}

main();
